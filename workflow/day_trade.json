{
  "name": "Alpaca Option MultiTF DMI/TD (1m/15m/60m)",
  "nodes": [
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "string": [
            {
              "name": "Ticker",
              "value": "={{ $json.ticker }}"
            },
            {
              "name": "intervals",
              "value": "={{$node[\"Set Request\"].json.intervals}}"
            },
            {
              "name": "effective_end",
              "value": "={{$node[\"Set Request\"].json.effective_end}}"
            }
          ],
          "number": [
            {
              "name": "dmiPeriod",
              "value": 14
            }
          ]
        },
        "options": {}
      },
      "id": "33887430-6300-4d26-9809-665470adc03a",
      "name": "Set Params",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        29440,
        33792
      ]
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        30624,
        33776
      ],
      "id": "6708790b-3abe-440d-8c09-a2337ceb799b",
      "name": "Merge"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "123"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        34688,
        33840
      ],
      "id": "2044c669-93a9-4ece-9423-fd6fcb3ba539",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "jsCode": "const fmt = d => d.toISOString().split('.')[0] + '.000Z';\n\nconst now = new Date();\nconst to = fmt(now);\n\n// 24 hours ago (86,400,000 ms)\nconst fromDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);\nconst from = fmt(fromDate);\n\nreturn {\n  from,\n  to,\n  now: to\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        36880,
        33424
      ],
      "id": "4fbf9253-3313-48a4-9975-efc31eeae3a6",
      "name": "Create Chart ID"
    },
    {
      "parameters": {
        "url": "=https://query1.finance.yahoo.com/v1/finance/search?q={{ $json.symbol}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        29104,
        33792
      ],
      "id": "aca03358-7a3e-4eb9-827c-b222b7b9760a",
      "name": "Search ticker on yahoo finance"
    },
    {
      "parameters": {
        "jsCode": "const data = items[0].json;\n\nlet ticker = \"UNKNOWN\";\nif (data.quotes && data.quotes.length > 0) {\n  ticker = data.quotes[0].symbol.toUpperCase();\n}\n\nreturn [{ json: { ticker } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        29280,
        33792
      ],
      "id": "85afdc65-97c4-4654-9d4f-eac4ec77697c",
      "name": "Code Sticker"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// n8n Code node: Output Telegram\n// MODE: Run Once for Each Item\n//\n// FIXES:\n// - Pull deterministic context from Compute Trend & Confidence + Compare Candidates (avoid \"n/a\")\n// - Prevent AI from overriding workflow truth (only explanatory allowlist)\n// - If workflow did not provide option_decision, accept AI option_decision (still subject to gates)\n// - If AI was overridden to WAIT, prepend WHY WAIT (time gate / liquidity / missing candidate_pass / RR extreme guardrail / missing levels)\n\nfunction isPlainObject(x) {\n  return x != null && typeof x === \"object\" && !Array.isArray(x);\n}\n\nfunction safeNum(x) {\n  if (typeof x === \"number\" && Number.isFinite(x)) return x;\n  if (typeof x === \"string\") {\n    const n = Number.parseFloat(x);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\nfunction safeStr(x) {\n  if (x == null) return null;\n  const s = String(x).trim();\n  return s === \"\" ? null : s;\n}\n\nfunction stripCodeFences(s) {\n  if (typeof s !== \"string\") return s;\n  let t = s.trim();\n  t = t.replace(/^```(?:json)?\\s*/i, \"\");\n  t = t.replace(/\\s*```$/i, \"\");\n  return t.trim();\n}\n\nfunction parseMaybeJson(x) {\n  if (x == null) return null;\n  if (typeof x === \"object\") return x;\n  if (typeof x !== \"string\") return null;\n  const t = stripCodeFences(x);\n  if (!t) return null;\n  try {\n    return JSON.parse(t);\n  } catch {\n    return null;\n  }\n}\n\nfunction mergePreferDefined(target, source) {\n  if (!isPlainObject(source)) return target;\n  for (const [k, v] of Object.entries(source)) {\n    if (v === undefined || v === null) continue;\n    if (isPlainObject(v) && isPlainObject(target[k])) {\n      target[k] = mergePreferDefined({ ...target[k] }, v);\n    } else {\n      target[k] = v;\n    }\n  }\n  return target;\n}\n\nfunction safeFirstJson(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    if (!Array.isArray(arr) || arr.length === 0) return {};\n    if (arr.length === 1) return arr[0].json ?? {};\n    return (arr[$itemIndex]?.json ?? arr[0]?.json ?? {});\n  } catch {\n    return {};\n  }\n}\n\nfunction findAiRaw(obj) {\n  const cands = [\n    obj?.output,\n    obj?.ai?.output,\n    obj?.ai_output,\n    obj?.aiOutput,\n    obj?.llm?.output,\n    obj?.agent?.output,\n    obj?.normalize_confidence?.output,\n    obj?.ai_result?.output,\n  ];\n  for (const v of cands) {\n    if (typeof v === \"string\" && v.trim()) return v;\n  }\n  // Sometimes output is an array like: [{ output: \"{...json...}\" }]\n  if (\n    Array.isArray(obj?.output) &&\n    obj.output.length === 1 &&\n    typeof obj.output[0]?.output === \"string\"\n  ) {\n    return obj.output[0].output;\n  }\n  // Last resort: scan top-level string fields for JSON-ish content\n  if (obj && typeof obj === \"object\") {\n    for (const v of Object.values(obj)) {\n      if (typeof v === \"string\" && v.includes(\"{\") && v.includes(\"}\")) return v;\n    }\n  }\n  return null;\n}\n\nfunction normOptDecision(v) {\n  if (!v) return \"WAIT\";\n  const s = String(v).trim().toUpperCase();\n  if (s === \"BUY_CALL\" || s === \"BUY_PUT\" || s === \"WAIT\") return s;\n  return \"WAIT\";\n}\n\nfunction fmtStr(x, dp = 2) {\n  const n = safeNum(x);\n  if (n == null) return \"n/a\";\n  return Number(n.toFixed(dp));\n}\n\nfunction fmtPctSmart(x) {\n  const n = safeNum(x);\n  if (n == null) return \"n/a\";\n  return `${(n * 100).toFixed(2)}%`;\n}\n\nfunction fmtDelta(x) {\n  const n = safeNum(x);\n  if (n == null) return \"n/a\";\n  return (n >= 0 ? \"+\" : \"\") + n.toFixed(3);\n}\n\nfunction inferSideFromOptDecision(dec) {\n  if (dec === \"BUY_PUT\") return \"PUT\";\n  if (dec === \"BUY_CALL\") return \"CALL\";\n  return null;\n}\n\n// --------------------------------------------------\n// 1) Parse AI output (but DO NOT merge it wholesale)\n// --------------------------------------------------\nconst aiRaw = findAiRaw($json);\nconst aiParsed = parseMaybeJson(aiRaw);\n\nlet aiPlan = {};\nif (isPlainObject(aiParsed)) aiPlan = aiParsed;\nelse if (\n  Array.isArray(aiParsed) &&\n  aiParsed.length === 1 &&\n  isPlainObject(aiParsed[0])\n) {\n  aiPlan = aiParsed[0];\n}\n\n// --------------------------------------------------\n// 2) Build deterministic payload (source of truth)\n// --------------------------------------------------\nlet trend = {};\ntry {\n  trend = $node[\"Compute Trend & Confidence\"].json ?? {};\n} catch {\n  trend = {};\n}\nif (!isPlainObject(trend) || Object.keys(trend).length === 0) {\n  trend = safeFirstJson(\"Compute Trend & Confidence\");\n}\n\nlet basePlan = {};\ntry {\n  basePlan = $node[\"Compare Candidates\"].json ?? {};\n} catch {\n  basePlan = {};\n}\nif (!isPlainObject(basePlan) || Object.keys(basePlan).length === 0) {\n  basePlan = safeFirstJson(\"Compare Candidates\");\n}\n\nlet enrich = {};\ntry {\n  enrich = $node[\"Enrich Payload for AI\"].json ?? {};\n} catch {\n  enrich = {};\n}\nif (!isPlainObject(enrich) || Object.keys(enrich).length === 0) {\n  enrich = safeFirstJson(\"Enrich Payload for AI\");\n}\n\nconst payload = {};\nmergePreferDefined(payload, trend);\nmergePreferDefined(payload, basePlan);\nmergePreferDefined(payload, enrich);\n\n// --------------------------------------------------\n// FIX: clear stale liquidity reason / keep spread consistent\n// - Downstream merges often skip nulls, so an earlier non-null reason can \"stick\"\n//   even after later nodes set option_liquidity_ok=true.\n// --------------------------------------------------\nconst liqOkFinal =\n  (enrich.option_liquidity_ok === true || enrich.option_liquidity_ok === false)\n    ? enrich.option_liquidity_ok\n    : ((basePlan.option_liquidity_ok === true || basePlan.option_liquidity_ok === false)\n        ? basePlan.option_liquidity_ok\n        : (payload.option_liquidity_ok === true || payload.option_liquidity_ok === false ? payload.option_liquidity_ok : null));\n\nif (liqOkFinal === true) {\n  payload.option_liquidity_ok = true;\n  payload.option_liquidity_reason = null;\n} else if (liqOkFinal === false) {\n  payload.option_liquidity_ok = false;\n  payload.option_liquidity_reason =\n    safeStr(enrich.option_liquidity_reason) ??\n    safeStr(basePlan.option_liquidity_reason) ??\n    safeStr(payload.option_liquidity_reason) ??\n    null;\n}\n\n// Ensure displayed spread uses the same source as the liquidity gate (prefer enrich quote)\nconst spreadFinal =\n  safeNum(enrich.option_spread_pct) ??\n  safeNum(enrich.optionContext?.quote?.spread_pct) ??\n  safeNum(payload.option_spread_pct);\n\nif (spreadFinal != null) payload.option_spread_pct = spreadFinal;\n\n// If liquidity gate says \"too wide\", but spread is actually within limit, prefer recompute for consistency\nconst maxSp =\n  safeNum(enrich.max_spread_pct) ??\n  safeNum(basePlan.max_spread_pct) ??\n  safeNum(payload.max_spread_pct);\n\nif (maxSp != null && spreadFinal != null) {\n  if (spreadFinal <= maxSp) {\n    payload.option_liquidity_ok = true;\n    payload.option_liquidity_reason = null;\n  } else {\n    payload.option_liquidity_ok = false;\n    payload.option_liquidity_reason =\n      payload.option_liquidity_reason ??\n      `Spread too wide: ${(spreadFinal * 100).toFixed(2)}% > ${(maxSp * 100).toFixed(2)}%`;\n  }\n}\n\n// Merge current item ONLY for non-AI, non-critical fields (avoid AI overriding truth)\nconst current = isPlainObject($json) ? $json : {};\nconst aiTopKeys = new Set(Object.keys(aiPlan || {}));\nconst deny = new Set([\n  ...aiTopKeys,\n  \"optionContext\",\n  \"key_factors\",\n  \"plain_explanation\",\n  \"explanation\",\n]);\n\nfor (const [k, v] of Object.entries(current)) {\n  if (v === undefined || v === null) continue;\n  if (deny.has(k)) continue;\n  // only fill missing top-level fields (don't override deterministic)\n  if (payload[k] === undefined || payload[k] === null) payload[k] = v;\n}\n\n// --------------------------------------------------\n// 3) Allowlist AI fields: explanation only\n// --------------------------------------------------\npayload.ai_debug = {\n  desired_option_right_ai: aiPlan.desired_option_right ?? null,\n  option_contract_symbol_ai: aiPlan.option_contract_symbol ?? null,\n  option_decision_ai: aiPlan.option_decision ?? null,\n  confidence_ai: aiPlan.confidence ?? null,\n};\n\nif (Array.isArray(aiPlan.key_factors)) payload.key_factors = aiPlan.key_factors;\n\nlet explanation =\n  typeof aiPlan.plain_explanation === \"string\" && aiPlan.plain_explanation.trim()\n    ? aiPlan.plain_explanation.trim()\n    : typeof aiPlan.explanation === \"string\" && aiPlan.explanation.trim()\n      ? aiPlan.explanation.trim()\n      : typeof payload.plain_explanation === \"string\"\n        ? payload.plain_explanation.trim()\n        : \"\";\n\n// --------------------------------------------------\n// 4) Pull summary fields\n// --------------------------------------------------\nconst ticker = payload.ticker || \"n/a\";\nconst tf = payload.overall_timeframe || payload.timeframes || \"n/a\";\n\nconst direction =\n  payload.trend_direction_pre ||\n  payload.trend_direction ||\n  payload.direction ||\n  aiPlan.trend_direction ||\n  \"n/a\";\n\nconst strength =\n  payload.trend_strength_pre ||\n  payload.trend_strength ||\n  aiPlan.trend_strength ||\n  \"n/a\";\n\nconst strengthScore =\n  safeNum(payload.trend_strength_score_pre) ??\n  safeNum(payload.trend_strength_score) ??\n  safeNum(aiPlan.trend_strength_score);\n\nconst strengthScoreTxt = strengthScore != null ? Math.round(strengthScore) : \"n/a\";\n\nconst alignment =\n  payload.alignment_pre || payload.alignment || aiPlan.alignment || \"n/a\";\n\nconst adxConf =\n  payload.adx_confirmation_pre ||\n  payload.adx_confirmation ||\n  aiPlan.adx_confirmation ||\n  \"n/a\";\n\nconst bias =\n  payload.technical_bias || payload.bias || aiPlan.technical_bias || \"n/a\";\n\nconst conf =\n  safeNum(payload.confidence_pre) ??\n  safeNum(payload.confidence) ??\n  safeNum(aiPlan.confidence);\n\nconst confTxt =\n  conf != null ? `${Math.round(conf > 1 ? conf : conf * 100)}%` : \"n/a\";\n\nconst trig = safeNum(payload.trigger_price);\nconst inv = safeNum(payload.invalidation_level);\nconst tgt = safeNum(payload.target_level);\n\nconst missingLevels = trig == null || inv == null || tgt == null;\n\n// --------------------------------------------------\n// 5) Decision + WHY WAIT logic\n// --------------------------------------------------\nconst aiOptDecisionRaw = normOptDecision(aiPlan.option_decision);\nconst aiOptDecision = aiOptDecisionRaw;\n\nconst optDecision = normOptDecision(\n  payload.option_decision ||\n    payload.option_trade_decision ||\n    aiPlan.option_decision ||\n    \"WAIT\"\n);\n\n// If workflow did not provide a deterministic option_decision, accept the AI decision (still subject to gates)\nif (\n  payload.option_decision == null &&\n  payload.option_trade_decision == null &&\n  aiPlan.option_decision != null\n) {\n  payload.option_decision = normOptDecision(aiPlan.option_decision);\n}\n\nconst overrideReasons = [];\nif (payload.time_gate_ok === false)\n  overrideReasons.push(\n    `time_gate_ok=false (${payload.time_gate_reason ?? \"n/a\"})`\n  );\nif (payload.option_liquidity_ok === false)\n  overrideReasons.push(\n    `option_liquidity_ok=false (${payload.option_liquidity_reason ?? \"n/a\"})`\n  );\n\nif (payload.candidate_pass === false) overrideReasons.push(\"candidate_pass=false\");\nif (payload.candidate_pass == null)\n  overrideReasons.push(\n    \"candidate_pass is missing (treated as fail by Compare Candidates)\"\n  );\n\nconst rr = safeNum(payload.option_risk_reward);\nconst RR_WAY_TOO_LOW = 0.6;\nif (rr != null && rr < RR_WAY_TOO_LOW) {\n  overrideReasons.push(\n    `option_risk_reward ${rr.toFixed(2)} < ${RR_WAY_TOO_LOW} (RR way too low)`\n  );\n}\n\nif (missingLevels)\n  overrideReasons.push(\"missing underlying levels (trigger/invalidation/target)\");\n\nif (aiOptDecision !== \"WAIT\" && optDecision === \"WAIT\") {\n  const reasonTxt2 = overrideReasons.length\n    ? overrideReasons.join(\"; \")\n    : \"deterministic rules forced WAIT\";\n  const note = `NOTE: AI suggested ${aiOptDecisionRaw}, but overridden to WAIT: ${reasonTxt2}.`;\n  explanation = explanation ? `${note}\\n${explanation}` : note;\n  payload.plain_explanation = explanation;\n}\n\nif (!explanation) explanation = \"n/a\";\n\n// Winner / Other\nconst winnerSide =\n  String(payload.winner_side || \"\").toUpperCase().trim() ||\n  String(payload.candidate_side || \"\").toUpperCase().trim() ||\n  inferSideFromOptDecision(optDecision) ||\n  \"n/a\";\n\n// keep ONLY ONE \"other\" variable\nconst otherCand = isPlainObject(payload.other_candidate) ? payload.other_candidate : null;\n\n// Option quote\nconst right =\n  payload.desired_option_right ||\n  payload.winner_right ||\n  payload.option_right ||\n  payload.right ||\n  aiPlan.desired_option_right ||\n  \"n/a\";\n\nconst sym =\n  payload.option_contract_symbol ||\n  payload.option_symbol ||\n  aiPlan.option_contract_symbol ||\n  \"n/a\";\n\nconst bid = safeNum(payload.option_bid ?? payload.quote?.bid);\nconst ask = safeNum(payload.option_ask ?? payload.quote?.ask);\nconst mid = safeNum(payload.option_mid ?? payload.quote?.mid);\nconst sp = safeNum(payload.option_spread_pct ?? payload.quote?.spread_pct);\n\nconst entry = safeNum(payload.option_entry_premium);\nconst stop = safeNum(payload.option_stop_premium);\nconst tp = safeNum(payload.option_take_profit_premium);\nconst rrTxt =\n  safeNum(payload.option_risk_reward) != null\n    ? Number(safeNum(payload.option_risk_reward).toFixed(2))\n    : \"n/a\";\n\n// Underlying RR (optional)\nconst uRR = safeNum(payload.underlying_risk_reward);\nconst uRRTxt = uRR != null ? Number(uRR.toFixed(2)) : \"n/a\";\n\n// --------------------------------------------------\n// 6) Render Telegram message\n// --------------------------------------------------\nconst lines = [];\n\nlines.push(\"Options Multi-TF Summary\");\nlines.push(`Ticker: ${ticker}`);\nlines.push(`Timeframes: ${tf}`);\nlines.push(`Direction: ${direction}`);\nlines.push(`Strength: ${strength} (score ${strengthScoreTxt})`);\nlines.push(`Alignment: ${alignment}`);\nlines.push(`ADX confirmation: ${adxConf}`);\nlines.push(`Bias: ${bias}`);\nlines.push(`Confidence: ${confTxt}`);\nlines.push(\n  `Underlying Levels: Trigger: ${fmtStr(trig, 2)} | Invalidation: ${fmtStr(inv, 2)} | Target: ${fmtStr(tgt, 2)}`\n);\n\n// --- Candlestick summaries (Hammer / Engulfing / ShootingStar) ---\ntry {\n  const tfs =\n    payload.timeframes && typeof payload.timeframes === \"object\"\n      ? Object.keys(payload.timeframes)\n      : [];\n  if (tfs.length) {\n    lines.push(\"\");\n    lines.push(\"\ud83d\udd6f Candles (Hammer / BullEngulf / BearEngulf / ShootingStar)\");\n    for (const tfKey of tfs) {\n      const h = payload.timeframes?.[tfKey]?.hammer;\n      const e = payload.timeframes?.[tfKey]?.bullish_engulfing;\n      const be = payload.timeframes?.[tfKey]?.bearish_engulfing;\n      const s = payload.timeframes?.[tfKey]?.shooting_star;\n\n      const parts = [];\n\n      if (h && h.present === true) parts.push(`Hammer=${h.type || \"hammer\"} \u2705`);\n      else parts.push(\"Hammer=none\");\n\n      if (e && e.present === true)\n        parts.push(`BullEngulf=${e.type || \"bullish_engulfing\"} \u2705`);\n      else parts.push(\"BullEngulf=none\");\n\n      if (be && be.present === true)\n        parts.push(`BearEngulf=${be.type || \"bearish_engulfing\"} \u2705`);\n      else parts.push(\"BearEngulf=none\");\n\n      if (s && s.present === true)\n        parts.push(`ShootingStar=${s.type || \"shooting_star\"} \u2705`);\n      else parts.push(\"ShootingStar=none\");\n\n      lines.push(`${tfKey}: ${parts.join(\" | \")}`);\n    }\n  }\n} catch (e) {}\n\nlines.push(\"\");\nlines.push(\"\ud83e\udded Candidate Compare\");\n\n// Pull compare metadata (if present)\nconst cc =\n  payload.candidate_compare && typeof payload.candidate_compare === \"object\"\n    ? payload.candidate_compare\n    : {};\n\nconst desiredSide =\n  cc.desired_side != null ? String(cc.desired_side).toUpperCase() : null;\nconst desiredTxt = desiredSide || \"n/a\";\nconst reasonTxt =\n  cc.reason != null ? String(cc.reason) : \"compare_lexicographic\";\n\nlines.push(`Desired: ${desiredTxt} | ${reasonTxt}`);\nif (cc.desired_source) lines.push(`Desired source: ${cc.desired_source}`);\nif (cc.desired_inputs && typeof cc.desired_inputs === \"object\") {\n  const b = cc.desired_inputs.bias ?? \"n/a\";\n  const t = cc.desired_inputs.trend ?? \"n/a\";\n  const d = cc.desired_inputs.derived_right ?? \"n/a\";\n  lines.push(\n    `Desired inputs: bias=${b ?? \"n/a\"} | trend=${t ?? \"n/a\"} | derived_right=${d ?? \"n/a\"}`\n  );\n}\n\n// Build CALL/PUT views from winner + other_candidate.\nfunction normSide2(v) {\n  if (!v) return null;\n  const s = String(v).trim().toUpperCase();\n  if (s === \"CALL\" || s === \"C\") return \"CALL\";\n  if (s === \"PUT\" || s === \"P\") return \"PUT\";\n  return null;\n}\n\nfunction pickOI(obj) {\n  return (\n    safeNum(obj?.selected?.open_interest) ??\n    safeNum(obj?.open_interest) ??\n    safeNum(obj?.selected?.oi) ??\n    null\n  );\n}\n\nfunction pickQuoteAgeSec(obj) {\n  const qas = safeNum(obj?.option_quote_age_sec ?? obj?.quote_age_sec);\n  if (qas != null) return Math.max(0, Math.round(qas));\n  const qt = obj?.option_quote_time ?? obj?.quote_time ?? null;\n  const gt = payload?.generatedAt ?? payload?.generated_at ?? null;\n  try {\n    if (qt) {\n      const t0 = Date.parse(String(qt));\n      const t1 = gt ? Date.parse(String(gt)) : Date.now();\n      if (Number.isFinite(t0) && Number.isFinite(t1))\n        return Math.max(0, Math.round((t1 - t0) / 1000));\n    }\n  } catch {}\n  return null;\n}\n\nfunction scoreParts(obj, desiredSideUpper) {\n  const side =\n    normSide2(obj?.candidate_side) ??\n    normSide2(obj?.option_right) ??\n    normSide2(obj?.right) ??\n    normSide2(obj?.option_intent?.right);\n\n  const passOk = obj?.candidate_pass === true ? 1 : 0;\n  const liqOk = obj?.option_liquidity_ok === true ? 1 : 0;\n  const sideMatch =\n    desiredSideUpper && side && side === desiredSideUpper ? 1 : 0;\n\n  const rr = safeNum(obj?.option_risk_reward);\n  const rrRank =\n    rr == null ? 0 : Math.max(0, Math.min(9999, Math.round(rr * 100)));\n\n  const spv = safeNum(obj?.option_spread_pct);\n  const spBps = spv == null ? null : Math.round(spv * 10000);\n  const spRank =\n    spBps == null ? 0 : Math.max(0, Math.min(9999, 9999 - spBps));\n\n  const oi = pickOI(obj);\n  const oiRank =\n    oi == null ? 0 : Math.max(0, Math.min(9999, Math.round(oi)));\n\n  const score =\n    passOk * 1000000 +\n    liqOk * 100000 +\n    sideMatch * 10000 +\n    rrRank +\n    spRank +\n    oiRank;\n\n  return { side, passOk, liqOk, sideMatch, rr, sp: spv, oi, score, rrRank, spBps, spRank, oiRank };\n}\n\nfunction explainTie(callP, putP) {\n  if (callP.passOk !== putP.passOk) {\n    return { key: \"passOk\", why: `pass: CALL=${callP.passOk} vs PUT=${putP.passOk} (higher wins)` };\n  }\n  if (callP.liqOk !== putP.liqOk) {\n    return { key: \"liqOk\", why: `liq: CALL=${callP.liqOk} vs PUT=${putP.liqOk} (higher wins)` };\n  }\n  if (callP.sideMatch !== putP.sideMatch) {\n    return {\n      key: \"sideMatch\",\n      why: `desired_side=${desiredTxt} \u2192 ${desiredTxt === \"CALL\" ? \"CALL\" : \"PUT\"} sideMatch=1 beats ${desiredTxt === \"CALL\" ? \"PUT\" : \"CALL\"}=0`,\n    };\n  }\n\n  const callRR = callP.rr;\n  const putRR = putP.rr;\n  if ((callRR != null) !== (putRR != null)) {\n    return { key: \"rrScore\", why: `RR: ${callRR != null ? \"CALL has RR\" : \"CALL RR=n/a\"} vs ${putRR != null ? \"PUT has RR\" : \"PUT RR=n/a\"} (present wins)` };\n  }\n  if (callRR != null && putRR != null && callRR !== putRR) {\n    const win = callRR > putRR ? \"CALL\" : \"PUT\";\n    return { key: \"rrScore\", why: `RR: CALL=${callRR.toFixed(2)} vs PUT=${putRR.toFixed(2)} (higher wins \u2192 ${win})` };\n  }\n\n  const callSP = callP.sp;\n  const putSP = putP.sp;\n  if ((callSP != null) !== (putSP != null)) {\n    return { key: \"spScore\", why: `spread: ${callSP != null ? \"CALL has spread\" : \"CALL spread=n/a\"} vs ${putSP != null ? \"PUT has spread\" : \"PUT spread=n/a\"} (present wins)` };\n  }\n  if (callSP != null && putSP != null && callSP !== putSP) {\n    const win = callSP < putSP ? \"CALL\" : \"PUT\";\n    const a = (callSP * 100).toFixed(2);\n    const b = (putSP * 100).toFixed(2);\n    return { key: \"spScore\", why: `spread: ${win}=${win === \"CALL\" ? a : b}% vs ${win === \"CALL\" ? \"PUT\" : \"CALL\"}=${win === \"CALL\" ? b : a}% (lower wins)` };\n  }\n\n  if ((callP.oi != null) !== (putP.oi != null)) {\n    return { key: \"oiScore\", why: `OI: ${callP.oi != null ? \"CALL has OI\" : \"CALL OI=n/a\"} vs ${putP.oi != null ? \"PUT has OI\" : \"PUT OI=n/a\"} (present wins)` };\n  }\n  if (callP.oi != null && putP.oi != null && callP.oi !== putP.oi) {\n    const win = callP.oi > putP.oi ? \"CALL\" : \"PUT\";\n    return { key: \"oiScore\", why: `OI: CALL=${Math.round(callP.oi)} vs PUT=${Math.round(putP.oi)} (higher wins \u2192 ${win})` };\n  }\n\n  return { key: \"tie\", why: \"all compare keys equal (tie)\" };\n}\n\n// Identify winner & candidates (FIX: no redeclare of `other`)\nconst winnerSideNorm =\n  normSide2(payload?.winner_side) ??\n  normSide2(payload?.candidate_side) ??\n  winnerSide;\n\nlet callObj = null;\nlet putObj = null;\n\nif (winnerSideNorm === \"CALL\") {\n  callObj = payload;\n  putObj = otherCand;\n} else if (winnerSideNorm === \"PUT\") {\n  putObj = payload;\n  callObj = otherCand;\n} else {\n  const wRight = normSide2(payload?.option_right ?? payload?.right);\n  if (wRight === \"CALL\") {\n    callObj = payload;\n    putObj = otherCand;\n  } else if (wRight === \"PUT\") {\n    putObj = payload;\n    callObj = otherCand;\n  }\n}\n\n// Winner line\nlines.push(`Winner: ${winnerSideNorm || winnerSide}`);\n\n// If we have both, print WHY + both sides\nif (callObj && putObj) {\n  const callP = scoreParts(callObj, desiredSide);\n  const putP = scoreParts(putObj, desiredSide);\n  const exp = explainTie(callP, putP);\n\n  lines.push(`Why: ${exp.why}`);\n  lines.push(`Tie-break: ${exp.key}`);\n\n  function fmtLine(sideLabel, obj, parts) {\n    const sym2 =\n      obj?.option_contract_symbol || obj?.selected?.symbol || obj?.symbol || \"n/a\";\n\n    const pass =\n      obj?.candidate_pass === true || obj?.candidate_pass === false\n        ? String(obj.candidate_pass)\n        : \"n/a\";\n\n    const sp2 = fmtPctSmart(obj?.option_spread_pct);\n\n    const rr2 =\n      safeNum(obj?.option_risk_reward) != null\n        ? Number(safeNum(obj?.option_risk_reward).toFixed(2))\n        : \"n/a\";\n\n    const delta2 = fmtDelta(obj?.option_delta);\n\n    const liq =\n      obj?.option_liquidity_ok === true || obj?.option_liquidity_ok === false\n        ? String(obj.option_liquidity_ok)\n        : \"n/a\";\n\n    const qa = pickQuoteAgeSec(obj);\n    const qaTxt = qa == null ? \"n/a\" : `${qa}s`;\n\n    lines.push(\n      `${sideLabel}: ${sideLabel} | ${sym2} | pass=${pass} | score=${parts.score} | spread%=${sp2} | RR=${rr2} | \u0394 ${delta2} | liq=${liq} | quoteAge=${qaTxt}`\n    );\n\n    const spTxt =\n      safeNum(obj?.option_spread_pct) != null\n        ? `${(safeNum(obj.option_spread_pct) * 100).toFixed(2)}%`\n        : \"n/a\";\n\n    const oiTxt = parts.oi != null ? Math.round(parts.oi) : \"n/a\";\n    const rrTxt2 = parts.rr != null ? parts.rr.toFixed(2) : \"n/a\";\n\n    lines.push(\n      `   \u21b3 score_detail: pass=${parts.passOk}, liq=${parts.liqOk}, sideMatch=${parts.sideMatch}, RR=${rrTxt2}, spread=${spTxt}, OI=${oiTxt} => score=${parts.score}`\n    );\n  }\n\n  fmtLine(\"CALL\", callObj, callP);\n  fmtLine(\"PUT\", putObj, putP);\n} else {\n  // Fallback if only one side present\n  const otherCandidate = otherCand;\n  if (otherCandidate) {\n    const oSide = String(otherCandidate.candidate_side || \"n/a\").toUpperCase();\n    const oSym = otherCandidate.option_contract_symbol || \"n/a\";\n    const oPass =\n      otherCandidate.candidate_pass === true || otherCandidate.candidate_pass === false\n        ? String(otherCandidate.candidate_pass)\n        : \"n/a\";\n    const oSp = fmtPctSmart(otherCandidate.option_spread_pct);\n    const oRR =\n      safeNum(otherCandidate.option_risk_reward) != null\n        ? Number(safeNum(otherCandidate.option_risk_reward).toFixed(2))\n        : \"n/a\";\n    const oDelta = fmtDelta(otherCandidate.option_delta);\n    lines.push(`Other: ${oSide} | ${oSym} | pass=${oPass} | spread%=${oSp} | RR=${oRR} | \u0394 ${oDelta}`);\n  } else {\n    lines.push(\"Other: N/A\");\n  }\n}\n\nlines.push(\"\");\nlines.push(\"\ud83e\uddfe Option Trade Plan\");\nlines.push(\n  `Decision: ${\n    optDecision === \"WAIT\"\n      ? \"\ud83d\udfe1 WAIT\"\n      : optDecision === \"BUY_PUT\"\n        ? \"\ud83d\udd34 BUY_PUT\"\n        : \"\ud83d\udfe2 BUY_CALL\"\n  } @ ${sym}`\n);\nlines.push(\n  `Quote: Right: ${right} | Bid: ${fmtStr(bid, 2)} | Ask: ${fmtStr(ask, 2)} | Mid: ${fmtStr(mid, 3)} | Spread%: ${fmtPctSmart(sp)}`\n);\nlines.push(\n  `Entry: ${fmtStr(entry, 2)} | Stop: ${fmtStr(stop, 2)} | TP: ${fmtStr(tp, 2)} | R:R ${rrTxt}`\n);\n\nlines.push(\"\");\nlines.push(\"\ud83e\uddfe Trade Plan (Underlying)\");\nlines.push(`Decision: \ud83d\udfe1 WAIT @ ${fmtStr(trig, 2)}`);\nlines.push(\n  `Entry: ${fmtStr(trig, 2)} | Stop: ${fmtStr(inv, 2)} | TP: ${fmtStr(tgt, 2)} | R:R ${uRRTxt}`\n);\n\nif (Array.isArray(payload.key_factors) && payload.key_factors.length) {\n  lines.push(\"\");\n  lines.push(\"Key factors:\");\n  for (const k of payload.key_factors) lines.push(`\u2022 ${String(k)}`);\n}\n\nlines.push(\"\");\nlines.push(`Explanation: ${explanation}`);\n\nreturn { json: { ...payload, text: lines.join(\"\\n\") } };\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        35392,
        33456
      ],
      "id": "153ccca9-46bd-4042-ad35-88a5a65d5589",
      "name": "Output Telegram"
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{$json.text.replace(/_/g,'\\\\_')}}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        36704,
        33424
      ],
      "id": "04fa1144-c19e-4084-aa03-1406cbd54516",
      "name": "Send a text message",
      "webhookId": "f0e18d53-5a73-4e3a-b9f7-6d6bc8d2924f",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node\n\nfunction getText(item) {\n  return (\n    item.json?.message?.text ??\n    item.json?.body?.message?.text ??\n    item.json?.text ??\n    item.json?.message ??\n    item.json?.body?.text ??\n    \"\"\n  );\n}\n\nconst item = items[0];\nconst textRaw = String(getText(item)).trim();\n\n// Matches:\n// \"SPY\"\n// \"SPY S\"\n// \"SPY M\"\n// \"SPY L\"\nconst m = textRaw.match(/^\\s*([A-Za-z0-9.\\-_]{1,15})(?:\\s+([SMLsml]))?\\b/);\n\nif (!m) {\n  throw new Error(`Cannot parse Telegram message text: \"${textRaw}\"`);\n}\n\nconst symbol = m[1].toUpperCase();\nconst profile = (m[2] ? m[2].toUpperCase() : \"S\"); // <-- default to S\n\nconst profileMap = {\n  S: [\"2m\", \"3m\", \"5m\"],\n  M: [\"1m\", \"5m\", \"15m\"],\n  L: [\"5m\", \"1h\", \"1d\"], // daily = 1d\n};\n\nconst intervals = profileMap[profile];\nif (!intervals) {\n  throw new Error(`Unknown profile \"${profile}\". Use S, M, or L. Input was: \"${textRaw}\"`);\n}\n\nreturn [\n  {\n    json: {\n      symbol,\n      mode:\"MANUAL\",\n      chatId:$input.first().json.message.chat.id,\n      profile,                     // S/M/L\n      intervals,                   // [\"1m\",\"2m\",\"5m\"] etc\n      intervals_csv: intervals.join(\",\"),\n      route: `${symbol}_${profile}`, // e.g. \"SPY_S\"\n      telegram_text: textRaw,\n      requested_at: new Date().toISOString(),\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        28736,
        33792
      ],
      "id": "22e3c13f-038c-4d31-aaa1-7704c0c91b6d",
      "name": "Get Profile"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node\n// AFTER Merge node, BEFORE AI node (multi-timeframe DMI + Demark + Price Structure)\n\nfunction safeNum(x) {\n  if (typeof x === 'number' && Number.isFinite(x)) return x;\n  if (typeof x === 'string') {\n    const n = Number.parseFloat(x);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\nfunction dmiDirection(diPlus, diMinus) {\n  if (diPlus == null || diMinus == null) return 'unknown';\n  if (diPlus > diMinus) return 'bullish';\n  if (diMinus > diPlus) return 'bearish';\n  return 'flat';\n}\n\nfunction adxStrength(adx) {\n  if (adx == null) return 'unknown';\n  if (adx >= 50) return 'very_strong';\n  if (adx >= 25) return 'moderate';\n  return 'weak';\n}\n\nfunction adxSlope3(series) {\n  if (!Array.isArray(series)) return null;\n  const valid = series.map(p => safeNum(p?.adx)).filter(v => v != null);\n  if (valid.length < 3) return null;\n  return valid[valid.length - 1] - valid[valid.length - 3];\n}\n\nfunction normalizeTf(tf) {\n  if (!tf) return 'unknown';\n  const s = String(tf).trim();\n  if (s === '120s' || s === '2min') return '2m';\n  if (s === '60m') return '1h';\n  if (s.toLowerCase() === 'daily') return '1d';\n  return s;\n}\n\n// Convert timeframe label to minutes (for sorting HTF/MTF/LTF)\nfunction tfToMinutes(tf) {\n  const t = normalizeTf(tf);\n  const m = t.match(/^(\\d+)([mhd])$/i);\n  if (!m) return null;\n  const n = Number(m[1]);\n  const u = m[2].toLowerCase();\n  if (!Number.isFinite(n)) return null;\n  if (u === 'm') return n;\n  if (u === 'h') return n * 60;\n  if (u === 'd') return n * 60 * 24;\n  return null;\n}\n\n// ---- NEW: normalize/validate price object coming from your per-TF indicator node ----\nfunction normalizePrice(p) {\n  if (!p || typeof p !== 'object') {\n    return {\n      last_close: null,\n      last_high: null,\n      last_low: null,\n      swing_n: null,\n      swing_high_n: null,\n      swing_high_time: null,\n      swing_low_n: null,\n      swing_low_time: null,\n      atr_n: null,\n      atr_n_sma: null,\n      true_range_avg_n: null,\n      swing_effective_n: null,\n      atr_effective_n: null,\n      reason: 'missing_price'\n    };\n  }\n\n  return {\n    last_close: safeNum(p.last_close),\n    last_high:  safeNum(p.last_high),\n    last_low:   safeNum(p.last_low),\n\n    swing_n: safeNum(p.swing_n),\n    swing_high_n: safeNum(p.swing_high_n),\n    swing_high_time: p.swing_high_time ?? null,\n    swing_low_n: safeNum(p.swing_low_n),\n    swing_low_time: p.swing_low_time ?? null,\n\n    atr_n: safeNum(p.atr_n),\n    atr_n_sma: safeNum(p.atr_n_sma),\n    true_range_avg_n: safeNum(p.true_range_avg_n),\n\n    swing_effective_n: safeNum(p.swing_effective_n),\n    atr_effective_n: safeNum(p.atr_effective_n),\n\n    reason: p.reason ?? null\n  };\n}\n\n\n// ---- NEW: normalize/validate hammer pattern ----\nfunction normalizeHammer(h) {\n  if (!h || typeof h !== 'object') {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'missing_hammer'\n    };\n  }\n\n  return {\n    present: h.present === true,\n    type: h.type ?? null,\n    candleTime: h.candleTime ?? null,\n    bodyPct: safeNum(h.bodyPct),\n    lowerWickPct: safeNum(h.lowerWickPct),\n    upperWickPct: safeNum(h.upperWickPct),\n    reason: h.reason ?? null\n  };\n}\n\n\n// ---- NEW: normalize/validate shooting star pattern ----\nfunction normalizeShootingStar(s) {\n  if (!s || typeof s !== 'object') {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'missing_shooting_star'\n    };\n  }\n\n  return {\n    present: s.present === true,\n    type: s.type ?? null,\n    candleTime: s.candleTime ?? null,\n    bodyPct: safeNum(s.bodyPct),\n    lowerWickPct: safeNum(s.lowerWickPct),\n    upperWickPct: safeNum(s.upperWickPct),\n    reason: s.reason ?? null\n  };\n}\n\n// ---- NEW: normalize/validate bullish engulfing pattern ----\nfunction normalizeBullishEngulfing(e) {\n  if (!e || typeof e !== 'object') {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      prevTime: null,\n      prevBody: null,\n      currBody: null,\n      reason: 'missing_bullish_engulfing'\n    };\n  }\n\n  return {\n    present: e.present === true,\n    type: e.type ?? null,\n    candleTime: e.candleTime ?? null,\n    prevTime: e.prevTime ?? null,\n    prevBody: safeNum(e.prevBody),\n    currBody: safeNum(e.currBody),\n    reason: e.reason ?? null\n  };\n}\n\n\n\n// ---- NEW: normalize/validate bearish engulfing pattern ----\nfunction normalizeBearishEngulfing(e) {\n  if (!e || typeof e !== 'object') {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      prevTime: null,\n      prevBody: null,\n      currBody: null,\n      reason: 'missing_bearish_engulfing'\n    };\n  }\n\n  return {\n    present: e.present === true,\n    type: e.type ?? null,\n    candleTime: e.candleTime ?? null,\n    prevTime: e.prevTime ?? null,\n    prevBody: safeNum(e.prevBody),\n    currBody: safeNum(e.currBody),\n    reason: e.reason ?? null\n  };\n}\n\n// Pull from upstream nodes directly\nconst gp = $('Set Request').first()?.json ?? {};\nconst sp = $('Set Params').first()?.json ?? {};\n\n// intervals/profile from Set Request (or your Get Profile equivalent)\nconst EXPECTED = Array.isArray(gp.intervals) && gp.intervals.length\n  ? gp.intervals.map(normalizeTf)\n  : ['1m', '2m', '5m'];\n\nconst profile = gp.profile ?? gp.Profile ?? null;\n\n// ticker from Set Params\nconst tickerFromUpstream = sp.Ticker ?? sp.ticker ?? sp.symbol ?? null;\n\nconst timeframes = {};\nlet ticker = tickerFromUpstream;\n\n// ---- Build per-timeframe blocks ----\nfor (const it of items) {\n  const j = it.json || {};\n  const tf = normalizeTf(j.tf || j.timeframe || j.interval);\n\n  if (!ticker) ticker = j.ticker || j.Ticker || j.symbol || null;\n\n  const series = Array.isArray(j.dmiSeries) ? j.dmiSeries.slice(-12) : [];\n  const diPlus = safeNum(j.diPlus);\n  const diMinus = safeNum(j.diMinus);\n  const adx = safeNum(j.adx);\n\n  // NEW: include price structure coming from the per-TF indicator node\n  const price = normalizePrice(j.price);\n\n  // If duplicates for the same tf arrive, prefer one with status 'ok'\n  const candidate = {\n    status: j.status || 'ok',\n    reason: j.reason || null,\n\n    latest: { diPlus, diMinus, adx },\n\n    derived: {\n      direction: dmiDirection(diPlus, diMinus),\n      strength: adxStrength(adx),\n      adxSlope3: adxSlope3(series),\n    },\n\n    crossover: j.dmiSummary?.crossover || null,\n    series,\n\n    demark: j.demark || null,\n\n    // NEW: price structure block\n    price,\n\n    // NEW: candlestick pattern(s)\n    hammer: normalizeHammer(j.hammer),\n    shooting_star: normalizeShootingStar(j.shooting_star),\n    bullish_engulfing: normalizeBullishEngulfing(j.bullish_engulfing),\n    bearish_engulfing: normalizeBearishEngulfing(j.bearish_engulfing),\n  };\n\n  if (!timeframes[tf]) {\n    timeframes[tf] = candidate;\n  } else {\n    const prev = timeframes[tf];\n    if (prev.status !== 'ok' && candidate.status === 'ok') {\n      timeframes[tf] = candidate;\n    }\n  }\n}\n\n// Fill missing expected tfs\nfor (const tf of EXPECTED) {\n  if (!timeframes[tf]) {\n    timeframes[tf] = {\n      status: 'missing',\n      reason: 'No data merged for this timeframe',\n      latest: { diPlus: null, diMinus: null, adx: null },\n      derived: { direction: 'unknown', strength: 'unknown', adxSlope3: null },\n      crossover: null,\n      series: [],\n      demark: null,\n\n      // NEW: keep schema stable\n      price: normalizePrice(null),\n\n      // NEW: keep schema stable\n      hammer: normalizeHammer(null),\n\n      // NEW: keep schema stable\n      bullish_engulfing: normalizeBullishEngulfing(null),\n    };\n  }\n}\n\n// ---- Alignment logic (auto: HTF/MTF/LTF based on duration) ----\nconst sorted = [...EXPECTED]\n  .map(tf => ({ tf, mins: tfToMinutes(tf) }))\n  .sort((a, b) => (a.mins ?? 1e15) - (b.mins ?? 1e15));\n\nconst ltf = sorted[0]?.tf;\nconst mtf = sorted[Math.floor(sorted.length / 2)]?.tf;\nconst htf = sorted[sorted.length - 1]?.tf;\n\nconst dHTF = timeframes[htf]?.derived?.direction ?? 'unknown';\nconst dMTF = timeframes[mtf]?.derived?.direction ?? 'unknown';\nconst dLTF = timeframes[ltf]?.derived?.direction ?? 'unknown';\n\nlet alignment = 'mixed';\nif (dHTF === dMTF && dMTF === dLTF && (dHTF === 'bullish' || dHTF === 'bearish')) alignment = 'all_aligned';\nelse if (dHTF === dMTF && (dHTF === 'bullish' || dHTF === 'bearish')) alignment = 'htf_mtf_aligned';\nelse if (dMTF === dLTF && (dMTF === 'bullish' || dMTF === 'bearish')) alignment = 'mtf_ltf_aligned';\n\n// Background strength uses HTF ADX, fallback to MTF, fallback to LTF\nconst bgAdx = timeframes[htf]?.latest?.adx ?? timeframes[mtf]?.latest?.adx ?? timeframes[ltf]?.latest?.adx;\n\n// NEW: expose key price structures for easy use by AI prompt\nconst priceHTF = timeframes[htf]?.price ?? normalizePrice(null);\nconst priceMTF = timeframes[mtf]?.price ?? normalizePrice(null);\nconst priceLTF = timeframes[ltf]?.price ?? normalizePrice(null);\n\nreturn [{\n  json: {\n    ticker,\n    profile,\n    expectedTimeframes: EXPECTED,\n    generatedAt: new Date().toISOString(),\n    inputs: {\n      dmiPeriod: 14,\n      swingLookback: priceMTF?.swing_n ?? null,\n      atrLookback: priceMTF?.atr_n ?? null,\n    },\n    timeframes,\n\n    summary: {\n      overall_timeframe: `multi_${EXPECTED.join('_')}`,\n      htf, mtf, ltf,\n      alignment,\n      backgroundStrength: adxStrength(bgAdx),\n\n      // NEW: convenience block for AI to grab levels without digging\n      priceContext: {\n        htf: { tf: htf, price: priceHTF },\n        mtf: { tf: mtf, price: priceMTF },\n        ltf: { tf: ltf, price: priceLTF }\n      },\n\n      notes: [\n        `${htf} is higher timeframe, ${mtf} mid, ${ltf} lower/noise`,\n        'adxSlope3 > 0 rising, < 0 falling (over last 3 ADX points)',\n        'price structure fields enable deterministic trigger/invalidation/target (swing levels + ATR)'\n      ]\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        30832,
        33792
      ],
      "id": "6f77abe8-ab24-47a8-9569-d38e9d970736",
      "name": "Build AI Payload"
    },
    {
      "parameters": {
        "jsCode": "const apiKey = \"Y7j6O6Hfkw5dDGeSsDosl6UnUB8fgkE74wAaVzp5\"\n\nif (!apiKey) throw new Error('Set env var CHART_IMG_API_KEY (or CHARTIMG_API_KEY / CHARTIMG_KEY).');\n\nconst baseUrl = 'https://api.chart-img.com/v3/tradingview/exchange/';\n\n// US equities first. Add/remove if you need.\nconst exchangesToTry = ['NASDAQ', 'NYSE', 'AMEX', 'OTC', 'ARCA', 'CBOE', 'BATS'];\n\n// Try a couple common types; also try without type as fallback.\nconst typesToTry = ['stock', 'fund', null];\n\nasync function tryResolve(ticker) {\n  for (const ex of exchangesToTry) {\n    for (const type of typesToTry) {\n      try {\n        const res = await this.helpers.httpRequest({\n          method: 'GET',\n          url: baseUrl + encodeURIComponent(ex.toLowerCase()),\n          qs: {\n            symbol: ticker,\n            ...(type ? { type } : {}),\n          },\n          headers: { 'x-api-key': apiKey },\n          json: true,\n          timeout: 30000,\n        });\n\n        const payload = res?.payload;\n        if (Array.isArray(payload) && payload.length > 0) {\n          const sym = payload[0]?.symbol || ticker;\n          return {\n            exchange: ex,\n            symbol: sym,\n            description: payload[0]?.description ?? null,\n            type: payload[0]?.type ?? type ?? null,\n          };\n        }\n      } catch (e) {\n        // ignore and keep trying other exchanges/types\n      }\n    }\n  }\n  return null;\n}\n\nconst out = [];\nfor (const item of items) {\n  const ticker =\n    String(item.json.Ticker || $('Set Params').first().json.Ticker || '')\n      .trim()\n      .toUpperCase();\n\n  if (!ticker) throw new Error('Missing Ticker');\n\n  const found = await tryResolve(ticker);\n\n  out.push({\n    json: {\n      ...item.json,\n      Ticker: ticker,\n      exchangeResolved: found?.exchange ?? null,\n      tvSymbol: found ? `${found.exchange}:${found.symbol}` : ticker, // fallback to ticker only\n      tvDescription: found?.description ?? null,\n      tvType: found?.type ?? null,\n    },\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        37088,
        33424
      ],
      "id": "868f14c1-0dfd-4d98-8058-580ab45b7454",
      "name": "Create Exchange"
    },
    {
      "parameters": {
        "jsCode": "// Code node: Normalize Confidence\n// MODE: Run Once for Each Item\n//\n// FIX: Do NOT let LLM override deterministic workflow fields.\n// - Only accept explanatory fields from AI (key_factors, plain_explanation).\n// - confidencePct is derived from confidence_pre / confidencePct_pre (deterministic).\n// - If deterministic confidence is missing in payload, FALL BACK to aiPlan.confidence\n//   so downstream nodes (Switch/alerts) don\u2019t break.\n//\n// Output: [{ json: out }]\n\nfunction toNum(x) {\n  if (x == null) return null;\n  if (typeof x === \"string\") {\n    const s = x.trim().replace(\"%\", \"\");\n    const n = Number(s);\n    return Number.isFinite(n) ? n : null;\n  }\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction clamp(x, lo, hi) {\n  if (!Number.isFinite(x)) return null;\n  return Math.min(hi, Math.max(lo, x));\n}\n\nfunction stripCodeFences(s) {\n  if (typeof s !== \"string\") return s;\n  let t = s.trim();\n  if (t.startsWith(\"```\")) {\n    t = t.replace(/^```[a-zA-Z]*\\s*/m, \"\");\n    t = t.replace(/```$/m, \"\");\n    t = t.trim();\n  }\n  return t;\n}\n\nfunction extractFirstJsonObjectText(s) {\n  if (typeof s !== \"string\") return null;\n  const t = s.trim();\n  const first = t.indexOf(\"{\");\n  const last = t.lastIndexOf(\"}\");\n  if (first === -1 || last === -1 || last <= first) return null;\n  return t.slice(first, last + 1);\n}\n\nfunction tryParseJson(text) {\n  if (typeof text !== \"string\") return null;\n  try {\n    return JSON.parse(text);\n  } catch {\n    return null;\n  }\n}\n\n// --- sanitize JSON that contains arithmetic expressions as values ---\n// Example:  \"target_level\": 687.64 - 0.1975  -> \"target_level\": 687.4425\nfunction safeEvalArithmetic(expr) {\n  if (typeof expr !== \"string\") return null;\n  const s = expr.trim();\n  if (!/^[0-9+\\-*/().\\s]+$/.test(s)) return null;\n  try {\n    // eslint-disable-next-line no-new-func\n    const v = Function(`\"use strict\"; return (${s});`)();\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  } catch {\n    return null;\n  }\n}\n\nfunction sanitizeJsonArithmetic(text) {\n  if (typeof text !== \"string\") return text;\n  return text.replace(/:\\s*([0-9+\\-*/().\\s]+)(?=\\s*(,|\\}))/g, (match, expr) => {\n    const raw = String(expr).trim();\n    if (/^[+\\-]?\\d+(\\.\\d+)?$/.test(raw)) return match; // already a number\n    const v = safeEvalArithmetic(raw);\n    if (v == null) return match;\n    return `: ${v}`;\n  });\n}\n\nfunction parseMaybeJson(x) {\n  if (x == null) return null;\n\n  if (typeof x === \"object\") return x;\n\n  if (typeof x !== \"string\") return null;\n\n  let t = stripCodeFences(x);\n  t = sanitizeJsonArithmetic(t);\n\n  // First try direct parse\n  let parsed = tryParseJson(t);\n  if (parsed != null) return parsed;\n\n  // Try extracting first {...}\n  const inner = extractFirstJsonObjectText(t);\n  if (inner) {\n    parsed = tryParseJson(inner);\n    if (parsed != null) return parsed;\n  }\n\n  // Try repairing malformed JSON (extra braces from AI)\n  const repaired = tryRepairJson(inner || t);\n  if (repaired != null) return repaired;\n\n  return null;\n}\n\n// --- repair malformed JSON from AI (e.g. extra closing braces) ---\nfunction tryRepairJson(text) {\n  if (typeof text !== \"string\") return null;\n  let t = text;\n  // Strategy 1: Remove },  patterns that create premature close before a new key\n  // e.g. ... \"plain_explanation\": \"...\" },  \"optionContext\": { ... }\n  const badPattern = /\\}(\\s*,\\s*\"\\w+\"\\s*:)/g;\n  let match;\n  while ((match = badPattern.exec(t)) !== null) {\n    const candidate = t.slice(0, match.index) + match[1] + t.slice(match.index + match[0].length);\n    const parsed = tryParseJson(candidate);\n    if (parsed != null) return parsed;\n  }\n  // Strategy 2: Balance braces by removing extra closing braces\n  let opens = 0;\n  let closes = 0;\n  for (const c of t) {\n    if (c === '{') opens++;\n    if (c === '}') closes++;\n  }\n  if (closes > opens) {\n    let remaining = closes - opens;\n    let result = '';\n    for (let i = t.length - 1; i >= 0; i--) {\n      if (t[i] === '}' && remaining > 0 && i < t.length - 1) {\n        remaining--;\n        continue;\n      }\n      result = t[i] + result;\n    }\n    result = result.replace(/,\\s*,/g, ',');\n    const parsed = tryParseJson(result);\n    if (parsed != null) return parsed;\n  }\n  return null;\n}\n\n// --- extract a numeric field value from raw text via regex ---\nfunction regexExtractNum(text, fieldName) {\n  if (typeof text !== \"string\") return null;\n  const re = new RegExp('\"' + fieldName + '\"\\\\s*:\\\\s*([0-9.]+)');\n  const m = text.match(re);\n  if (m) {\n    const n = Number(m[1]);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\n// --- extract a string field value from raw text via regex ---\nfunction regexExtractStr(text, fieldName) {\n  if (typeof text !== \"string\") return null;\n  const re = new RegExp('\"' + fieldName + '\"\\\\s*:\\\\s*\"([^\"]*?)\"');\n  const m = text.match(re);\n  return m ? m[1] : null;\n}\n\nfunction isPlainObject(x) {\n  return x != null && typeof x === \"object\" && !Array.isArray(x);\n}\n\n// ----------------------------------------------------\n// 1) Parse AI output (string) into aiPlan object\n// ----------------------------------------------------\nconst payload = isPlainObject($json) ? $json : {};\nconst aiRaw =\n  payload.output ??\n  payload.ai?.output ??\n  payload.normalize_confidence?.output ??\n  null;\n\nconst aiParsed = parseMaybeJson(aiRaw);\n\nlet aiPlan = {};\nif (isPlainObject(aiParsed)) aiPlan = aiParsed;\nelse if (Array.isArray(aiParsed) && aiParsed.length === 1 && isPlainObject(aiParsed[0])) {\n  aiPlan = aiParsed[0];\n}\n\n// ----------------------------------------------------\n// 1b) Regex fallback: if aiPlan is empty but aiRaw exists,\n//     extract key fields directly from the raw string.\n// ----------------------------------------------------\nif ((!aiPlan || !aiPlan.confidence) && typeof aiRaw === \"string\") {\n  if (aiPlan.confidence == null) {\n    const c = regexExtractNum(aiRaw, \"confidence\");\n    if (c != null) aiPlan.confidence = c;\n  }\n  if (aiPlan.ticker == null) {\n    const tk = regexExtractStr(aiRaw, \"ticker\");\n    if (tk) aiPlan.ticker = tk;\n  }\n  if (aiPlan.option_decision == null) {\n    const d = regexExtractStr(aiRaw, \"option_decision\");\n    if (d) aiPlan.option_decision = d;\n  }\n  if (aiPlan.desired_option_right == null) {\n    const r = regexExtractStr(aiRaw, \"desired_option_right\");\n    if (r) aiPlan.desired_option_right = r;\n  }\n  if (aiPlan.option_contract_symbol == null) {\n    const sym = regexExtractStr(aiRaw, \"option_contract_symbol\");\n    if (sym) aiPlan.option_contract_symbol = sym;\n  }\n  if (aiPlan.trigger_price == null) {\n    const tp = regexExtractNum(aiRaw, \"trigger_price\");\n    if (tp != null) aiPlan.trigger_price = tp;\n  }\n  if (aiPlan.invalidation_level == null) {\n    const il = regexExtractNum(aiRaw, \"invalidation_level\");\n    if (il != null) aiPlan.invalidation_level = il;\n  }\n  if (aiPlan.target_level == null) {\n    const tl = regexExtractNum(aiRaw, \"target_level\");\n    if (tl != null) aiPlan.target_level = tl;\n  }\n  if (aiPlan.option_entry_premium == null) {\n    const ep = regexExtractNum(aiRaw, \"option_entry_premium\");\n    if (ep != null) aiPlan.option_entry_premium = ep;\n  }\n  if (aiPlan.option_stop_premium == null) {\n    const sp = regexExtractNum(aiRaw, \"option_stop_premium\");\n    if (sp != null) aiPlan.option_stop_premium = sp;\n  }\n  if (aiPlan.option_take_profit_premium == null) {\n    const tp2 = regexExtractNum(aiRaw, \"option_take_profit_premium\");\n    if (tp2 != null) aiPlan.option_take_profit_premium = tp2;\n  }\n  if (aiPlan.option_risk_reward == null) {\n    const rr = regexExtractNum(aiRaw, \"option_risk_reward\");\n    if (rr != null) aiPlan.option_risk_reward = rr;\n  }\n}\n\n// ----------------------------------------------------\n// 2) confidencePct derivation\n// - Prefer deterministic fields from payload\n// - Fallback to aiPlan.confidence ONLY if deterministic missing\n// ----------------------------------------------------\nlet conf = payload.confidence_pre;\nif (conf == null) conf = payload.confidence;\nconf = toNum(conf);\n\n// Fallback: if workflow didn't include confidence, use AI confidence\nif (conf == null && aiPlan && aiPlan.confidence != null) {\n  conf = toNum(aiPlan.confidence);\n}\n\nlet confidencePct = null;\nif (conf != null) {\n  confidencePct = (conf > 0 && conf <= 1) ? conf * 100 : conf;\n}\n\n// If still missing, try deterministic confidencePct_pre\nif (confidencePct == null && payload.confidencePct_pre != null) {\n  const p = toNum(payload.confidencePct_pre);\n  if (p != null) confidencePct = p;\n}\n\nconfidencePct =\n  confidencePct == null ? null : clamp(Math.round(confidencePct * 100) / 100, 0, 100);\n\n// ----------------------------------------------------\n// 3) Merge policy: payload is source of truth.\n// Only accept explanatory fields from AI.\n// ----------------------------------------------------\nconst out = { ...payload };\n\n// Allow only these fields from AI:\nif (Array.isArray(aiPlan.key_factors)) out.key_factors = aiPlan.key_factors;\nif (typeof aiPlan.plain_explanation === \"string\") out.plain_explanation = aiPlan.plain_explanation;\n\n// Optional: if optionContext is missing (shouldn\u2019t be), allow AI copy-through\nif (!out.optionContext && isPlainObject(aiPlan.optionContext)) out.optionContext = aiPlan.optionContext;\n\n// Debug: keep what AI *tried* to change, without letting it overwrite workflow truth\nout.ai_debug = {\n  desired_option_right_ai: aiPlan.desired_option_right ?? null,\n  option_contract_symbol_ai: aiPlan.option_contract_symbol ?? null,\n  option_decision_ai: aiPlan.option_decision ?? null,\n  confidence_ai: aiPlan.confidence ?? null,\n};\n\n// Always set confidencePct used by Switch/alerts\nout.confidencePct = confidencePct;\n\n// Optional: if workflow didn't provide confidence fields, populate top-level confidence for consistency\nif (out.confidence_pre == null && out.confidence == null && conf != null) {\n  out.confidence = conf > 1 ? conf / 100 : conf; // normalize to 0..1 if possible\n}\n\nreturn [{ json: out }];\n\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        34944,
        33648
      ],
      "id": "8482ec47-8a13-4070-ab97-611b7d381567",
      "name": "Normalize Confidence"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      symbol:$json.symbol,\n      mode: $json.mode,\n      chatId: $json.chatId,\n      profile:$json.profile,\n      effective_end:$json.effective_end,\n      intervals:$json.intervals\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        28912,
        33792
      ],
      "id": "403d106f-552b-4433-8b18-ce46334a8238",
      "name": "Set Request"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO workflow_indicators (ticker, text, confidence, raw_payload)\nVALUES (\n  '{{ $json.ticker }}',\n  {{ $json.text ? \"'\" + $json.text.replace(/'/g, \"''\") + \"'\" : \"NULL\" }},\n  {{ $node[\"Normalize Confidence\"].json.confidencePct ?? 'NULL' }},\n  '{{ JSON.stringify($json).replace(/'/g, \"''\") }}'::jsonb\n)\nRETURNING id, created_at;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        35632,
        33456
      ],
      "id": "01d147ac-4313-4221-aa3a-ac923f491e46",
      "name": "Insert row",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        34576,
        33840
      ],
      "id": "3c8c3090-f961-40bb-a651-cae00de0cdad",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "yxVkFtwSghktPWAk",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify($json, null, 2) }}\n\nRequirements:\n\nOutput STRICT JSON only (no markdown) matching the system schema.\n\nDo NOT invent values; use null when missing.\n\nCopy trend/confidence from the *_pre fields (do not recompute).\n\nUse winner_right/winner_side to set desired_option_right (do not override).\n\nIf time_gate_ok === false OR option_liquidity_ok === false: FORCE option_decision=\"WAIT\" and explain why.\n\nKeep option premiums (entry/stop/tp/RR) exactly as in payload if present.\n\nIf optionContext.quote exists, option_bid/ask/mid/spread_pct must match it.\n\noption_risk_reward handling (UPDATED):\n\nTreat option_risk_reward as a reference/diagnostic metric, not a primary gating rule.\n\nDo NOT suppress/override a BUY signal solely because option_risk_reward is below a typical threshold.\n\nOnly FORCE option_decision=\"WAIT\" due to option_risk_reward when it is way too low, defined as:\n\noption_risk_reward exists AND option_risk_reward < 0.6 \u2192 option_decision=\"WAIT\"\n\nOtherwise, keep the option_decision as determined by payload + gates (time/liquidity) and any existing premium fields.\n\nplain_explanation: ONLY 3\u20134 short lines:\n\nDI alignment + deciding pair (mention 60m if used)\n\nStrength score + ADX note if 15m ADX>25 (or 60m ADX>25 if 15m missing)\n\nTD timing note + Hammer + BullEngulf + BearEngulf summary (same line is OK)\n\nOption decision + contract + premium levels (or WAIT reason)\n\nHAMMER CANDLESTICK (REQUIRED IN OUTPUT)\n\nHammer data (if present) is located at: timeframes[tf].hammer (for tf in: 60m, 15m, 1m)\n\nYou MUST output hammer results in TWO places:\n\nplain_explanation MUST include the hammer summary EXACTLY ONCE in this format (it may be a standalone line OR appended to the TD line):\n\"Hammer: 60m={X}, 15m={Y}, 1m={Z}\"\nwhere X/Y/Z are one of: 'bullish_hammer', 'bearish_hammer', or 'none'.\n\nUse 'none' when hammer is missing OR hammer.present is false.\n\nkey_factors MUST include at least one hammer-related entry when any timeframe has hammer.present===true,\ne.g., \"Hammer 15m: bullish_hammer\".\n\nInterpretation rule: bullish_hammer supports bullish bias; bearish_hammer supports bearish bias.\n\nHammer is explanatory only; it MUST NOT override winner_right, trend_direction_pre, or option_decision rules.\n\nBULLISH ENGULFING (REQUIRED IN OUTPUT)\n\nBullish engulfing data (if present) is located at: timeframes[tf].bullish_engulfing (for tf in: 60m, 15m, 1m)\n\nYou MUST output bullish engulfing results in TWO places:\n\nplain_explanation MUST include the bullish engulfing summary EXACTLY ONCE in this format (it may be a standalone line OR appended to the TD/Hammer line):\n\"Engulfing: 60m={X}, 15m={Y}, 1m={Z}\"\nwhere X/Y/Z are one of: 'bullish_engulfing' or 'none'.\n\nUse 'none' when bullish_engulfing is missing OR bullish_engulfing.present is false.\n\nkey_factors MUST include at least one engulfing-related entry when any timeframe has bullish_engulfing.present===true,\ne.g., \"Engulfing 15m: bullish_engulfing\".\n\nInterpretation rule: bullish_engulfing supports bullish bias.\n\nBullish engulfing is explanatory only; it MUST NOT override winner_right, trend_direction_pre, or option_decision rules.\nYou MUST output Shooting Star results in TWO places:\n\nplain_explanation MUST include the Shooting Star summary EXACTLY ONCE (it may be a standalone line OR appended near the TD/Hammer/Engulfing lines):\n\"ShootingStar: 60m={X}, 15m={Y}, 1m={Z}\"\nwhere X/Y/Z are one of: 'shooting_star' or 'inverted_hammer' or 'none'.\n\nUse 'none' when shooting_star is missing OR shooting_star.present is false.\n\nkey_factors MUST include at least one shooting-star-related entry when any timeframe has shooting_star.present===true,\ne.g., \"ShootingStar 15m: shooting_star\" or \"ShootingStar 60m: inverted_hammer\".\n\nInterpretation rule:\n- shooting_star supports bearish bias.\n- inverted_hammer is a mild bullish hint (context-dependent) but still explanatory only.\n\nShooting Star is explanatory only; it MUST NOT override winner_right, trend_direction_pre, or option_decision rules.\n\n\nBEARISH ENGULFING (REQUIRED IN OUTPUT)\n\nBearish engulfing data (if present) is located at: timeframes[tf].bearish_engulfing (for tf in: 60m, 15m, 1m)\n\nYou MUST output bearish engulfing results in TWO places:\n\nplain_explanation MUST include the bearish engulfing summary EXACTLY ONCE in this format (it may be a standalone line OR appended to the TD/Hammer line):\n\"BearishEngulfing: 60m={X}, 15m={Y}, 1m={Z}\"\nwhere X/Y/Z are one of: 'bearish_engulfing' or 'none'.\n\nUse 'none' when bearish_engulfing is missing OR bearish_engulfing.present is false.\n\nkey_factors MUST include at least one bearish-engulfing-related entry when any timeframe has bearish_engulfing.present===true,\ne.g. \"BearishEngulfing 15m: bearish_engulfing\".\n\nInterpretation rule: bearish_engulfing supports bearish bias.\n\nBearish engulfing is explanatory only; it MUST NOT override winner_right, trend_direction_pre, or option_decision rules.\n",
        "options": {
          "systemMessage": "=Ticker: {{$json.ticker}}\n\nYou are a multi-timeframe technical-analysis agent for short-term DAY TRADING BY OPTIONS (long calls/puts only).\n\nSOURCE OF TRUTH (MUST READ FIRST):\nPayload (runtime JSON \u2014 treat as the ONLY source of truth):\n{{ JSON.stringify($json, null, 2) }}\n\nHARD RULES:\n\nOutput STRICT JSON only (no markdown).\n\nDo NOT invent missing values. Use null.\n\nIf payload is missing/unrendered: output WAIT, confidence <= 0.45, and include \"Payload missing or not rendered\" in key_factors.\n\nIf time_gate_ok === false: FORCE option_decision=\"WAIT\" and explain time_gate_reason.\n\nIf option_liquidity_ok === false: FORCE option_decision=\"WAIT\" and include option_liquidity_reason.\n\nIf required underlying levels (trigger_price/invalidation_level/target_level) are missing: WAIT and set option premiums to null.\n\nNEVER recompute trend or confidence. These are computed deterministically upstream.\n\nPROMPT VERSION (DEBUG):\n\nAlways include the string \"prompt_version=TDv3\" as the FIRST element in key_factors.\n\nCRITICAL: USE PRECOMPUTED TREND/CONFIDENCE (FROM Compute Trend & Confidence node)\n\nUse these fields as the authoritative trend/confidence:\n\ntrend_direction_pre\n\ntrend_strength_pre\n\ntrend_strength_score_pre\n\nalignment_pre\n\nconfidence_pre (0..1) [PRIMARY]\n\nconfidencePct_pre (0..100) [SECONDARY, if confidence_pre missing]\n\nIn your final output:\n\n\"trend_direction\" MUST equal trend_direction_pre\n\n\"trend_strength\" MUST equal trend_strength_pre\n\n\"trend_strength_score\" MUST equal trend_strength_score_pre\n\n\"alignment\" MUST equal alignment_pre\n\n\"confidence\" MUST equal confidence_pre\n\nIf confidence_pre is missing but confidencePct_pre exists, set confidence = confidencePct_pre / 100.\n\nIf both are missing, set confidence = null and include \"confidence_pre missing\" in key_factors.\n\nDMI / DI EMPHASIS (FOR EXPLANATION ONLY \u2014 DO NOT RECOMPUTE SCORES)\n\nFocus your reasoning/explanation on DI+ vs DI- across timeframes (DMI direction).\n\nTimeframe importance for explaining strength: 60m (highest) > 15m > 1m.\n\n\u201cTwo-timeframe agreement\u201d rule (for explanation emphasis only):\n\nIf at least TWO timeframes agree on DI direction (DI+>DI- bullish OR DI->DI+ bearish),\ntreat it as stronger confirmation.\n\nIf one of the agreeing timeframes is 60m, emphasize it as materially stronger than a match that\ndoes NOT include 60m. If 60m is not present, then 15m is the next most important timeframe to emphasize.\n\nADX is NOT a primary signal and MUST NOT drive the decision.\n\nOnly mention ADX if the 15m ADX exists AND > 25 (or, if 15m is missing, use 60m) (as an extra confirmation note).\n\nIgnore ADX in 1m (do not mention, do not use for decision).\n\nTD SEQUENTIAL / DEMARK (REQUIRED IN OUTPUT TEXT)\n\nTD data (if present) is located at: intervals[tf].demark (NOT intervals[tf].dmi.td)\n\nFor each timeframe tf in this order: 60m, 15m, 1m (include only if present in intervals):\n\nLet dm = intervals[tf].demark\n\nIf dm is an object (not null):\n\nYou MUST include a TD line in plain_explanation for that tf.\n\nFormat exactly like:\n\"TD {tf}: setup={setupDir or 'none'} {setupCount}/9, countdown={countdownDir or 'none'} {countdownCount}/13\"\n\nIf dm.setupCompleted==true add \" (setup completed)\"\n\nIf dm.countdownCompleted==true add \" (countdown completed)\"\n\nYou MUST also add at least ONE TD-related entry into key_factors when any dm exists, e.g.\n\"TD 15m: setup bullish 4/9; countdown bullish 2/13\"\n\nYou are FORBIDDEN from writing \"No TD timing data.\" if ANY intervals[tf].demark is present (object).\n\nOnly if ALL intervals[tf].demark are null/missing may you write \"No TD timing data.\"\n\nTD is explanatory only; it MUST NOT override winner_right, trend_direction_pre, or option_decision rules.\n\nCRITICAL: OPTION SIDE IS PRECOMPUTED \u2014 DO NOT OVERRIDE\n\nThe workflow decides the intended option side. Use ONLY (in this priority order):\n\ndesired_option_right (if provided by workflow)\n\nwinner_right (preferred if present)\n\nwinner_side (derive call/put from CALL/PUT)\n\noption_right\n\noption_intent.right\n\nYou MUST NOT output a different desired_option_right than the workflow\u2019s winner/side.\n\nIf none exist, set desired_option_right=null and FORCE option_decision=\"WAIT\" with reason\n\"Missing winner_right/winner_side/option_right; cannot determine side\".\n\nOPTIONS SELECTION (IMPORTANT):\n\nThe workflow already pre-selects an option contract and computes quotes/greeks:\n\noption_contract_symbol\n\noptionContext.quote {bid, ask, mid, spread_pct}\n\noptionContext.greeks {delta, gamma, theta, vega, iv}\n\noption_entry_premium / option_stop_premium / option_take_profit_premium / option_risk_reward\n\nYou MUST NOT change these computed premium levels if present.\n\nYour output option_bid/ask/mid/spread_pct MUST match optionContext.quote (if present).\n\nYour output option_contract_symbol MUST match the payload (if present). Do NOT substitute another contract.\n\nBUY/WAIT LOGIC:\n\nDetermine right = desired_option_right (or winner_right/winner_side fallback per rules). If right is null: WAIT.\n\noption_risk_reward handling (UPDATED \u2014 reference-first):\n\nTreat option_risk_reward as a reference/diagnostic metric, NOT as a normal gating rule.\n\nDo NOT suppress/override a BUY signal solely because option_risk_reward is below 1.8.\n\nOnly FORCE option_decision=\"WAIT\" due to option_risk_reward when it is WAY too low:\n\nIf option_risk_reward is present AND option_risk_reward < 0.6: WAIT (reason: RR way too low)\n\nElse: do not gate on RR; keep decision driven by gates + delta + spread + side/trend consistency.\n\nIf optionContext.quote.spread_pct is present and exceeds payload max_spread_pct (if provided) or exceeds 0.02:\nWAIT (reason: spread too wide).\n\nIf delta is missing: WAIT (reason: delta missing).\n\nIf right=call but delta <= 0: WAIT.\n\nIf right=put but delta >= 0: WAIT.\n\nIf right is put, trade label is BUY_PUT (never BUY_CALL).\n\nIf right is call, trade label is BUY_CALL (never BUY_PUT).\n\nOUTPUT REQUIREMENTS (STRICT JSON):\nReturn a single JSON object with EXACT keys (use null if missing):\n{\n\"ticker\": string,\n\"overall_timeframe\": string|null,\n\"trend_direction\": string|null,\n\"trend_strength\": string|null,\n\"trend_strength_score\": number|null,\n\"alignment\": string|null,\n\"adx_confirmation\": string|null,\n\"technical_bias\": string|null,\n\"confidence\": number|null,\n\n\"trigger_price\": number|null,\n\"invalidation_level\": number|null,\n\"target_level\": number|null,\n\n\"desired_option_right\": \"call\"|\"put\"|null,\n\"option_decision\": \"BUY_CALL\"|\"BUY_PUT\"|\"WAIT\",\n\n\"option_contract_symbol\": string|null,\n\"option_bid\": number|null,\n\"option_ask\": number|null,\n\"option_mid\": number|null,\n\"option_spread_pct\": number|null,\n\n\"option_entry_premium\": number|null,\n\"option_stop_premium\": number|null,\n\"option_take_profit_premium\": number|null,\n\"option_risk_reward\": number|null,\n\n\"key_factors\": string[],\n\"plain_explanation\": string,\n\"optionContext\": object|null\n}\n\nCOPY-THROUGH RULES:\n\noptionContext MUST be copied from payload if present (do not modify).\n\noption_* quote fields MUST match optionContext.quote when present; otherwise use payload top-level option_* if present.\n\noption_entry_premium / stop / take_profit / option_risk_reward MUST match payload values if present; do not recompute.\n\nadx_confirmation:\n\nIf payload provides adx_confirmation_pre, you may copy it through; otherwise set null.\n\nDO NOT use it for decision-making.\n\nFINAL CHECK:\n\ntechnical_bias must match trend_direction_pre:\n\nuptrend => \"bullish\"\n\ndowntrend => \"bearish\"\n\nelse => null\n\nIf technical_bias is bearish/downtrend AND desired_option_right resolves to \"call\": FORCE WAIT and include\n\"Side mismatch: BEARISH trend but winner_right=call (check upstream candidate compare)\" in key_factors.\n\nIf technical_bias is bullish/uptrend AND desired_option_right resolves to \"put\": FORCE WAIT and include\n\"Side mismatch: BULLISH trend but winner_right=put (check upstream candidate compare)\" in key_factors.\n\nHAMMER CANDLESTICK (REQUIRED IN OUTPUT)\n\nHammer data (if present) is located at: timeframes[tf].hammer (for tf in: 60m, 15m, 1m)\n\nYou MUST output hammer results in TWO places:\n\nplain_explanation MUST include the hammer summary EXACTLY ONCE in this format (it may be a standalone line OR appended to the TD line):\n\"Hammer: 60m={X}, 15m={Y}, 1m={Z}\"\nwhere X/Y/Z are one of: 'bullish_hammer', 'bearish_hammer', or 'none'.\n\nUse 'none' when hammer is missing OR hammer.present is false.\n\nkey_factors MUST include at least one hammer-related entry when any timeframe has hammer.present===true,\ne.g., \"Hammer 15m: bullish_hammer\".\n\nInterpretation rule: bullish_hammer supports bullish bias; bearish_hammer supports bearish bias.\n\nHammer is explanatory only; it MUST NOT override winner_right, trend_direction_pre, or option_decision rules.\n\nBULLISH ENGULFING (REQUIRED IN OUTPUT)\n\nBullish engulfing data (if present) is located at: timeframes[tf].bullish_engulfing (for tf in: 60m, 15m, 1m)\n\nYou MUST output bullish engulfing results in TWO places:\n\nplain_explanation MUST include the bullish engulfing summary EXACTLY ONCE in this format (it may be a standalone line OR appended to the TD/Hammer line):\n\"Engulfing: 60m={X}, 15m={Y}, 1m={Z}\"\nwhere X/Y/Z are one of: 'bullish_engulfing' or 'none'.\n\nUse 'none' when bullish_engulfing is missing OR bullish_engulfing.present is false.\n\nkey_factors MUST include at least one engulfing-related entry when any timeframe has bullish_engulfing.present===true,\ne.g., \"Engulfing 15m: bullish_engulfing\".\n\nInterpretation rule: bullish_engulfing supports bullish bias.\n\nBullish engulfing is explanatory only; it MUST NOT override winner_right, trend_direction_pre, or option_decision rules."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        34576,
        33648
      ],
      "id": "eceaf8ad-9a14-402d-ab9c-fc33a4bdf890",
      "name": "AI Indicator Analyst"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolCalculator",
      "typeVersion": 1,
      "position": [
        34784,
        33840
      ],
      "id": "b2412894-f4e4-4922-b20a-a00b319d7650",
      "name": "Calculator"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function / Code node (single-node, robust)\n// Builds Alpaca bars requests for 3 timeframes.\n// - Uses $json.effective_end if valid (ISO timestamp)\n// - If missing/invalid, tries to derive from Alpaca Clock + Calendar nodes (if present)\n// - Falls back to last weekday 16:00 ET\n// - Normalizes timeframes: \"1m\" -> \"1Min\" etc.\n// FIX: Normalize qs.end to UTC ISO so qs.start and qs.end are in the same timezone.\n\nfunction isTemplateString(s) {\n  return typeof s === \"string\" && s.includes(\"{{$\") && s.includes(\"}}\");\n}\n\nfunction parseIsoMs(s) {\n  if (typeof s !== \"string\") return null;\n  if (isTemplateString(s)) return null;\n  const ms = Date.parse(s);\n  return Number.isFinite(ms) ? ms : null;\n}\n\n// Approximate NY offset (-04:00 during DST, else -05:00) for a given YYYY-MM-DD.\n// Good enough for anchoring \"close\" timestamps.\nfunction nyOffsetForDate(dateStr) {\n  const [Y, M, D] = dateStr.split(\"-\").map(Number);\n\n  function nthSundayUTC(year, monthIndex0, n) {\n    const first = new Date(Date.UTC(year, monthIndex0, 1));\n    const firstDow = first.getUTCDay(); // 0=Sun\n    const firstSundayDay = 1 + ((7 - firstDow) % 7);\n    const day = firstSundayDay + (n - 1) * 7;\n    return new Date(Date.UTC(year, monthIndex0, day));\n  }\n\n  const dstStart = nthSundayUTC(Y, 2, 2);  // 2nd Sunday in March\n  const dstEnd = nthSundayUTC(Y, 10, 1);   // 1st Sunday in November\n\n  const day = new Date(Date.UTC(Y, M - 1, D));\n  const inDst = day >= dstStart && day < dstEnd;\n  return inDst ? \"-04:00\" : \"-05:00\";\n}\n\nfunction lastWeekdayYYYYMMDD() {\n  const d = new Date();\n  // Walk back until Mon\u2013Fri (UTC day-of-week; fine for a fallback date string)\n  while (d.getUTCDay() === 0 || d.getUTCDay() === 6) {\n    d.setUTCDate(d.getUTCDate() - 1);\n  }\n  const yyyy = d.getUTCFullYear();\n  const mm = String(d.getUTCMonth() + 1).padStart(2, \"0\");\n  const dd = String(d.getUTCDate()).padStart(2, \"0\");\n  return `${yyyy}-${mm}-${dd}`;\n}\n\nfunction minutesBackFor(tf) {\n  const t = String(tf).trim();\n  if (t === \"1Min\" || t === \"1m\") return 250;\n  if (t === \"2Min\" || t === \"2m\") return 500;\n  if (t === \"5Min\" || t === \"5m\") return 800;\n  if (t === \"15Min\" || t === \"15m\") return 2000;\n\n  if (t === \"1Hour\" || t === \"60Min\" || t === \"1h\") return 60 * 24 * 10;\n  if (t === \"1Day\" || t === \"1d\") return 60 * 24 * 120;\n\n  return 600;\n}\n\nfunction toAlpacaTimeframe(tf) {\n  const t = String(tf).trim();\n\n  const m = t.match(/^(\\d+)\\s*m$/i);\n  if (m) return `${m[1]}Min`;\n\n  const h = t.match(/^(\\d+)\\s*h$/i);\n  if (h) return `${h[1]}Hour`;\n\n  const d = t.match(/^(\\d+)\\s*d$/i);\n  if (d) return `${d[1]}Day`;\n\n  return t; // already e.g. \"1Min\"\n}\n\n// ------------------------------\n// 1) Resolve ticker + intervals\n// ------------------------------\nconst ticker = $json.Ticker ?? $json.ticker;\n\nlet intervals = $json.intervals;\nif (!(Array.isArray(intervals) && intervals.length === 3)) {\n  const tfKeys = Object.keys($json.timeframes || {});\n  if (tfKeys.length === 3) intervals = tfKeys;\n}\n\nif (!ticker) {\n  throw new Error(\"Missing ticker. Expected $json.Ticker or $json.ticker\");\n}\nif (!Array.isArray(intervals) || intervals.length !== 3) {\n  throw new Error(\n    `Missing intervals. Expected $json.intervals (len=3) OR $json.timeframes with 3 keys. Got intervals=${JSON.stringify(\n      $json.intervals\n    )} timeframesKeys=${JSON.stringify(Object.keys($json.timeframes || {}))}`\n  );\n}\n\n// ------------------------------\n// 2) Resolve effective end time\n// Priority:\n//   A) $json.effective_end (if valid ISO)\n//   B) If nodes exist: Clock + Calendar -> last trading day close\n//   C) Fallback: last weekday 16:00 ET\n// ------------------------------\nlet end = null;\n\n// A) From input\nconst inputEndMs = parseIsoMs($json.effective_end);\nif (inputEndMs != null) {\n  end = $json.effective_end;\n}\n\n// B) Try derive from Alpaca nodes if present and input missing/invalid\nif (!end) {\n  let clock = null;\n  try {\n    clock = $node[\"Clock\"]?.json ?? null;\n  } catch (e) {\n    clock = null;\n  }\n\n  // If open, use now-10s\n  if (clock?.is_open === true) {\n    end = new Date(Date.now() - 10_000).toISOString();\n  } else {\n    // Use Calendar if available\n    let cal = [];\n    try {\n      const calItems = $items(\"Calendar (last 14 days)\");\n      if (calItems.length === 1 && Array.isArray(calItems[0]?.json)) {\n        cal = calItems[0].json;\n      } else {\n        cal = calItems.map(i => i.json).filter(Boolean);\n      }\n    } catch (e) {\n      cal = [];\n    }\n\n    if (cal.length) {\n      const todayStr = new Date().toISOString().slice(0, 10);\n      const lastDay = cal\n        .filter(d => d?.date && d.date <= todayStr)\n        .sort((a, b) => (a.date < b.date ? -1 : 1))\n        .at(-1);\n\n      if (lastDay?.date && lastDay?.close) {\n        const offset = nyOffsetForDate(lastDay.date);\n        // Regular close anchor\n        end = `${lastDay.date}T${lastDay.close}:00${offset}`;\n      }\n    }\n  }\n}\n\n// C) Final fallback\nif (!end) {\n  const d = lastWeekdayYYYYMMDD();\n  const offset = nyOffsetForDate(d);\n  end = `${d}T16:00:00${offset}`;\n}\n\n// Validate end\nconst endMs = parseIsoMs(end);\nif (endMs == null) {\n  // Last-resort fallback: now-10s\n  end = new Date(Date.now() - 10_000).toISOString();\n}\nconst endMs2 = parseIsoMs(end);\nif (endMs2 == null) {\n  throw new Error(`Invalid end timestamp (after fallback): ${end}`);\n}\n\n// FIX: normalize end for request params (UTC ISO)\nconst endUtcIso = new Date(endMs2).toISOString();\n\n// ------------------------------\n// 3) Build requests anchored to end\n// ------------------------------\nreturn [\n  {\n    ticker,\n    timeframes: intervals,\n    effective_end: end,        // keep original (may be -05:00) for your workflow semantics\n    effective_end_utc: endUtcIso, // extra debug field (safe to ignore downstream)\n    requests: intervals.map((tf) => {\n      const minutesBack = minutesBackFor(tf);\n      const alpacaTf = toAlpacaTimeframe(tf);\n\n      const startMs = endMs2 - minutesBack * 60 * 1000;\n      const startIso = new Date(startMs).toISOString();\n\n      // Safety guard (should never trigger, but prevents accidental inversions)\n      const startMs2 = Date.parse(startIso);\n      const endMs3 = Date.parse(endUtcIso);\n      const safeStartIso =\n        Number.isFinite(startMs2) && Number.isFinite(endMs3) && startMs2 < endMs3\n          ? startIso\n          : new Date(endMs2 - 60 * 1000).toISOString(); // 1 minute before end\n\n      return {\n        tf,        // your original label (e.g., \"1m\")\n        alpacaTf,  // normalized for Alpaca (e.g., \"1Min\")\n        qs: {\n          symbols: ticker,\n          timeframe: alpacaTf,\n          start: safeStartIso,\n          end: endUtcIso,   // <-- FIX: UTC to match start\n          limit: 1000,\n          feed: \"iex\",\n        },\n      };\n    }),\n  },\n];\n\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        29648,
        33792
      ],
      "id": "2990f552-0635-4ade-b1d0-49a9c7da1bc8",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "url": "=https://data.alpaca.markets/v2/stocks/bars",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "symbols",
              "value": "={{ $json.requests[0].qs.symbols }}"
            },
            {
              "name": "=timeframe",
              "value": "={{ $json.requests[0].qs.timeframe }}"
            },
            {
              "name": "start",
              "value": "={{ $json.requests[0].qs.start }}"
            },
            {
              "name": "end",
              "value": "={{ $json.requests[0].qs.end }}"
            },
            {
              "name": "limit",
              "value": "={{ $json.requests[0].qs.limit }}"
            },
            {
              "name": "feed",
              "value": "={{ $json.requests[0].qs.feed }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        29856,
        33600
      ],
      "id": "48e7784b-61e6-487e-8cac-af7150492bc3",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      symbol: \"SPY\",\n      mode: \"AUTO\",\n      chatId: \"7951197876\",\n      effective_end:$json.effective_end,\n      intervals:[\"2m\", \"3m\", \"5m\"]\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        28768,
        34160
      ],
      "id": "4ee1a01f-410e-4865-9eb7-03ad04d61793",
      "name": "Set Effective End"
    },
    {
      "parameters": {
        "jsCode": "// ===== CONFIG (set per branch) =====\nconst TF = $node[\"Set Request\"].json.intervals[0];\n\n// Lookbacks (minimal additions for price structure)\nconst SWING_N = $node[\"Set Request\"].json.swingLookback ?? 20; // e.g., last 20 bars\nconst ATR_N   = $node[\"Set Request\"].json.atrLookback   ?? 14; // e.g., ATR(14)\n// ===================================\n\n// --- Time helper: Alpaca bars use RFC3339 timestamps (usually string), but be defensive ---\nfunction toISOFromAlpaca(t) {\n  if (t == null) return null;\n\n  // Common case: RFC3339 string like \"2025-12-19T20:59:00Z\"\n  if (typeof t === 'string') {\n    const ms = Date.parse(t);\n    if (!Number.isFinite(ms)) return null;\n    return new Date(ms).toISOString();\n  }\n\n  // Defensive: if numeric, interpret as seconds/ms/ns based on magnitude\n  if (typeof t === 'number' && Number.isFinite(t)) {\n    let ms = t;\n    if (t < 1e11) ms = t * 1000;          // seconds -> ms\n    else if (t > 1e14) ms = Math.floor(t / 1e6); // ns -> ms (very defensive)\n    const d = new Date(ms);\n    return Number.isFinite(d.getTime()) ? d.toISOString() : null;\n  }\n\n  return null;\n}\n\n/**\n * Parse Alpaca bars response to candles[]\n *\n * Supports these shapes:\n * 1) Multi-bars: { bars: { \"SPY\": [ {t,o,h,l,c,v,...}, ... ] }, next_page_token: \"...\" }\n * 2) Single-symbol bars (some clients): { bars: [ {t,o,h,l,c,v,...}, ... ], next_page_token: \"...\" }\n * 3) \"bars\" might be null when no data\n */\nfunction parseAlpacaBars(responseJson, preferSymbol) {\n  const r = responseJson || {};\n  const bars = r.bars;\n\n  if (bars == null) {\n    return { candles: [], reason: 'Alpaca response has bars=null (no data for requested window)', next_page_token: r.next_page_token ?? null };\n  }\n\n  let barArr = null;\n  let resolvedSymbol = preferSymbol ?? null;\n\n  if (Array.isArray(bars)) {\n    // Single-symbol shape\n    barArr = bars;\n  } else if (typeof bars === 'object') {\n    // Multi-symbol shape: bars is an object keyed by symbol\n    const keys = Object.keys(bars);\n    if (!keys.length) {\n      return { candles: [], reason: 'Alpaca response bars={} empty', next_page_token: r.next_page_token ?? null };\n    }\n\n    // Prefer the symbol you requested (if known)\n    const sym = (preferSymbol || '').toUpperCase();\n    if (sym && bars[sym] && Array.isArray(bars[sym])) {\n      barArr = bars[sym];\n      resolvedSymbol = sym;\n    } else {\n      // Fallback: first available symbol\n      const firstKey = keys[0];\n      barArr = Array.isArray(bars[firstKey]) ? bars[firstKey] : [];\n      resolvedSymbol = resolvedSymbol ?? firstKey;\n    }\n  } else {\n    return { candles: [], reason: 'Alpaca response bars has unexpected type', next_page_token: r.next_page_token ?? null };\n  }\n\n  if (!Array.isArray(barArr) || barArr.length === 0) {\n    return { candles: [], reason: 'No bar rows returned for requested window', next_page_token: r.next_page_token ?? null, symbol: resolvedSymbol };\n  }\n\n  // Map Alpaca bar objects to your candle shape {t,o,h,l,c,v}\n  // Alpaca bar fields commonly: t,o,h,l,c,v (plus n=trade_count, vw=vwap) :contentReference[oaicite:3]{index=3}\n  const candles = [];\n\n  for (const b of barArr) {\n    const tIso = toISOFromAlpaca(b?.t ?? b?.timestamp ?? b?.time);\n    const o = b?.o ?? b?.open;\n    const h = b?.h ?? b?.high;\n    const l = b?.l ?? b?.low;\n    const c = b?.c ?? b?.close;\n    const v = b?.v ?? b?.volume;\n\n    if (!tIso) continue;\n    if (o == null || h == null || l == null || c == null) continue;\n\n    candles.push({\n      t: tIso,\n      o,\n      h,\n      l,\n      c,\n      v: v == null ? 0 : v,\n    });\n  }\n\n  // Ensure ascending time\n  candles.sort((a, b) => new Date(a.t) - new Date(b.t));\n\n  return {\n    candles,\n    reason: candles.length ? null : 'All bars were filtered out (missing OHLC or invalid timestamps)',\n    symbol: resolvedSymbol,\n    next_page_token: r.next_page_token ?? null,\n  };\n}\n\n/**\n * Simplified TD Sequential (common baseline)\n * - Setup (9): compares close vs close 4 bars earlier\n *   bullish setup increments when close < close[4]  (downward pressure; often called \"buy setup\")\n *   bearish setup increments when close > close[4]  (upward pressure; often called \"sell setup\")\n * - Countdown (13): after setup completes, count nonconsecutive bars:\n *   bullish countdown when close <= low[2]\n *   bearish countdown when close >= high[2]\n */\nfunction computeTDSequential(candles) {\n  const n = candles.length;\n  const td = new Array(n);\n\n  let bullSetup = 0;\n  let bearSetup = 0;\n\n  let cdDir = null;      // 'bullish' | 'bearish'\n  let cdCount = 0;\n  let setupCompletedIndex = -1;\n\n  for (let i = 0; i < n; i++) {\n    td[i] = {\n      setupDir: null,\n      setupCount: 0,\n      setupCompleted: false,\n      countdownDir: cdDir,\n      countdownCount: cdCount,\n      countdownCompleted: false\n    };\n\n    // --- SETUP ---\n    if (i >= 4) {\n      const c0 = candles[i].c;\n      const c4 = candles[i - 4].c;\n\n      if (c0 < c4) bullSetup += 1;\n      else bullSetup = 0;\n\n      if (c0 > c4) bearSetup += 1;\n      else bearSetup = 0;\n\n      let setupDir = null;\n      let setupCount = 0;\n\n      if (bullSetup > 0 && bearSetup === 0) {\n        setupDir = 'bullish';\n        setupCount = bullSetup;\n      } else if (bearSetup > 0 && bullSetup === 0) {\n        setupDir = 'bearish';\n        setupCount = bearSetup;\n      } else if (bullSetup > 0 && bearSetup > 0) {\n        if (bullSetup >= bearSetup) {\n          setupDir = 'bullish';\n          setupCount = bullSetup;\n        } else {\n          setupDir = 'bearish';\n          setupCount = bearSetup;\n        }\n      }\n\n      if (setupCount > 9) setupCount = 9;\n\n      td[i].setupDir = setupDir;\n      td[i].setupCount = setupCount;\n      td[i].setupCompleted = (setupCount === 9);\n\n      if (td[i].setupCompleted && setupDir) {\n        cdDir = setupDir;\n        cdCount = 0;\n        setupCompletedIndex = i;\n      }\n    }\n\n    // --- COUNTDOWN ---\n    if (cdDir && setupCompletedIndex >= 0 && i > setupCompletedIndex && i >= 2) {\n      const c0 = candles[i].c;\n      const low2 = candles[i - 2].l;\n      const high2 = candles[i - 2].h;\n\n      if (cdDir === 'bullish') {\n        if (c0 <= low2) cdCount += 1;\n      } else if (cdDir === 'bearish') {\n        if (c0 >= high2) cdCount += 1;\n      }\n\n      if (cdCount > 13) cdCount = 13;\n\n      td[i].countdownDir = cdDir;\n      td[i].countdownCount = cdCount;\n      td[i].countdownCompleted = (cdCount === 13);\n    } else {\n      td[i].countdownDir = cdDir;\n      td[i].countdownCount = cdCount;\n      td[i].countdownCompleted = (cdCount === 13);\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    candles[i].td = td[i];\n  }\n\n  const last = n ? candles[n - 1].td : null;\n\n  return {\n    candles,\n    tdSummary: {\n      tf: TF,\n      setupDir: last ? last.setupDir : null,\n      setupCount: last ? last.setupCount : 0,\n      setupCompleted: last ? last.setupCompleted : false,\n      countdownDir: last ? last.countdownDir : null,\n      countdownCount: last ? last.countdownCount : 0,\n      countdownCompleted: last ? last.countdownCompleted : false\n    }\n  };\n}\n\n/**\n * Price structure helpers\n */\nfunction computePriceStructure(candles, swingN, atrN) {\n  const n = candles.length;\n  if (!n) {\n    return {\n      last_close: null, last_high: null, last_low: null,\n      swing_n: swingN,\n      swing_high_n: null, swing_high_time: null,\n      swing_low_n: null, swing_low_time: null,\n      atr_n: atrN,\n      atr_n_sma: null,\n      true_range_avg_n: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[n - 1];\n\n  // --- Swing levels (last N bars) ---\n  const win = Math.min(swingN, n);\n  let swingHigh = -Infinity, swingLow = Infinity;\n  let swingHighTime = null, swingLowTime = null;\n\n  for (let i = n - win; i < n; i++) {\n    const c = candles[i];\n    if (c.h != null && c.h >= swingHigh) { swingHigh = c.h; swingHighTime = c.t; }\n    if (c.l != null && c.l <= swingLow)  { swingLow  = c.l; swingLowTime  = c.t; }\n  }\n\n  if (!Number.isFinite(swingHigh)) { swingHigh = null; swingHighTime = null; }\n  if (!Number.isFinite(swingLow))  { swingLow  = null; swingLowTime  = null; }\n\n  // --- True Range + ATR (SMA) ---\n  const trs = [];\n  for (let i = 1; i < n; i++) {\n    const cur = candles[i];\n    const prev = candles[i - 1];\n    if (cur.h == null || cur.l == null || prev.c == null) continue;\n\n    const hl = cur.h - cur.l;\n    const hc = Math.abs(cur.h - prev.c);\n    const lc = Math.abs(cur.l - prev.c);\n    const tr = Math.max(hl, hc, lc);\n\n    if (Number.isFinite(tr)) trs.push(tr);\n  }\n\n  const atrWin = Math.min(atrN, trs.length);\n  let atrSma = null;\n  let trAvg = null;\n\n  if (atrWin > 0) {\n    const slice = trs.slice(trs.length - atrWin);\n    const sum = slice.reduce((a, b) => a + b, 0);\n    trAvg = sum / atrWin;\n    atrSma = trAvg;\n  }\n\n  return {\n    last_close: last.c ?? null,\n    last_high: last.h ?? null,\n    last_low: last.l ?? null,\n\n    swing_n: swingN,\n    swing_high_n: swingHigh,\n    swing_high_time: swingHighTime,\n    swing_low_n: swingLow,\n    swing_low_time: swingLowTime,\n\n    atr_n: atrN,\n    atr_n_sma: atrSma,\n    true_range_avg_n: trAvg,\n\n    swing_effective_n: win,\n    atr_effective_n: atrWin,\n    reason: null\n  };\n}\n\n// ---- main (ALPACA) ----\n//\n// In n8n, after your HTTP Request node (JSON response), items[0].json is the Alpaca response.\n// For multi-bars: items[0].json.bars is usually an object keyed by symbol. :contentReference[oaicite:4]{index=4}\n//\n// If your HTTP node *replaces* the item and you lose the requested ticker,\n// use Set Request node as the source of truth.\nconst responseJson = items[0].json;\n\n// Prefer ticker from Set Request, fallback to response-derived\nconst preferTicker =\n  $node[\"Set Request\"].json.Ticker ??\n  $node[\"Set Request\"].json.ticker ??\n  $node[\"Set Request\"].json.symbol ??\n  null;\n\nconst parsed = parseAlpacaBars(responseJson, preferTicker);\nconst ticker = parsed.symbol ?? preferTicker ?? null;\n\nif (!parsed.candles.length) {\n  return [{\n    json: {\n      ticker,\n      tf: TF,\n      status: 'insufficient_data',\n      reason: parsed.reason || 'No valid candles parsed',\n      candles: [],\n      tdSummary: {\n        tf: TF,\n        setupDir: null, setupCount: 0, setupCompleted: false,\n        countdownDir: null, countdownCount: 0, countdownCompleted: false\n      },\n      price: computePriceStructure([], SWING_N, ATR_N),\n      next_page_token: parsed.next_page_token ?? null\n    }\n  }];\n}\n\nconst tdOut = computeTDSequential(parsed.candles);\nconst price = computePriceStructure(tdOut.candles, SWING_N, ATR_N);\n\nreturn [{\n  json: {\n    ticker,\n    tf: TF,\n    status: 'ok',\n    reason: null,\n    candles: tdOut.candles,\n    tdSummary: tdOut.tdSummary,\n    price,\n    next_page_token: parsed.next_page_token ?? null\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        30048,
        33600
      ],
      "id": "66b3beb2-7fe9-4beb-905f-d73d41a301f0",
      "name": "Normalize Results"
    },
    {
      "parameters": {
        "url": "=https://data.alpaca.markets/v2/stocks/bars",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "symbols",
              "value": "={{ $json.requests[1].qs.symbols }}"
            },
            {
              "name": "=timeframe",
              "value": "={{ $json.requests[1].qs.timeframe }}"
            },
            {
              "name": "start",
              "value": "={{ $json.requests[1].qs.start }}"
            },
            {
              "name": "end",
              "value": "={{ $json.requests[1].qs.end }}"
            },
            {
              "name": "limit",
              "value": "={{ $json.requests[1].qs.limit }}"
            },
            {
              "name": "feed",
              "value": "={{ $json.requests[1].qs.feed }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        29856,
        33792
      ],
      "id": "d1de2bc2-c487-400a-af47-c002a95b8d2e",
      "name": "HTTP Request1"
    },
    {
      "parameters": {
        "url": "=https://data.alpaca.markets/v2/stocks/bars",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "symbols",
              "value": "={{ $json.requests[2].qs.symbols }}"
            },
            {
              "name": "=timeframe",
              "value": "={{ $json.requests[2].qs.timeframe }}"
            },
            {
              "name": "start",
              "value": "={{ $json.requests[2].qs.start }}"
            },
            {
              "name": "end",
              "value": "={{ $json.requests[2].qs.end }}"
            },
            {
              "name": "limit",
              "value": "={{ $json.requests[2].qs.limit }}"
            },
            {
              "name": "feed",
              "value": "={{ $json.requests[2].qs.feed }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        29840,
        34000
      ],
      "id": "a9494612-29d7-430d-9c87-c1d49456b203",
      "name": "HTTP Request2"
    },
    {
      "parameters": {
        "jsCode": "// ===== CONFIG (set per branch) =====\nconst TF = $node[\"Set Request\"].json.intervals[1];\n\n// Lookbacks (minimal additions for price structure)\nconst SWING_N = $node[\"Set Request\"].json.swingLookback ?? 20; // e.g., last 20 bars\nconst ATR_N   = $node[\"Set Request\"].json.atrLookback   ?? 14; // e.g., ATR(14)\n// ===================================\n\n// --- Time helper: Alpaca bars use RFC3339 timestamps (usually string), but be defensive ---\nfunction toISOFromAlpaca(t) {\n  if (t == null) return null;\n\n  // Common case: RFC3339 string like \"2025-12-19T20:59:00Z\"\n  if (typeof t === 'string') {\n    const ms = Date.parse(t);\n    if (!Number.isFinite(ms)) return null;\n    return new Date(ms).toISOString();\n  }\n\n  // Defensive: if numeric, interpret as seconds/ms/ns based on magnitude\n  if (typeof t === 'number' && Number.isFinite(t)) {\n    let ms = t;\n    if (t < 1e11) ms = t * 1000;          // seconds -> ms\n    else if (t > 1e14) ms = Math.floor(t / 1e6); // ns -> ms (very defensive)\n    const d = new Date(ms);\n    return Number.isFinite(d.getTime()) ? d.toISOString() : null;\n  }\n\n  return null;\n}\n\n/**\n * Parse Alpaca bars response to candles[]\n *\n * Supports these shapes:\n * 1) Multi-bars: { bars: { \"SPY\": [ {t,o,h,l,c,v,...}, ... ] }, next_page_token: \"...\" }\n * 2) Single-symbol bars (some clients): { bars: [ {t,o,h,l,c,v,...}, ... ], next_page_token: \"...\" }\n * 3) \"bars\" might be null when no data\n */\nfunction parseAlpacaBars(responseJson, preferSymbol) {\n  const r = responseJson || {};\n  const bars = r.bars;\n\n  if (bars == null) {\n    return { candles: [], reason: 'Alpaca response has bars=null (no data for requested window)', next_page_token: r.next_page_token ?? null };\n  }\n\n  let barArr = null;\n  let resolvedSymbol = preferSymbol ?? null;\n\n  if (Array.isArray(bars)) {\n    // Single-symbol shape\n    barArr = bars;\n  } else if (typeof bars === 'object') {\n    // Multi-symbol shape: bars is an object keyed by symbol\n    const keys = Object.keys(bars);\n    if (!keys.length) {\n      return { candles: [], reason: 'Alpaca response bars={} empty', next_page_token: r.next_page_token ?? null };\n    }\n\n    // Prefer the symbol you requested (if known)\n    const sym = (preferSymbol || '').toUpperCase();\n    if (sym && bars[sym] && Array.isArray(bars[sym])) {\n      barArr = bars[sym];\n      resolvedSymbol = sym;\n    } else {\n      // Fallback: first available symbol\n      const firstKey = keys[0];\n      barArr = Array.isArray(bars[firstKey]) ? bars[firstKey] : [];\n      resolvedSymbol = resolvedSymbol ?? firstKey;\n    }\n  } else {\n    return { candles: [], reason: 'Alpaca response bars has unexpected type', next_page_token: r.next_page_token ?? null };\n  }\n\n  if (!Array.isArray(barArr) || barArr.length === 0) {\n    return { candles: [], reason: 'No bar rows returned for requested window', next_page_token: r.next_page_token ?? null, symbol: resolvedSymbol };\n  }\n\n  // Map Alpaca bar objects to your candle shape {t,o,h,l,c,v}\n  // Alpaca bar fields commonly: t,o,h,l,c,v (plus n=trade_count, vw=vwap) :contentReference[oaicite:3]{index=3}\n  const candles = [];\n\n  for (const b of barArr) {\n    const tIso = toISOFromAlpaca(b?.t ?? b?.timestamp ?? b?.time);\n    const o = b?.o ?? b?.open;\n    const h = b?.h ?? b?.high;\n    const l = b?.l ?? b?.low;\n    const c = b?.c ?? b?.close;\n    const v = b?.v ?? b?.volume;\n\n    if (!tIso) continue;\n    if (o == null || h == null || l == null || c == null) continue;\n\n    candles.push({\n      t: tIso,\n      o,\n      h,\n      l,\n      c,\n      v: v == null ? 0 : v,\n    });\n  }\n\n  // Ensure ascending time\n  candles.sort((a, b) => new Date(a.t) - new Date(b.t));\n\n  return {\n    candles,\n    reason: candles.length ? null : 'All bars were filtered out (missing OHLC or invalid timestamps)',\n    symbol: resolvedSymbol,\n    next_page_token: r.next_page_token ?? null,\n  };\n}\n\n/**\n * Simplified TD Sequential (common baseline)\n * - Setup (9): compares close vs close 4 bars earlier\n *   bullish setup increments when close < close[4]  (downward pressure; often called \"buy setup\")\n *   bearish setup increments when close > close[4]  (upward pressure; often called \"sell setup\")\n * - Countdown (13): after setup completes, count nonconsecutive bars:\n *   bullish countdown when close <= low[2]\n *   bearish countdown when close >= high[2]\n */\nfunction computeTDSequential(candles) {\n  const n = candles.length;\n  const td = new Array(n);\n\n  let bullSetup = 0;\n  let bearSetup = 0;\n\n  let cdDir = null;      // 'bullish' | 'bearish'\n  let cdCount = 0;\n  let setupCompletedIndex = -1;\n\n  for (let i = 0; i < n; i++) {\n    td[i] = {\n      setupDir: null,\n      setupCount: 0,\n      setupCompleted: false,\n      countdownDir: cdDir,\n      countdownCount: cdCount,\n      countdownCompleted: false\n    };\n\n    // --- SETUP ---\n    if (i >= 4) {\n      const c0 = candles[i].c;\n      const c4 = candles[i - 4].c;\n\n      if (c0 < c4) bullSetup += 1;\n      else bullSetup = 0;\n\n      if (c0 > c4) bearSetup += 1;\n      else bearSetup = 0;\n\n      let setupDir = null;\n      let setupCount = 0;\n\n      if (bullSetup > 0 && bearSetup === 0) {\n        setupDir = 'bullish';\n        setupCount = bullSetup;\n      } else if (bearSetup > 0 && bullSetup === 0) {\n        setupDir = 'bearish';\n        setupCount = bearSetup;\n      } else if (bullSetup > 0 && bearSetup > 0) {\n        if (bullSetup >= bearSetup) {\n          setupDir = 'bullish';\n          setupCount = bullSetup;\n        } else {\n          setupDir = 'bearish';\n          setupCount = bearSetup;\n        }\n      }\n\n      if (setupCount > 9) setupCount = 9;\n\n      td[i].setupDir = setupDir;\n      td[i].setupCount = setupCount;\n      td[i].setupCompleted = (setupCount === 9);\n\n      if (td[i].setupCompleted && setupDir) {\n        cdDir = setupDir;\n        cdCount = 0;\n        setupCompletedIndex = i;\n      }\n    }\n\n    // --- COUNTDOWN ---\n    if (cdDir && setupCompletedIndex >= 0 && i > setupCompletedIndex && i >= 2) {\n      const c0 = candles[i].c;\n      const low2 = candles[i - 2].l;\n      const high2 = candles[i - 2].h;\n\n      if (cdDir === 'bullish') {\n        if (c0 <= low2) cdCount += 1;\n      } else if (cdDir === 'bearish') {\n        if (c0 >= high2) cdCount += 1;\n      }\n\n      if (cdCount > 13) cdCount = 13;\n\n      td[i].countdownDir = cdDir;\n      td[i].countdownCount = cdCount;\n      td[i].countdownCompleted = (cdCount === 13);\n    } else {\n      td[i].countdownDir = cdDir;\n      td[i].countdownCount = cdCount;\n      td[i].countdownCompleted = (cdCount === 13);\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    candles[i].td = td[i];\n  }\n\n  const last = n ? candles[n - 1].td : null;\n\n  return {\n    candles,\n    tdSummary: {\n      tf: TF,\n      setupDir: last ? last.setupDir : null,\n      setupCount: last ? last.setupCount : 0,\n      setupCompleted: last ? last.setupCompleted : false,\n      countdownDir: last ? last.countdownDir : null,\n      countdownCount: last ? last.countdownCount : 0,\n      countdownCompleted: last ? last.countdownCompleted : false\n    }\n  };\n}\n\n/**\n * Price structure helpers\n */\nfunction computePriceStructure(candles, swingN, atrN) {\n  const n = candles.length;\n  if (!n) {\n    return {\n      last_close: null, last_high: null, last_low: null,\n      swing_n: swingN,\n      swing_high_n: null, swing_high_time: null,\n      swing_low_n: null, swing_low_time: null,\n      atr_n: atrN,\n      atr_n_sma: null,\n      true_range_avg_n: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[n - 1];\n\n  // --- Swing levels (last N bars) ---\n  const win = Math.min(swingN, n);\n  let swingHigh = -Infinity, swingLow = Infinity;\n  let swingHighTime = null, swingLowTime = null;\n\n  for (let i = n - win; i < n; i++) {\n    const c = candles[i];\n    if (c.h != null && c.h >= swingHigh) { swingHigh = c.h; swingHighTime = c.t; }\n    if (c.l != null && c.l <= swingLow)  { swingLow  = c.l; swingLowTime  = c.t; }\n  }\n\n  if (!Number.isFinite(swingHigh)) { swingHigh = null; swingHighTime = null; }\n  if (!Number.isFinite(swingLow))  { swingLow  = null; swingLowTime  = null; }\n\n  // --- True Range + ATR (SMA) ---\n  const trs = [];\n  for (let i = 1; i < n; i++) {\n    const cur = candles[i];\n    const prev = candles[i - 1];\n    if (cur.h == null || cur.l == null || prev.c == null) continue;\n\n    const hl = cur.h - cur.l;\n    const hc = Math.abs(cur.h - prev.c);\n    const lc = Math.abs(cur.l - prev.c);\n    const tr = Math.max(hl, hc, lc);\n\n    if (Number.isFinite(tr)) trs.push(tr);\n  }\n\n  const atrWin = Math.min(atrN, trs.length);\n  let atrSma = null;\n  let trAvg = null;\n\n  if (atrWin > 0) {\n    const slice = trs.slice(trs.length - atrWin);\n    const sum = slice.reduce((a, b) => a + b, 0);\n    trAvg = sum / atrWin;\n    atrSma = trAvg;\n  }\n\n  return {\n    last_close: last.c ?? null,\n    last_high: last.h ?? null,\n    last_low: last.l ?? null,\n\n    swing_n: swingN,\n    swing_high_n: swingHigh,\n    swing_high_time: swingHighTime,\n    swing_low_n: swingLow,\n    swing_low_time: swingLowTime,\n\n    atr_n: atrN,\n    atr_n_sma: atrSma,\n    true_range_avg_n: trAvg,\n\n    swing_effective_n: win,\n    atr_effective_n: atrWin,\n    reason: null\n  };\n}\n\n// ---- main (ALPACA) ----\n//\n// In n8n, after your HTTP Request node (JSON response), items[0].json is the Alpaca response.\n// For multi-bars: items[0].json.bars is usually an object keyed by symbol. :contentReference[oaicite:4]{index=4}\n//\n// If your HTTP node *replaces* the item and you lose the requested ticker,\n// use Set Request node as the source of truth.\nconst responseJson = items[0].json;\n\n// Prefer ticker from Set Request, fallback to response-derived\nconst preferTicker =\n  $node[\"Set Request\"].json.Ticker ??\n  $node[\"Set Request\"].json.ticker ??\n  $node[\"Set Request\"].json.symbol ??\n  null;\n\nconst parsed = parseAlpacaBars(responseJson, preferTicker);\nconst ticker = parsed.symbol ?? preferTicker ?? null;\n\nif (!parsed.candles.length) {\n  return [{\n    json: {\n      ticker,\n      tf: TF,\n      status: 'insufficient_data',\n      reason: parsed.reason || 'No valid candles parsed',\n      candles: [],\n      tdSummary: {\n        tf: TF,\n        setupDir: null, setupCount: 0, setupCompleted: false,\n        countdownDir: null, countdownCount: 0, countdownCompleted: false\n      },\n      price: computePriceStructure([], SWING_N, ATR_N),\n      next_page_token: parsed.next_page_token ?? null\n    }\n  }];\n}\n\nconst tdOut = computeTDSequential(parsed.candles);\nconst price = computePriceStructure(tdOut.candles, SWING_N, ATR_N);\n\nreturn [{\n  json: {\n    ticker,\n    tf: TF,\n    status: 'ok',\n    reason: null,\n    candles: tdOut.candles,\n    tdSummary: tdOut.tdSummary,\n    price,\n    next_page_token: parsed.next_page_token ?? null\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        30064,
        33792
      ],
      "id": "b6d2b37e-b0b7-42fe-bf64-a142f682b191",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "jsCode": "// ===== CONFIG (set per branch) =====\nconst TF = $node[\"Set Request\"].json.intervals[2];\n\n// Lookbacks (minimal additions for price structure)\nconst SWING_N = $node[\"Set Request\"].json.swingLookback ?? 20; // e.g., last 20 bars\nconst ATR_N   = $node[\"Set Request\"].json.atrLookback   ?? 14; // e.g., ATR(14)\n// ===================================\n\n// --- Time helper: Alpaca bars use RFC3339 timestamps (usually string), but be defensive ---\nfunction toISOFromAlpaca(t) {\n  if (t == null) return null;\n\n  // Common case: RFC3339 string like \"2025-12-19T20:59:00Z\"\n  if (typeof t === 'string') {\n    const ms = Date.parse(t);\n    if (!Number.isFinite(ms)) return null;\n    return new Date(ms).toISOString();\n  }\n\n  // Defensive: if numeric, interpret as seconds/ms/ns based on magnitude\n  if (typeof t === 'number' && Number.isFinite(t)) {\n    let ms = t;\n    if (t < 1e11) ms = t * 1000;          // seconds -> ms\n    else if (t > 1e14) ms = Math.floor(t / 1e6); // ns -> ms (very defensive)\n    const d = new Date(ms);\n    return Number.isFinite(d.getTime()) ? d.toISOString() : null;\n  }\n\n  return null;\n}\n\n/**\n * Parse Alpaca bars response to candles[]\n *\n * Supports these shapes:\n * 1) Multi-bars: { bars: { \"SPY\": [ {t,o,h,l,c,v,...}, ... ] }, next_page_token: \"...\" }\n * 2) Single-symbol bars (some clients): { bars: [ {t,o,h,l,c,v,...}, ... ], next_page_token: \"...\" }\n * 3) \"bars\" might be null when no data\n */\nfunction parseAlpacaBars(responseJson, preferSymbol) {\n  const r = responseJson || {};\n  const bars = r.bars;\n\n  if (bars == null) {\n    return { candles: [], reason: 'Alpaca response has bars=null (no data for requested window)', next_page_token: r.next_page_token ?? null };\n  }\n\n  let barArr = null;\n  let resolvedSymbol = preferSymbol ?? null;\n\n  if (Array.isArray(bars)) {\n    // Single-symbol shape\n    barArr = bars;\n  } else if (typeof bars === 'object') {\n    // Multi-symbol shape: bars is an object keyed by symbol\n    const keys = Object.keys(bars);\n    if (!keys.length) {\n      return { candles: [], reason: 'Alpaca response bars={} empty', next_page_token: r.next_page_token ?? null };\n    }\n\n    // Prefer the symbol you requested (if known)\n    const sym = (preferSymbol || '').toUpperCase();\n    if (sym && bars[sym] && Array.isArray(bars[sym])) {\n      barArr = bars[sym];\n      resolvedSymbol = sym;\n    } else {\n      // Fallback: first available symbol\n      const firstKey = keys[0];\n      barArr = Array.isArray(bars[firstKey]) ? bars[firstKey] : [];\n      resolvedSymbol = resolvedSymbol ?? firstKey;\n    }\n  } else {\n    return { candles: [], reason: 'Alpaca response bars has unexpected type', next_page_token: r.next_page_token ?? null };\n  }\n\n  if (!Array.isArray(barArr) || barArr.length === 0) {\n    return { candles: [], reason: 'No bar rows returned for requested window', next_page_token: r.next_page_token ?? null, symbol: resolvedSymbol };\n  }\n\n  // Map Alpaca bar objects to your candle shape {t,o,h,l,c,v}\n  // Alpaca bar fields commonly: t,o,h,l,c,v (plus n=trade_count, vw=vwap) :contentReference[oaicite:3]{index=3}\n  const candles = [];\n\n  for (const b of barArr) {\n    const tIso = toISOFromAlpaca(b?.t ?? b?.timestamp ?? b?.time);\n    const o = b?.o ?? b?.open;\n    const h = b?.h ?? b?.high;\n    const l = b?.l ?? b?.low;\n    const c = b?.c ?? b?.close;\n    const v = b?.v ?? b?.volume;\n\n    if (!tIso) continue;\n    if (o == null || h == null || l == null || c == null) continue;\n\n    candles.push({\n      t: tIso,\n      o,\n      h,\n      l,\n      c,\n      v: v == null ? 0 : v,\n    });\n  }\n\n  // Ensure ascending time\n  candles.sort((a, b) => new Date(a.t) - new Date(b.t));\n\n  return {\n    candles,\n    reason: candles.length ? null : 'All bars were filtered out (missing OHLC or invalid timestamps)',\n    symbol: resolvedSymbol,\n    next_page_token: r.next_page_token ?? null,\n  };\n}\n\n/**\n * Simplified TD Sequential (common baseline)\n * - Setup (9): compares close vs close 4 bars earlier\n *   bullish setup increments when close < close[4]  (downward pressure; often called \"buy setup\")\n *   bearish setup increments when close > close[4]  (upward pressure; often called \"sell setup\")\n * - Countdown (13): after setup completes, count nonconsecutive bars:\n *   bullish countdown when close <= low[2]\n *   bearish countdown when close >= high[2]\n */\nfunction computeTDSequential(candles) {\n  const n = candles.length;\n  const td = new Array(n);\n\n  let bullSetup = 0;\n  let bearSetup = 0;\n\n  let cdDir = null;      // 'bullish' | 'bearish'\n  let cdCount = 0;\n  let setupCompletedIndex = -1;\n\n  for (let i = 0; i < n; i++) {\n    td[i] = {\n      setupDir: null,\n      setupCount: 0,\n      setupCompleted: false,\n      countdownDir: cdDir,\n      countdownCount: cdCount,\n      countdownCompleted: false\n    };\n\n    // --- SETUP ---\n    if (i >= 4) {\n      const c0 = candles[i].c;\n      const c4 = candles[i - 4].c;\n\n      if (c0 < c4) bullSetup += 1;\n      else bullSetup = 0;\n\n      if (c0 > c4) bearSetup += 1;\n      else bearSetup = 0;\n\n      let setupDir = null;\n      let setupCount = 0;\n\n      if (bullSetup > 0 && bearSetup === 0) {\n        setupDir = 'bullish';\n        setupCount = bullSetup;\n      } else if (bearSetup > 0 && bullSetup === 0) {\n        setupDir = 'bearish';\n        setupCount = bearSetup;\n      } else if (bullSetup > 0 && bearSetup > 0) {\n        if (bullSetup >= bearSetup) {\n          setupDir = 'bullish';\n          setupCount = bullSetup;\n        } else {\n          setupDir = 'bearish';\n          setupCount = bearSetup;\n        }\n      }\n\n      if (setupCount > 9) setupCount = 9;\n\n      td[i].setupDir = setupDir;\n      td[i].setupCount = setupCount;\n      td[i].setupCompleted = (setupCount === 9);\n\n      if (td[i].setupCompleted && setupDir) {\n        cdDir = setupDir;\n        cdCount = 0;\n        setupCompletedIndex = i;\n      }\n    }\n\n    // --- COUNTDOWN ---\n    if (cdDir && setupCompletedIndex >= 0 && i > setupCompletedIndex && i >= 2) {\n      const c0 = candles[i].c;\n      const low2 = candles[i - 2].l;\n      const high2 = candles[i - 2].h;\n\n      if (cdDir === 'bullish') {\n        if (c0 <= low2) cdCount += 1;\n      } else if (cdDir === 'bearish') {\n        if (c0 >= high2) cdCount += 1;\n      }\n\n      if (cdCount > 13) cdCount = 13;\n\n      td[i].countdownDir = cdDir;\n      td[i].countdownCount = cdCount;\n      td[i].countdownCompleted = (cdCount === 13);\n    } else {\n      td[i].countdownDir = cdDir;\n      td[i].countdownCount = cdCount;\n      td[i].countdownCompleted = (cdCount === 13);\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    candles[i].td = td[i];\n  }\n\n  const last = n ? candles[n - 1].td : null;\n\n  return {\n    candles,\n    tdSummary: {\n      tf: TF,\n      setupDir: last ? last.setupDir : null,\n      setupCount: last ? last.setupCount : 0,\n      setupCompleted: last ? last.setupCompleted : false,\n      countdownDir: last ? last.countdownDir : null,\n      countdownCount: last ? last.countdownCount : 0,\n      countdownCompleted: last ? last.countdownCompleted : false\n    }\n  };\n}\n\n/**\n * Price structure helpers\n */\nfunction computePriceStructure(candles, swingN, atrN) {\n  const n = candles.length;\n  if (!n) {\n    return {\n      last_close: null, last_high: null, last_low: null,\n      swing_n: swingN,\n      swing_high_n: null, swing_high_time: null,\n      swing_low_n: null, swing_low_time: null,\n      atr_n: atrN,\n      atr_n_sma: null,\n      true_range_avg_n: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[n - 1];\n\n  // --- Swing levels (last N bars) ---\n  const win = Math.min(swingN, n);\n  let swingHigh = -Infinity, swingLow = Infinity;\n  let swingHighTime = null, swingLowTime = null;\n\n  for (let i = n - win; i < n; i++) {\n    const c = candles[i];\n    if (c.h != null && c.h >= swingHigh) { swingHigh = c.h; swingHighTime = c.t; }\n    if (c.l != null && c.l <= swingLow)  { swingLow  = c.l; swingLowTime  = c.t; }\n  }\n\n  if (!Number.isFinite(swingHigh)) { swingHigh = null; swingHighTime = null; }\n  if (!Number.isFinite(swingLow))  { swingLow  = null; swingLowTime  = null; }\n\n  // --- True Range + ATR (SMA) ---\n  const trs = [];\n  for (let i = 1; i < n; i++) {\n    const cur = candles[i];\n    const prev = candles[i - 1];\n    if (cur.h == null || cur.l == null || prev.c == null) continue;\n\n    const hl = cur.h - cur.l;\n    const hc = Math.abs(cur.h - prev.c);\n    const lc = Math.abs(cur.l - prev.c);\n    const tr = Math.max(hl, hc, lc);\n\n    if (Number.isFinite(tr)) trs.push(tr);\n  }\n\n  const atrWin = Math.min(atrN, trs.length);\n  let atrSma = null;\n  let trAvg = null;\n\n  if (atrWin > 0) {\n    const slice = trs.slice(trs.length - atrWin);\n    const sum = slice.reduce((a, b) => a + b, 0);\n    trAvg = sum / atrWin;\n    atrSma = trAvg;\n  }\n\n  return {\n    last_close: last.c ?? null,\n    last_high: last.h ?? null,\n    last_low: last.l ?? null,\n\n    swing_n: swingN,\n    swing_high_n: swingHigh,\n    swing_high_time: swingHighTime,\n    swing_low_n: swingLow,\n    swing_low_time: swingLowTime,\n\n    atr_n: atrN,\n    atr_n_sma: atrSma,\n    true_range_avg_n: trAvg,\n\n    swing_effective_n: win,\n    atr_effective_n: atrWin,\n    reason: null\n  };\n}\n\n// ---- main (ALPACA) ----\n//\n// In n8n, after your HTTP Request node (JSON response), items[0].json is the Alpaca response.\n// For multi-bars: items[0].json.bars is usually an object keyed by symbol. :contentReference[oaicite:4]{index=4}\n//\n// If your HTTP node *replaces* the item and you lose the requested ticker,\n// use Set Request node as the source of truth.\nconst responseJson = items[0].json;\n\n// Prefer ticker from Set Request, fallback to response-derived\nconst preferTicker =\n  $node[\"Set Request\"].json.Ticker ??\n  $node[\"Set Request\"].json.ticker ??\n  $node[\"Set Request\"].json.symbol ??\n  null;\n\nconst parsed = parseAlpacaBars(responseJson, preferTicker);\nconst ticker = parsed.symbol ?? preferTicker ?? null;\n\nif (!parsed.candles.length) {\n  return [{\n    json: {\n      ticker,\n      tf: TF,\n      status: 'insufficient_data',\n      reason: parsed.reason || 'No valid candles parsed',\n      candles: [],\n      tdSummary: {\n        tf: TF,\n        setupDir: null, setupCount: 0, setupCompleted: false,\n        countdownDir: null, countdownCount: 0, countdownCompleted: false\n      },\n      price: computePriceStructure([], SWING_N, ATR_N),\n      next_page_token: parsed.next_page_token ?? null\n    }\n  }];\n}\n\nconst tdOut = computeTDSequential(parsed.candles);\nconst price = computePriceStructure(tdOut.candles, SWING_N, ATR_N);\n\nreturn [{\n  json: {\n    ticker,\n    tf: TF,\n    status: 'ok',\n    reason: null,\n    candles: tdOut.candles,\n    tdSummary: tdOut.tdSummary,\n    price,\n    next_page_token: parsed.next_page_token ?? null\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        30064,
        34000
      ],
      "id": "b390821b-2eb9-4cc1-9d96-c5cd32559e7d",
      "name": "Code in JavaScript2"
    },
    {
      "parameters": {
        "jsCode": "// ===== CONFIG =====\nconst DMI_PERIOD = 14;\n\n// Minimal price structure additions (for trigger/invalidation/target)\nconst SWING_N = 20;   // swing_high_N / swing_low_N lookback\nconst ATR_N   = 14;   // ATR lookback (SMA of True Range)\n// ==================\n\nfunction computeDMI(candles, period) {\n  if (!candles || candles.length <= period + 2) {\n    return {\n      status: 'insufficient_data',\n      reason: 'Not enough candles for DMI',\n      series: [],\n      summary: { latest: null, crossover: null, trendStrength: 'weak' }\n    };\n  }\n\n  // candles assumed sorted ascending\n  const plusDM = [];\n  const minusDM = [];\n  const tr = [];\n\n  for (let i = 1; i < candles.length; i++) {\n    const curr = candles[i];\n    const prev = candles[i - 1];\n\n    const upMove = curr.h - prev.h;\n    const downMove = prev.l - curr.l;\n\n    let plus = 0, minus = 0;\n    if (upMove > downMove && upMove > 0) plus = upMove;\n    if (downMove > upMove && downMove > 0) minus = downMove;\n\n    plusDM.push(plus);\n    minusDM.push(minus);\n\n    const tr1 = curr.h - curr.l;\n    const tr2 = Math.abs(curr.h - prev.c);\n    const tr3 = Math.abs(curr.l - prev.c);\n    tr.push(Math.max(tr1, tr2, tr3));\n  }\n\n  const smooth = (values) => {\n    const out = new Array(values.length).fill(null);\n    let sum = 0;\n    for (let i = 0; i < period; i++) sum += values[i];\n    out[period - 1] = sum;\n    for (let i = period; i < values.length; i++) {\n      const prev = out[i - 1];\n      out[i] = prev - prev / period + values[i];\n    }\n    return out;\n  };\n\n  const plusDMs = smooth(plusDM);\n  const minusDMs = smooth(minusDM);\n  const trs = smooth(tr);\n\n  const diPlusArr = [];\n  const diMinusArr = [];\n  const dxArr = [];\n\n  for (let i = 0; i < plusDM.length; i++) {\n    if (i < period - 1 || trs[i] === null) {\n      diPlusArr.push(null);\n      diMinusArr.push(null);\n      dxArr.push(null);\n      continue;\n    }\n\n    const p = plusDMs[i];\n    const m = minusDMs[i];\n    const t = trs[i];\n\n    const diPlus = t === 0 ? 0 : (p / t) * 100;\n    const diMinus = t === 0 ? 0 : (m / t) * 100;\n\n    diPlusArr.push(diPlus);\n    diMinusArr.push(diMinus);\n\n    const denom = diPlus + diMinus;\n    const dx = denom === 0 ? 0 : (Math.abs(diPlus - diMinus) / denom) * 100;\n    dxArr.push(dx);\n  }\n\n  // ADX\n  const adxArr = new Array(dxArr.length).fill(null);\n  let adx = null;\n\n  const firstDX = dxArr.findIndex(v => v !== null);\n  if (firstDX !== -1 && firstDX + period <= dxArr.length) {\n    let sumDX = 0;\n    for (let i = firstDX; i < firstDX + period; i++) sumDX += dxArr[i];\n    adx = sumDX / period;\n    adxArr[firstDX + period - 1] = adx;\n\n    for (let i = firstDX + period; i < dxArr.length; i++) {\n      adx = ((adx * (period - 1)) + dxArr[i]) / period;\n      adxArr[i] = adx;\n    }\n  }\n\n  const series = [];\n  for (let i = 0; i < dxArr.length; i++) {\n    series.push({\n      t: candles[i + 1].t,\n      diPlus: diPlusArr[i],\n      diMinus: diMinusArr[i],\n      adx: adxArr[i]\n    });\n  }\n\n  const valid = series.filter(p => p.diPlus !== null && p.adx !== null);\n  if (valid.length < 2) {\n    return {\n      status: 'partial',\n      reason: 'DMI computed but ADX not stable yet',\n      series,\n      summary: { latest: valid.length ? valid[valid.length - 1] : null, crossover: null, trendStrength: 'weak' }\n    };\n  }\n\n  const latest = valid[valid.length - 1];\n  const prev = valid[valid.length - 2];\n\n  let crossover = null;\n  const prevRel = prev.diPlus - prev.diMinus;\n  const currRel = latest.diPlus - latest.diMinus;\n  if (prevRel <= 0 && currRel > 0) crossover = 'bullish_cross_up';\n  else if (prevRel >= 0 && currRel < 0) crossover = 'bearish_cross_down';\n\n  let trendStrength = 'weak';\n  if (latest.adx >= 50) trendStrength = 'very_strong';\n  else if (latest.adx >= 25) trendStrength = 'moderate';\n\n  return {\n    status: 'ok',\n    reason: null,\n    series,\n    summary: { latest, crossover, trendStrength }\n  };\n}\n\n/**\n * NEW: price structure output so AI can compute trigger/invalidation/target\n * Requires only candles (o/h/l/c).\n *\n * Returns:\n * - last_close, last_high, last_low\n * - swing_high_n, swing_low_n (+ timestamps)\n * - atr_n_sma (SMA of True Range), true_range_avg_n\n */\nfunction computePriceStructure(candles, swingN, atrN) {\n  const n = Array.isArray(candles) ? candles.length : 0;\n  if (!n) {\n    return {\n      last_close: null, last_high: null, last_low: null,\n      swing_n: swingN,\n      swing_high_n: null, swing_high_time: null,\n      swing_low_n: null, swing_low_time: null,\n      atr_n: atrN,\n      atr_n_sma: null,\n      true_range_avg_n: null,\n      swing_effective_n: 0,\n      atr_effective_n: 0,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[n - 1];\n\n  // --- Swing levels over last N bars ---\n  const win = Math.min(swingN, n);\n  let swingHigh = -Infinity, swingLow = Infinity;\n  let swingHighTime = null, swingLowTime = null;\n\n  for (let i = n - win; i < n; i++) {\n    const c = candles[i];\n    if (c?.h != null && c.h >= swingHigh) { swingHigh = c.h; swingHighTime = c.t; }\n    if (c?.l != null && c.l <= swingLow)  { swingLow  = c.l; swingLowTime  = c.t; }\n  }\n\n  if (!Number.isFinite(swingHigh)) { swingHigh = null; swingHighTime = null; }\n  if (!Number.isFinite(swingLow))  { swingLow  = null; swingLowTime  = null; }\n\n  // --- True Range series ---\n  const trs = [];\n  for (let i = 1; i < n; i++) {\n    const cur = candles[i];\n    const prev = candles[i - 1];\n    if (cur?.h == null || cur?.l == null || prev?.c == null) continue;\n\n    const hl = cur.h - cur.l;\n    const hc = Math.abs(cur.h - prev.c);\n    const lc = Math.abs(cur.l - prev.c);\n    const tr = Math.max(hl, hc, lc);\n\n    if (Number.isFinite(tr)) trs.push(tr);\n  }\n\n  // --- ATR as SMA(TR, atrN) ---\n  const atrWin = Math.min(atrN, trs.length);\n  let atrSma = null;\n  let trAvg = null;\n\n  if (atrWin > 0) {\n    const slice = trs.slice(trs.length - atrWin);\n    const sum = slice.reduce((a, b) => a + b, 0);\n    trAvg = sum / atrWin;\n    atrSma = trAvg;\n  }\n\n  return {\n    last_close: last?.c ?? null,\n    last_high: last?.h ?? null,\n    last_low: last?.l ?? null,\n\n    swing_n: swingN,\n    swing_high_n: swingHigh,\n    swing_high_time: swingHighTime,\n    swing_low_n: swingLow,\n    swing_low_time: swingLowTime,\n\n    atr_n: atrN,\n    atr_n_sma: atrSma,\n    true_range_avg_n: trAvg,\n\n    swing_effective_n: win,\n    atr_effective_n: atrWin,\n    reason: null\n  };\n}\n\n\n\n// ---- NEW: Hammer candlestick detection (last candle) ----\n// Notes:\n// - A \"hammer\" typically has a small real body near the top of the range and a long lower wick.\n// - This function only detects the candle geometry (no trend context).\n// - If close < open, the same geometry is often called a \"hanging man\".\nfunction computeHammer(candles) {\n  if (!Array.isArray(candles) || candles.length === 0) {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[candles.length - 1] || {};\n  const o = Number(last.o);\n  const h = Number(last.h);\n  const l = Number(last.l);\n  const c = Number(last.c);\n\n  if (![o,h,l,c].every(Number.isFinite)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Non-finite OHLC'\n    };\n  }\n\n  const range = h - l;\n  if (!(range > 0)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Invalid range'\n    };\n  }\n\n  const body = Math.abs(c - o);\n  const upper = h - Math.max(o, c);\n  const lower = Math.min(o, c) - l;\n\n  const bodyPct = body / range;\n  const upperPct = upper / range;\n  const lowerPct = lower / range;\n\n  // Tunables: keep conservative defaults\n  const smallBody = bodyPct <= 0.35;\n  const longLower = lower >= 2 * body;\n  const smallUpper = upper <= 0.75 * body; // allow tiny upper wick\n\n  const present = !!(smallBody && longLower && smallUpper);\n  const type = present\n    ? (c >= o ? 'hammer' : 'hanging_man')\n    : null;\n\n  return {\n    present,\n    type,\n    candleTime: last.t ?? null,\n    bodyPct: Number.isFinite(bodyPct) ? bodyPct : null,\n    lowerWickPct: Number.isFinite(lowerPct) ? lowerPct : null,\n    upperWickPct: Number.isFinite(upperPct) ? upperPct : null,\n    reason: present ? null : 'Candle geometry did not meet hammer thresholds'\n  };\n}\n// ---- NEW: Shooting Star / Inverted Hammer detection (last candle) ----\n// Notes:\n// - Geometry-only detection (no trend context).\n// - Shooting star / inverted hammer: small real body with long upper wick and small lower wick.\n// - Type mapping by candle color:\n//   * close >= open => 'inverted_hammer' (often bullish context)\n//   * close < open  => 'shooting_star'   (often bearish context)\nfunction computeShootingStar(candles) {\n  if (!Array.isArray(candles) || candles.length === 0) {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[candles.length - 1] || {};\n  const o = Number(last.o);\n  const h = Number(last.h);\n  const l = Number(last.l);\n  const c = Number(last.c);\n\n  if (![o,h,l,c].every(Number.isFinite)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Non-finite OHLC'\n    };\n  }\n\n  const range = h - l;\n  if (!(range > 0)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Zero/negative range'\n    };\n  }\n\n  const body = Math.abs(c - o);\n  const upper = h - Math.max(o, c);\n  const lower = Math.min(o, c) - l;\n\n  const bodyPct = body / range;\n  const upperPct = upper / range;\n  const lowerPct = lower / range;\n\n  const smallBody = bodyPct <= 0.35;\n  const longUpper = upper >= 2 * body;\n  const smallLower = lower <= 0.75 * body; // allow tiny lower wick\n\n  const present = !!(smallBody && longUpper && smallLower);\n  const type = present\n    ? (c >= o ? 'inverted_hammer' : 'shooting_star')\n    : null;\n\n  return {\n    present,\n    type,\n    candleTime: last.t ?? null,\n    bodyPct: Number.isFinite(bodyPct) ? bodyPct : null,\n    lowerWickPct: Number.isFinite(lowerPct) ? lowerPct : null,\n    upperWickPct: Number.isFinite(upperPct) ? upperPct : null,\n    reason: present ? null : 'Candle geometry did not meet shooting star thresholds'\n  };\n}\n\n\n\n\n\n// ---- NEW: Bullish Engulfing detection (last 2 candles) ----\n// Notes:\n// - Bullish engulfing: prior candle bearish (close<open), current candle bullish (close>open),\n//   and current real body engulfs prior real body (curr.open <= prev.close && curr.close >= prev.open).\n// - Geometry-only detection (no trend context).\nfunction computeBullishEngulfing(candles) {\n  if (!Array.isArray(candles) || candles.length < 2) {\n    return { present: false, type: null, candleTime: null, prevTime: null, reason: 'Need at least 2 candles' };\n  }\n\n  const prev = candles[candles.length - 2] || {};\n  const curr = candles[candles.length - 1] || {};\n\n  const po = Number(prev.o); const pc = Number(prev.c);\n  const co = Number(curr.o); const cc = Number(curr.c);\n\n  if (![po, pc, co, cc].every(Number.isFinite)) {\n    return { present: false, type: null, candleTime: curr.t ?? null, prevTime: prev.t ?? null, reason: 'Non-finite OHLC' };\n  }\n\n  const prevBear = pc < po;\n  const currBull = cc > co;\n\n  const prevBody = Math.abs(pc - po);\n  const currBody = Math.abs(cc - co);\n\n  const engulfsBody = (co <= pc) && (cc >= po);\n  const biggerBody = currBody >= prevBody; // mild filter\n\n  const present = !!(prevBear && currBull && engulfsBody && biggerBody);\n\n  return {\n    present,\n    type: present ? 'bullish_engulfing' : null,\n    candleTime: curr.t ?? null,\n    prevTime: prev.t ?? null,\n    prevBody: Number.isFinite(prevBody) ? prevBody : null,\n    currBody: Number.isFinite(currBody) ? currBody : null,\n    reason: present ? null : 'Candle geometry did not meet bullish engulfing thresholds'\n  };\n}\n\n\n// ---- NEW: Bearish Engulfing detection (last 2 candles) ----\n// Notes:\n// - Bearish engulfing: prior candle bullish (close>open), current candle bearish (close<open),\n//   and current real body engulfs prior real body (curr.open >= prev.close && curr.close <= prev.open).\n// - Geometry-only detection (no trend context).\nfunction computeBearishEngulfing(candles) {\n  if (!Array.isArray(candles) || candles.length < 2) {\n    return { present: false, type: null, candleTime: null, prevTime: null, reason: 'Need at least 2 candles' };\n  }\n\n  const prev = candles[candles.length - 2] || {};\n  const curr = candles[candles.length - 1] || {};\n\n  const po = Number(prev.o); const pc = Number(prev.c);\n  const co = Number(curr.o); const cc = Number(curr.c);\n\n  if (![po, pc, co, cc].every(Number.isFinite)) {\n    return { present: false, type: null, candleTime: curr.t ?? null, prevTime: prev.t ?? null, reason: 'Non-finite OHLC' };\n  }\n\n  const prevBull = pc > po;\n  const currBear = cc < co;\n\n  const prevBody = Math.abs(pc - po);\n  const currBody = Math.abs(cc - co);\n\n  const engulfsBody = (co >= pc) && (cc <= po);\n  const biggerBody = currBody >= prevBody; // mild filter\n\n  const present = !!(prevBull && currBear && engulfsBody && biggerBody);\n\n  return {\n    present,\n    type: present ? 'bearish_engulfing' : null,\n    candleTime: curr.t ?? null,\n    prevTime: prev.t ?? null,\n    prevBody: Number.isFinite(prevBody) ? prevBody : null,\n    currBody: Number.isFinite(currBody) ? currBody : null,\n    reason: present ? null : 'Candle geometry did not meet bearish engulfing thresholds'\n  };\n}\n\n\n// ---- main ----\nconst j = items[0].json;\n\nconst ticker = j.ticker || null;\nconst tf = j.tf || null;\nconst candles = Array.isArray(j.candles) ? j.candles : [];\nconst tdSummary = j.tdSummary || null;\n\nconst dmiOut = computeDMI(candles, DMI_PERIOD);\n\n// NEW: compute price structure regardless of DMI status\nconst price = computePriceStructure(candles, SWING_N, ATR_N);\n\n\n\n// NEW: candlestick pattern\nconst hammer = computeHammer(candles);\nconst shooting_star = computeShootingStar(candles);\nconst bullish_engulfing = computeBullishEngulfing(candles);\nconst bearish_engulfing = computeBearishEngulfing(candles);\nreturn [{\n  json: {\n    ticker,\n    tf,\n\n    // DMI output (unchanged)\n    status: dmiOut.status,\n    reason: dmiOut.reason,\n    diPlus: dmiOut.summary.latest ? dmiOut.summary.latest.diPlus : null,\n    diMinus: dmiOut.summary.latest ? dmiOut.summary.latest.diMinus : null,\n    adx: dmiOut.summary.latest ? dmiOut.summary.latest.adx : null,\n    dmiSummary: dmiOut.summary,\n    dmiSeries: Array.isArray(dmiOut.series) ? dmiOut.series.slice(-20) : [],\n\n    // TD Sequential summary (unchanged)\n    demark: tdSummary,\n\n    // NEW: price structure for trigger / invalidation / target\n    price,\n\n    // NEW: candlestick pattern(s)\n    hammer,\n    shooting_star,\n    bullish_engulfing\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        30256,
        33600
      ],
      "id": "5eb258b6-04e4-4780-b3ee-e7e52f18fdc7",
      "name": "Code in JavaScript3"
    },
    {
      "parameters": {
        "jsCode": "// ===== CONFIG =====\nconst DMI_PERIOD = 14;\n\n// Minimal price structure additions (for trigger/invalidation/target)\nconst SWING_N = 20;   // swing_high_N / swing_low_N lookback\nconst ATR_N   = 14;   // ATR lookback (SMA of True Range)\n// ==================\n\nfunction computeDMI(candles, period) {\n  if (!candles || candles.length <= period + 2) {\n    return {\n      status: 'insufficient_data',\n      reason: 'Not enough candles for DMI',\n      series: [],\n      summary: { latest: null, crossover: null, trendStrength: 'weak' }\n    };\n  }\n\n  // candles assumed sorted ascending\n  const plusDM = [];\n  const minusDM = [];\n  const tr = [];\n\n  for (let i = 1; i < candles.length; i++) {\n    const curr = candles[i];\n    const prev = candles[i - 1];\n\n    const upMove = curr.h - prev.h;\n    const downMove = prev.l - curr.l;\n\n    let plus = 0, minus = 0;\n    if (upMove > downMove && upMove > 0) plus = upMove;\n    if (downMove > upMove && downMove > 0) minus = downMove;\n\n    plusDM.push(plus);\n    minusDM.push(minus);\n\n    const tr1 = curr.h - curr.l;\n    const tr2 = Math.abs(curr.h - prev.c);\n    const tr3 = Math.abs(curr.l - prev.c);\n    tr.push(Math.max(tr1, tr2, tr3));\n  }\n\n  const smooth = (values) => {\n    const out = new Array(values.length).fill(null);\n    let sum = 0;\n    for (let i = 0; i < period; i++) sum += values[i];\n    out[period - 1] = sum;\n    for (let i = period; i < values.length; i++) {\n      const prev = out[i - 1];\n      out[i] = prev - prev / period + values[i];\n    }\n    return out;\n  };\n\n  const plusDMs = smooth(plusDM);\n  const minusDMs = smooth(minusDM);\n  const trs = smooth(tr);\n\n  const diPlusArr = [];\n  const diMinusArr = [];\n  const dxArr = [];\n\n  for (let i = 0; i < plusDM.length; i++) {\n    if (i < period - 1 || trs[i] === null) {\n      diPlusArr.push(null);\n      diMinusArr.push(null);\n      dxArr.push(null);\n      continue;\n    }\n\n    const p = plusDMs[i];\n    const m = minusDMs[i];\n    const t = trs[i];\n\n    const diPlus = t === 0 ? 0 : (p / t) * 100;\n    const diMinus = t === 0 ? 0 : (m / t) * 100;\n\n    diPlusArr.push(diPlus);\n    diMinusArr.push(diMinus);\n\n    const denom = diPlus + diMinus;\n    const dx = denom === 0 ? 0 : (Math.abs(diPlus - diMinus) / denom) * 100;\n    dxArr.push(dx);\n  }\n\n  // ADX\n  const adxArr = new Array(dxArr.length).fill(null);\n  let adx = null;\n\n  const firstDX = dxArr.findIndex(v => v !== null);\n  if (firstDX !== -1 && firstDX + period <= dxArr.length) {\n    let sumDX = 0;\n    for (let i = firstDX; i < firstDX + period; i++) sumDX += dxArr[i];\n    adx = sumDX / period;\n    adxArr[firstDX + period - 1] = adx;\n\n    for (let i = firstDX + period; i < dxArr.length; i++) {\n      adx = ((adx * (period - 1)) + dxArr[i]) / period;\n      adxArr[i] = adx;\n    }\n  }\n\n  const series = [];\n  for (let i = 0; i < dxArr.length; i++) {\n    series.push({\n      t: candles[i + 1].t,\n      diPlus: diPlusArr[i],\n      diMinus: diMinusArr[i],\n      adx: adxArr[i]\n    });\n  }\n\n  const valid = series.filter(p => p.diPlus !== null && p.adx !== null);\n  if (valid.length < 2) {\n    return {\n      status: 'partial',\n      reason: 'DMI computed but ADX not stable yet',\n      series,\n      summary: { latest: valid.length ? valid[valid.length - 1] : null, crossover: null, trendStrength: 'weak' }\n    };\n  }\n\n  const latest = valid[valid.length - 1];\n  const prev = valid[valid.length - 2];\n\n  let crossover = null;\n  const prevRel = prev.diPlus - prev.diMinus;\n  const currRel = latest.diPlus - latest.diMinus;\n  if (prevRel <= 0 && currRel > 0) crossover = 'bullish_cross_up';\n  else if (prevRel >= 0 && currRel < 0) crossover = 'bearish_cross_down';\n\n  let trendStrength = 'weak';\n  if (latest.adx >= 50) trendStrength = 'very_strong';\n  else if (latest.adx >= 25) trendStrength = 'moderate';\n\n  return {\n    status: 'ok',\n    reason: null,\n    series,\n    summary: { latest, crossover, trendStrength }\n  };\n}\n\n/**\n * NEW: price structure output so AI can compute trigger/invalidation/target\n * Requires only candles (o/h/l/c).\n *\n * Returns:\n * - last_close, last_high, last_low\n * - swing_high_n, swing_low_n (+ timestamps)\n * - atr_n_sma (SMA of True Range), true_range_avg_n\n */\nfunction computePriceStructure(candles, swingN, atrN) {\n  const n = Array.isArray(candles) ? candles.length : 0;\n  if (!n) {\n    return {\n      last_close: null, last_high: null, last_low: null,\n      swing_n: swingN,\n      swing_high_n: null, swing_high_time: null,\n      swing_low_n: null, swing_low_time: null,\n      atr_n: atrN,\n      atr_n_sma: null,\n      true_range_avg_n: null,\n      swing_effective_n: 0,\n      atr_effective_n: 0,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[n - 1];\n\n  // --- Swing levels over last N bars ---\n  const win = Math.min(swingN, n);\n  let swingHigh = -Infinity, swingLow = Infinity;\n  let swingHighTime = null, swingLowTime = null;\n\n  for (let i = n - win; i < n; i++) {\n    const c = candles[i];\n    if (c?.h != null && c.h >= swingHigh) { swingHigh = c.h; swingHighTime = c.t; }\n    if (c?.l != null && c.l <= swingLow)  { swingLow  = c.l; swingLowTime  = c.t; }\n  }\n\n  if (!Number.isFinite(swingHigh)) { swingHigh = null; swingHighTime = null; }\n  if (!Number.isFinite(swingLow))  { swingLow  = null; swingLowTime  = null; }\n\n  // --- True Range series ---\n  const trs = [];\n  for (let i = 1; i < n; i++) {\n    const cur = candles[i];\n    const prev = candles[i - 1];\n    if (cur?.h == null || cur?.l == null || prev?.c == null) continue;\n\n    const hl = cur.h - cur.l;\n    const hc = Math.abs(cur.h - prev.c);\n    const lc = Math.abs(cur.l - prev.c);\n    const tr = Math.max(hl, hc, lc);\n\n    if (Number.isFinite(tr)) trs.push(tr);\n  }\n\n  // --- ATR as SMA(TR, atrN) ---\n  const atrWin = Math.min(atrN, trs.length);\n  let atrSma = null;\n  let trAvg = null;\n\n  if (atrWin > 0) {\n    const slice = trs.slice(trs.length - atrWin);\n    const sum = slice.reduce((a, b) => a + b, 0);\n    trAvg = sum / atrWin;\n    atrSma = trAvg;\n  }\n\n  return {\n    last_close: last?.c ?? null,\n    last_high: last?.h ?? null,\n    last_low: last?.l ?? null,\n\n    swing_n: swingN,\n    swing_high_n: swingHigh,\n    swing_high_time: swingHighTime,\n    swing_low_n: swingLow,\n    swing_low_time: swingLowTime,\n\n    atr_n: atrN,\n    atr_n_sma: atrSma,\n    true_range_avg_n: trAvg,\n\n    swing_effective_n: win,\n    atr_effective_n: atrWin,\n    reason: null\n  };\n}\n\n\n\n// ---- NEW: Hammer candlestick detection (last candle) ----\n// Notes:\n// - A \"hammer\" typically has a small real body near the top of the range and a long lower wick.\n// - This function only detects the candle geometry (no trend context).\n// - If close < open, the same geometry is often called a \"hanging man\".\nfunction computeHammer(candles) {\n  if (!Array.isArray(candles) || candles.length === 0) {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[candles.length - 1] || {};\n  const o = Number(last.o);\n  const h = Number(last.h);\n  const l = Number(last.l);\n  const c = Number(last.c);\n\n  if (![o,h,l,c].every(Number.isFinite)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Non-finite OHLC'\n    };\n  }\n\n  const range = h - l;\n  if (!(range > 0)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Invalid range'\n    };\n  }\n\n  const body = Math.abs(c - o);\n  const upper = h - Math.max(o, c);\n  const lower = Math.min(o, c) - l;\n\n  const bodyPct = body / range;\n  const upperPct = upper / range;\n  const lowerPct = lower / range;\n\n  // Tunables: keep conservative defaults\n  const smallBody = bodyPct <= 0.35;\n  const longLower = lower >= 2 * body;\n  const smallUpper = upper <= 0.75 * body; // allow tiny upper wick\n\n  const present = !!(smallBody && longLower && smallUpper);\n  const type = present\n    ? (c >= o ? 'hammer' : 'hanging_man')\n    : null;\n\n  return {\n    present,\n    type,\n    candleTime: last.t ?? null,\n    bodyPct: Number.isFinite(bodyPct) ? bodyPct : null,\n    lowerWickPct: Number.isFinite(lowerPct) ? lowerPct : null,\n    upperWickPct: Number.isFinite(upperPct) ? upperPct : null,\n    reason: present ? null : 'Candle geometry did not meet hammer thresholds'\n  };\n}\n// ---- NEW: Shooting Star / Inverted Hammer detection (last candle) ----\n// Notes:\n// - Geometry-only detection (no trend context).\n// - Shooting star / inverted hammer: small real body with long upper wick and small lower wick.\n// - Type mapping by candle color:\n//   * close >= open => 'inverted_hammer' (often bullish context)\n//   * close < open  => 'shooting_star'   (often bearish context)\nfunction computeShootingStar(candles) {\n  if (!Array.isArray(candles) || candles.length === 0) {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[candles.length - 1] || {};\n  const o = Number(last.o);\n  const h = Number(last.h);\n  const l = Number(last.l);\n  const c = Number(last.c);\n\n  if (![o,h,l,c].every(Number.isFinite)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Non-finite OHLC'\n    };\n  }\n\n  const range = h - l;\n  if (!(range > 0)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Zero/negative range'\n    };\n  }\n\n  const body = Math.abs(c - o);\n  const upper = h - Math.max(o, c);\n  const lower = Math.min(o, c) - l;\n\n  const bodyPct = body / range;\n  const upperPct = upper / range;\n  const lowerPct = lower / range;\n\n  const smallBody = bodyPct <= 0.35;\n  const longUpper = upper >= 2 * body;\n  const smallLower = lower <= 0.75 * body; // allow tiny lower wick\n\n  const present = !!(smallBody && longUpper && smallLower);\n  const type = present\n    ? (c >= o ? 'inverted_hammer' : 'shooting_star')\n    : null;\n\n  return {\n    present,\n    type,\n    candleTime: last.t ?? null,\n    bodyPct: Number.isFinite(bodyPct) ? bodyPct : null,\n    lowerWickPct: Number.isFinite(lowerPct) ? lowerPct : null,\n    upperWickPct: Number.isFinite(upperPct) ? upperPct : null,\n    reason: present ? null : 'Candle geometry did not meet shooting star thresholds'\n  };\n}\n\n\n\n\n\n// ---- NEW: Bullish Engulfing detection (last 2 candles) ----\n// Notes:\n// - Bullish engulfing: prior candle bearish (close<open), current candle bullish (close>open),\n//   and current real body engulfs prior real body (curr.open <= prev.close && curr.close >= prev.open).\n// - Geometry-only detection (no trend context).\nfunction computeBullishEngulfing(candles) {\n  if (!Array.isArray(candles) || candles.length < 2) {\n    return { present: false, type: null, candleTime: null, prevTime: null, reason: 'Need at least 2 candles' };\n  }\n\n  const prev = candles[candles.length - 2] || {};\n  const curr = candles[candles.length - 1] || {};\n\n  const po = Number(prev.o); const pc = Number(prev.c);\n  const co = Number(curr.o); const cc = Number(curr.c);\n\n  if (![po, pc, co, cc].every(Number.isFinite)) {\n    return { present: false, type: null, candleTime: curr.t ?? null, prevTime: prev.t ?? null, reason: 'Non-finite OHLC' };\n  }\n\n  const prevBear = pc < po;\n  const currBull = cc > co;\n\n  const prevBody = Math.abs(pc - po);\n  const currBody = Math.abs(cc - co);\n\n  const engulfsBody = (co <= pc) && (cc >= po);\n  const biggerBody = currBody >= prevBody; // mild filter\n\n  const present = !!(prevBear && currBull && engulfsBody && biggerBody);\n\n  return {\n    present,\n    type: present ? 'bullish_engulfing' : null,\n    candleTime: curr.t ?? null,\n    prevTime: prev.t ?? null,\n    prevBody: Number.isFinite(prevBody) ? prevBody : null,\n    currBody: Number.isFinite(currBody) ? currBody : null,\n    reason: present ? null : 'Candle geometry did not meet bullish engulfing thresholds'\n  };\n}\n\n\n// ---- NEW: Bearish Engulfing detection (last 2 candles) ----\n// Notes:\n// - Bearish engulfing: prior candle bullish (close>open), current candle bearish (close<open),\n//   and current real body engulfs prior real body (curr.open >= prev.close && curr.close <= prev.open).\n// - Geometry-only detection (no trend context).\nfunction computeBearishEngulfing(candles) {\n  if (!Array.isArray(candles) || candles.length < 2) {\n    return { present: false, type: null, candleTime: null, prevTime: null, reason: 'Need at least 2 candles' };\n  }\n\n  const prev = candles[candles.length - 2] || {};\n  const curr = candles[candles.length - 1] || {};\n\n  const po = Number(prev.o); const pc = Number(prev.c);\n  const co = Number(curr.o); const cc = Number(curr.c);\n\n  if (![po, pc, co, cc].every(Number.isFinite)) {\n    return { present: false, type: null, candleTime: curr.t ?? null, prevTime: prev.t ?? null, reason: 'Non-finite OHLC' };\n  }\n\n  const prevBull = pc > po;\n  const currBear = cc < co;\n\n  const prevBody = Math.abs(pc - po);\n  const currBody = Math.abs(cc - co);\n\n  const engulfsBody = (co >= pc) && (cc <= po);\n  const biggerBody = currBody >= prevBody; // mild filter\n\n  const present = !!(prevBull && currBear && engulfsBody && biggerBody);\n\n  return {\n    present,\n    type: present ? 'bearish_engulfing' : null,\n    candleTime: curr.t ?? null,\n    prevTime: prev.t ?? null,\n    prevBody: Number.isFinite(prevBody) ? prevBody : null,\n    currBody: Number.isFinite(currBody) ? currBody : null,\n    reason: present ? null : 'Candle geometry did not meet bearish engulfing thresholds'\n  };\n}\n\n\n// ---- main ----\nconst j = items[0].json;\n\nconst ticker = j.ticker || null;\nconst tf = j.tf || null;\nconst candles = Array.isArray(j.candles) ? j.candles : [];\nconst tdSummary = j.tdSummary || null;\n\nconst dmiOut = computeDMI(candles, DMI_PERIOD);\n\n// NEW: compute price structure regardless of DMI status\nconst price = computePriceStructure(candles, SWING_N, ATR_N);\n\n\n\n// NEW: candlestick pattern\nconst hammer = computeHammer(candles);\nconst shooting_star = computeShootingStar(candles);\nconst bullish_engulfing = computeBullishEngulfing(candles);\nconst bearish_engulfing = computeBearishEngulfing(candles);\nreturn [{\n  json: {\n    ticker,\n    tf,\n\n    // DMI output (unchanged)\n    status: dmiOut.status,\n    reason: dmiOut.reason,\n    diPlus: dmiOut.summary.latest ? dmiOut.summary.latest.diPlus : null,\n    diMinus: dmiOut.summary.latest ? dmiOut.summary.latest.diMinus : null,\n    adx: dmiOut.summary.latest ? dmiOut.summary.latest.adx : null,\n    dmiSummary: dmiOut.summary,\n    dmiSeries: Array.isArray(dmiOut.series) ? dmiOut.series.slice(-20) : [],\n\n    // TD Sequential summary (unchanged)\n    demark: tdSummary,\n\n    // NEW: price structure for trigger / invalidation / target\n    price,\n\n    // NEW: candlestick pattern(s)\n    hammer,\n    shooting_star,\n    bullish_engulfing\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        30272,
        33792
      ],
      "id": "4053c4b2-cfa3-4898-a7f2-a07799a0e504",
      "name": "Code in JavaScript4"
    },
    {
      "parameters": {
        "jsCode": "// ===== CONFIG =====\nconst DMI_PERIOD = 14;\n\n// Minimal price structure additions (for trigger/invalidation/target)\nconst SWING_N = 20;   // swing_high_N / swing_low_N lookback\nconst ATR_N   = 14;   // ATR lookback (SMA of True Range)\n// ==================\n\nfunction computeDMI(candles, period) {\n  if (!candles || candles.length <= period + 2) {\n    return {\n      status: 'insufficient_data',\n      reason: 'Not enough candles for DMI',\n      series: [],\n      summary: { latest: null, crossover: null, trendStrength: 'weak' }\n    };\n  }\n\n  // candles assumed sorted ascending\n  const plusDM = [];\n  const minusDM = [];\n  const tr = [];\n\n  for (let i = 1; i < candles.length; i++) {\n    const curr = candles[i];\n    const prev = candles[i - 1];\n\n    const upMove = curr.h - prev.h;\n    const downMove = prev.l - curr.l;\n\n    let plus = 0, minus = 0;\n    if (upMove > downMove && upMove > 0) plus = upMove;\n    if (downMove > upMove && downMove > 0) minus = downMove;\n\n    plusDM.push(plus);\n    minusDM.push(minus);\n\n    const tr1 = curr.h - curr.l;\n    const tr2 = Math.abs(curr.h - prev.c);\n    const tr3 = Math.abs(curr.l - prev.c);\n    tr.push(Math.max(tr1, tr2, tr3));\n  }\n\n  const smooth = (values) => {\n    const out = new Array(values.length).fill(null);\n    let sum = 0;\n    for (let i = 0; i < period; i++) sum += values[i];\n    out[period - 1] = sum;\n    for (let i = period; i < values.length; i++) {\n      const prev = out[i - 1];\n      out[i] = prev - prev / period + values[i];\n    }\n    return out;\n  };\n\n  const plusDMs = smooth(plusDM);\n  const minusDMs = smooth(minusDM);\n  const trs = smooth(tr);\n\n  const diPlusArr = [];\n  const diMinusArr = [];\n  const dxArr = [];\n\n  for (let i = 0; i < plusDM.length; i++) {\n    if (i < period - 1 || trs[i] === null) {\n      diPlusArr.push(null);\n      diMinusArr.push(null);\n      dxArr.push(null);\n      continue;\n    }\n\n    const p = plusDMs[i];\n    const m = minusDMs[i];\n    const t = trs[i];\n\n    const diPlus = t === 0 ? 0 : (p / t) * 100;\n    const diMinus = t === 0 ? 0 : (m / t) * 100;\n\n    diPlusArr.push(diPlus);\n    diMinusArr.push(diMinus);\n\n    const denom = diPlus + diMinus;\n    const dx = denom === 0 ? 0 : (Math.abs(diPlus - diMinus) / denom) * 100;\n    dxArr.push(dx);\n  }\n\n  // ADX\n  const adxArr = new Array(dxArr.length).fill(null);\n  let adx = null;\n\n  const firstDX = dxArr.findIndex(v => v !== null);\n  if (firstDX !== -1 && firstDX + period <= dxArr.length) {\n    let sumDX = 0;\n    for (let i = firstDX; i < firstDX + period; i++) sumDX += dxArr[i];\n    adx = sumDX / period;\n    adxArr[firstDX + period - 1] = adx;\n\n    for (let i = firstDX + period; i < dxArr.length; i++) {\n      adx = ((adx * (period - 1)) + dxArr[i]) / period;\n      adxArr[i] = adx;\n    }\n  }\n\n  const series = [];\n  for (let i = 0; i < dxArr.length; i++) {\n    series.push({\n      t: candles[i + 1].t,\n      diPlus: diPlusArr[i],\n      diMinus: diMinusArr[i],\n      adx: adxArr[i]\n    });\n  }\n\n  const valid = series.filter(p => p.diPlus !== null && p.adx !== null);\n  if (valid.length < 2) {\n    return {\n      status: 'partial',\n      reason: 'DMI computed but ADX not stable yet',\n      series,\n      summary: { latest: valid.length ? valid[valid.length - 1] : null, crossover: null, trendStrength: 'weak' }\n    };\n  }\n\n  const latest = valid[valid.length - 1];\n  const prev = valid[valid.length - 2];\n\n  let crossover = null;\n  const prevRel = prev.diPlus - prev.diMinus;\n  const currRel = latest.diPlus - latest.diMinus;\n  if (prevRel <= 0 && currRel > 0) crossover = 'bullish_cross_up';\n  else if (prevRel >= 0 && currRel < 0) crossover = 'bearish_cross_down';\n\n  let trendStrength = 'weak';\n  if (latest.adx >= 50) trendStrength = 'very_strong';\n  else if (latest.adx >= 25) trendStrength = 'moderate';\n\n  return {\n    status: 'ok',\n    reason: null,\n    series,\n    summary: { latest, crossover, trendStrength }\n  };\n}\n\n/**\n * NEW: price structure output so AI can compute trigger/invalidation/target\n * Requires only candles (o/h/l/c).\n *\n * Returns:\n * - last_close, last_high, last_low\n * - swing_high_n, swing_low_n (+ timestamps)\n * - atr_n_sma (SMA of True Range), true_range_avg_n\n */\nfunction computePriceStructure(candles, swingN, atrN) {\n  const n = Array.isArray(candles) ? candles.length : 0;\n  if (!n) {\n    return {\n      last_close: null, last_high: null, last_low: null,\n      swing_n: swingN,\n      swing_high_n: null, swing_high_time: null,\n      swing_low_n: null, swing_low_time: null,\n      atr_n: atrN,\n      atr_n_sma: null,\n      true_range_avg_n: null,\n      swing_effective_n: 0,\n      atr_effective_n: 0,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[n - 1];\n\n  // --- Swing levels over last N bars ---\n  const win = Math.min(swingN, n);\n  let swingHigh = -Infinity, swingLow = Infinity;\n  let swingHighTime = null, swingLowTime = null;\n\n  for (let i = n - win; i < n; i++) {\n    const c = candles[i];\n    if (c?.h != null && c.h >= swingHigh) { swingHigh = c.h; swingHighTime = c.t; }\n    if (c?.l != null && c.l <= swingLow)  { swingLow  = c.l; swingLowTime  = c.t; }\n  }\n\n  if (!Number.isFinite(swingHigh)) { swingHigh = null; swingHighTime = null; }\n  if (!Number.isFinite(swingLow))  { swingLow  = null; swingLowTime  = null; }\n\n  // --- True Range series ---\n  const trs = [];\n  for (let i = 1; i < n; i++) {\n    const cur = candles[i];\n    const prev = candles[i - 1];\n    if (cur?.h == null || cur?.l == null || prev?.c == null) continue;\n\n    const hl = cur.h - cur.l;\n    const hc = Math.abs(cur.h - prev.c);\n    const lc = Math.abs(cur.l - prev.c);\n    const tr = Math.max(hl, hc, lc);\n\n    if (Number.isFinite(tr)) trs.push(tr);\n  }\n\n  // --- ATR as SMA(TR, atrN) ---\n  const atrWin = Math.min(atrN, trs.length);\n  let atrSma = null;\n  let trAvg = null;\n\n  if (atrWin > 0) {\n    const slice = trs.slice(trs.length - atrWin);\n    const sum = slice.reduce((a, b) => a + b, 0);\n    trAvg = sum / atrWin;\n    atrSma = trAvg;\n  }\n\n  return {\n    last_close: last?.c ?? null,\n    last_high: last?.h ?? null,\n    last_low: last?.l ?? null,\n\n    swing_n: swingN,\n    swing_high_n: swingHigh,\n    swing_high_time: swingHighTime,\n    swing_low_n: swingLow,\n    swing_low_time: swingLowTime,\n\n    atr_n: atrN,\n    atr_n_sma: atrSma,\n    true_range_avg_n: trAvg,\n\n    swing_effective_n: win,\n    atr_effective_n: atrWin,\n    reason: null\n  };\n}\n\n\n\n// ---- NEW: Hammer candlestick detection (last candle) ----\n// Notes:\n// - A \"hammer\" typically has a small real body near the top of the range and a long lower wick.\n// - This function only detects the candle geometry (no trend context).\n// - If close < open, the same geometry is often called a \"hanging man\".\nfunction computeHammer(candles) {\n  if (!Array.isArray(candles) || candles.length === 0) {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[candles.length - 1] || {};\n  const o = Number(last.o);\n  const h = Number(last.h);\n  const l = Number(last.l);\n  const c = Number(last.c);\n\n  if (![o,h,l,c].every(Number.isFinite)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Non-finite OHLC'\n    };\n  }\n\n  const range = h - l;\n  if (!(range > 0)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Invalid range'\n    };\n  }\n\n  const body = Math.abs(c - o);\n  const upper = h - Math.max(o, c);\n  const lower = Math.min(o, c) - l;\n\n  const bodyPct = body / range;\n  const upperPct = upper / range;\n  const lowerPct = lower / range;\n\n  // Tunables: keep conservative defaults\n  const smallBody = bodyPct <= 0.35;\n  const longLower = lower >= 2 * body;\n  const smallUpper = upper <= 0.75 * body; // allow tiny upper wick\n\n  const present = !!(smallBody && longLower && smallUpper);\n  const type = present\n    ? (c >= o ? 'hammer' : 'hanging_man')\n    : null;\n\n  return {\n    present,\n    type,\n    candleTime: last.t ?? null,\n    bodyPct: Number.isFinite(bodyPct) ? bodyPct : null,\n    lowerWickPct: Number.isFinite(lowerPct) ? lowerPct : null,\n    upperWickPct: Number.isFinite(upperPct) ? upperPct : null,\n    reason: present ? null : 'Candle geometry did not meet hammer thresholds'\n  };\n}\n// ---- NEW: Shooting Star / Inverted Hammer detection (last candle) ----\n// Notes:\n// - Geometry-only detection (no trend context).\n// - Shooting star / inverted hammer: small real body with long upper wick and small lower wick.\n// - Type mapping by candle color:\n//   * close >= open => 'inverted_hammer' (often bullish context)\n//   * close < open  => 'shooting_star'   (often bearish context)\nfunction computeShootingStar(candles) {\n  if (!Array.isArray(candles) || candles.length === 0) {\n    return {\n      present: false,\n      type: null,\n      candleTime: null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'No candles'\n    };\n  }\n\n  const last = candles[candles.length - 1] || {};\n  const o = Number(last.o);\n  const h = Number(last.h);\n  const l = Number(last.l);\n  const c = Number(last.c);\n\n  if (![o,h,l,c].every(Number.isFinite)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Non-finite OHLC'\n    };\n  }\n\n  const range = h - l;\n  if (!(range > 0)) {\n    return {\n      present: false,\n      type: null,\n      candleTime: last.t ?? null,\n      bodyPct: null,\n      lowerWickPct: null,\n      upperWickPct: null,\n      reason: 'Zero/negative range'\n    };\n  }\n\n  const body = Math.abs(c - o);\n  const upper = h - Math.max(o, c);\n  const lower = Math.min(o, c) - l;\n\n  const bodyPct = body / range;\n  const upperPct = upper / range;\n  const lowerPct = lower / range;\n\n  const smallBody = bodyPct <= 0.35;\n  const longUpper = upper >= 2 * body;\n  const smallLower = lower <= 0.75 * body; // allow tiny lower wick\n\n  const present = !!(smallBody && longUpper && smallLower);\n  const type = present\n    ? (c >= o ? 'inverted_hammer' : 'shooting_star')\n    : null;\n\n  return {\n    present,\n    type,\n    candleTime: last.t ?? null,\n    bodyPct: Number.isFinite(bodyPct) ? bodyPct : null,\n    lowerWickPct: Number.isFinite(lowerPct) ? lowerPct : null,\n    upperWickPct: Number.isFinite(upperPct) ? upperPct : null,\n    reason: present ? null : 'Candle geometry did not meet shooting star thresholds'\n  };\n}\n\n\n\n\n\n// ---- NEW: Bullish Engulfing detection (last 2 candles) ----\n// Notes:\n// - Bullish engulfing: prior candle bearish (close<open), current candle bullish (close>open),\n//   and current real body engulfs prior real body (curr.open <= prev.close && curr.close >= prev.open).\n// - Geometry-only detection (no trend context).\nfunction computeBullishEngulfing(candles) {\n  if (!Array.isArray(candles) || candles.length < 2) {\n    return { present: false, type: null, candleTime: null, prevTime: null, reason: 'Need at least 2 candles' };\n  }\n\n  const prev = candles[candles.length - 2] || {};\n  const curr = candles[candles.length - 1] || {};\n\n  const po = Number(prev.o); const pc = Number(prev.c);\n  const co = Number(curr.o); const cc = Number(curr.c);\n\n  if (![po, pc, co, cc].every(Number.isFinite)) {\n    return { present: false, type: null, candleTime: curr.t ?? null, prevTime: prev.t ?? null, reason: 'Non-finite OHLC' };\n  }\n\n  const prevBear = pc < po;\n  const currBull = cc > co;\n\n  const prevBody = Math.abs(pc - po);\n  const currBody = Math.abs(cc - co);\n\n  const engulfsBody = (co <= pc) && (cc >= po);\n  const biggerBody = currBody >= prevBody; // mild filter\n\n  const present = !!(prevBear && currBull && engulfsBody && biggerBody);\n\n  return {\n    present,\n    type: present ? 'bullish_engulfing' : null,\n    candleTime: curr.t ?? null,\n    prevTime: prev.t ?? null,\n    prevBody: Number.isFinite(prevBody) ? prevBody : null,\n    currBody: Number.isFinite(currBody) ? currBody : null,\n    reason: present ? null : 'Candle geometry did not meet bullish engulfing thresholds'\n  };\n}\n\n\n// ---- NEW: Bearish Engulfing detection (last 2 candles) ----\n// Notes:\n// - Bearish engulfing: prior candle bullish (close>open), current candle bearish (close<open),\n//   and current real body engulfs prior real body (curr.open >= prev.close && curr.close <= prev.open).\n// - Geometry-only detection (no trend context).\nfunction computeBearishEngulfing(candles) {\n  if (!Array.isArray(candles) || candles.length < 2) {\n    return { present: false, type: null, candleTime: null, prevTime: null, reason: 'Need at least 2 candles' };\n  }\n\n  const prev = candles[candles.length - 2] || {};\n  const curr = candles[candles.length - 1] || {};\n\n  const po = Number(prev.o); const pc = Number(prev.c);\n  const co = Number(curr.o); const cc = Number(curr.c);\n\n  if (![po, pc, co, cc].every(Number.isFinite)) {\n    return { present: false, type: null, candleTime: curr.t ?? null, prevTime: prev.t ?? null, reason: 'Non-finite OHLC' };\n  }\n\n  const prevBull = pc > po;\n  const currBear = cc < co;\n\n  const prevBody = Math.abs(pc - po);\n  const currBody = Math.abs(cc - co);\n\n  const engulfsBody = (co >= pc) && (cc <= po);\n  const biggerBody = currBody >= prevBody; // mild filter\n\n  const present = !!(prevBull && currBear && engulfsBody && biggerBody);\n\n  return {\n    present,\n    type: present ? 'bearish_engulfing' : null,\n    candleTime: curr.t ?? null,\n    prevTime: prev.t ?? null,\n    prevBody: Number.isFinite(prevBody) ? prevBody : null,\n    currBody: Number.isFinite(currBody) ? currBody : null,\n    reason: present ? null : 'Candle geometry did not meet bearish engulfing thresholds'\n  };\n}\n\n\n// ---- main ----\nconst j = items[0].json;\n\nconst ticker = j.ticker || null;\nconst tf = j.tf || null;\nconst candles = Array.isArray(j.candles) ? j.candles : [];\nconst tdSummary = j.tdSummary || null;\n\nconst dmiOut = computeDMI(candles, DMI_PERIOD);\n\n// NEW: compute price structure regardless of DMI status\nconst price = computePriceStructure(candles, SWING_N, ATR_N);\n\n\n\n// NEW: candlestick pattern\nconst hammer = computeHammer(candles);\nconst shooting_star = computeShootingStar(candles);\nconst bullish_engulfing = computeBullishEngulfing(candles);\nconst bearish_engulfing = computeBearishEngulfing(candles);\nreturn [{\n  json: {\n    ticker,\n    tf,\n\n    // DMI output (unchanged)\n    status: dmiOut.status,\n    reason: dmiOut.reason,\n    diPlus: dmiOut.summary.latest ? dmiOut.summary.latest.diPlus : null,\n    diMinus: dmiOut.summary.latest ? dmiOut.summary.latest.diMinus : null,\n    adx: dmiOut.summary.latest ? dmiOut.summary.latest.adx : null,\n    dmiSummary: dmiOut.summary,\n    dmiSeries: Array.isArray(dmiOut.series) ? dmiOut.series.slice(-20) : [],\n\n    // TD Sequential summary (unchanged)\n    demark: tdSummary,\n\n    // NEW: price structure for trigger / invalidation / target\n    price,\n\n    // NEW: candlestick pattern(s)\n    hammer,\n    shooting_star,\n    bullish_engulfing\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        30272,
        34000
      ],
      "id": "91261250-c273-46fc-8e8b-c2fba052ccd1",
      "name": "Code in JavaScript5"
    },
    {
      "parameters": {
        "url": "https://paper-api.alpaca.markets/v2/clock",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        28096,
        34160
      ],
      "id": "bf0344d9-56d5-400c-9551-0c0520aa54f0",
      "name": "Clock1"
    },
    {
      "parameters": {
        "jsCode": "const clock = $json;\n\n// Alpaca clock fields: timestamp, is_open, next_open, next_close\nif (typeof clock?.is_open !== 'boolean') {\n  throw new Error('Clock response missing boolean is_open');\n}\n\nreturn [{\n  json: {\n    is_open: clock.is_open,\n    timestamp: clock.timestamp ?? null,\n    next_open: clock.next_open ?? null,\n    next_close: clock.next_close ?? null,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        28304,
        34160
      ],
      "id": "a237d67f-9c55-4a9e-9e3b-844502a8dff3",
      "name": "Code in JavaScript6"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "a5eefb32-3a0f-4bbf-832f-487f623b0d62",
              "leftValue": "={{ ($json.is_open ?? '').toString().trim().toLowerCase()}}\n",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": "={{ true }}",
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        28528,
        34160
      ],
      "id": "5f99ace6-5949-4b29-bec3-7aadddd14f9f",
      "name": "If2"
    },
    {
      "parameters": {
        "updates": [
          "message"
        ],
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.2,
      "position": [
        28544,
        33792
      ],
      "id": "6044e2c7-44c4-4a82-9b59-74cf266ea205",
      "name": "Telegram Trigger",
      "webhookId": "b5091405-b721-4026-bfa8-eabc14acf0ad",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: Parse Order Payload\n// MODE: Run Once for Each Item\n//\n// PURPOSE:\n// - Build Alpaca order payload for OPTIONS only (BUY_CALL / BUY_PUT).\n// - Uses the OCC option symbol and option premium for limit entry.\n// - Alpaca options orders: simple order_class, position_intent=buy_to_open,\n//   type=limit|market, time_in_force=day. NO bracket orders for options.\n//\n// OUTPUT:\n// { json: { ...plan, order_payload, order_meta } }\n//\n// IMPORTANT:\n// - This node only PREPARES payload. The HTTP Request node posts it to Alpaca /v2/orders.\n// - It does NOT place any order by itself.\n\nfunction safeNum(x) {\n  if (typeof x === \"number\" && Number.isFinite(x)) return x;\n  if (typeof x === \"string\") {\n    const n = Number.parseFloat(x.trim());\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\nfunction upperSymbol(x) {\n  if (typeof x !== \"string\") return null;\n  const s = x.trim().toUpperCase();\n  return s.length ? s : null;\n}\n\nfunction clampQty(q) {\n  const n = safeNum(q);\n  if (n == null) return 0;\n  return Math.max(0, Math.floor(n));\n}\n\nfunction roundToTick(price, tick) {\n  const p = safeNum(price);\n  const t = safeNum(tick);\n  if (p == null) return null;\n  if (t == null || t <= 0) return p;\n  return Math.round(p / t) * t;\n}\n\nfunction pickFirstNonNull(...vals) {\n  for (const v of vals) {\n    if (v !== undefined && v !== null) return v;\n  }\n  return null;\n}\n\n// -------------------- main --------------------\nconst plan = ($json && typeof $json === \"object\") ? $json : {};\n\nconst decisionRaw = String(plan.option_decision || plan.decision || \"\").toUpperCase();\nconst isOptionBuy = decisionRaw.startsWith(\"BUY_CALL\") || decisionRaw.startsWith(\"BUY_PUT\");\n\n// This workflow only handles option orders\nif (!isOptionBuy) {\n  return {\n    json: {\n      ...plan,\n      order_payload: null,\n      order_meta: {\n        ok: false,\n        reason: `Not an option buy decision (got: ${decisionRaw}). This workflow only submits option orders.`,\n        isOptionBuy: false,\n      }\n    }\n  };\n}\n\n// Side / Right (for metadata only)\nconst desiredRight = (plan.desired_option_right || plan.option_right || plan.option_intent?.right || null);\n\n// Qty (should already be computed by your Compute Size node)\nconst qty = clampQty(plan.qty);\n\n// Basic guardrails\nif (decisionRaw === \"WAIT\" || qty === 0) {\n  return {\n    json: {\n      ...plan,\n      order_payload: null,\n      order_meta: {\n        ok: false,\n        reason: decisionRaw === \"WAIT\" ? \"Decision=WAIT\" : \"qty=0\",\n        isOptionBuy,\n      }\n    }\n  };\n}\n\n// Tick size for options premium (usually $0.01)\nconst OPT_TICK = 0.01;\n\n// Options on Alpaca only support time_in_force = \"day\"\nconst tif = \"day\";\n\n// Order type: Alpaca options only support \"limit\" or \"market\"\nconst entryTypeRaw = (plan.entry_type || \"limit\").toString().toLowerCase();\nlet entryType = (entryTypeRaw === \"market\" || entryTypeRaw === \"limit\") ? entryTypeRaw : \"limit\";\n\n// -------- Option symbol & entry price --------\nconst symbol = upperSymbol(\n  plan.option_contract_symbol ??\n  plan.optionContext?.contract?.symbol ??\n  plan.selected_option?.contract_symbol ??\n  plan.selected_option?.symbol ??\n  plan.selected_contract?.symbol\n);\n\nlet entry = pickFirstNonNull(\n  safeNum(plan.option_entry_premium),\n  safeNum(plan.optionContext?.quote?.ask),\n  safeNum(plan.option_ask),\n  safeNum(plan.optionContext?.quote?.mid),\n  safeNum(plan.option_mid)\n);\n\nconst stopLoss = roundToTick(\n  pickFirstNonNull(safeNum(plan.option_stop_premium)),\n  OPT_TICK\n);\n\nconst takeProfit = roundToTick(\n  pickFirstNonNull(safeNum(plan.option_take_profit_premium), safeNum(plan.option_tp_premium)),\n  OPT_TICK\n);\n\n// Round entry to option tick\nentry = roundToTick(entry, OPT_TICK);\n\n// Validate symbol\nif (!symbol) {\n  return {\n    json: {\n      ...plan,\n      order_payload: null,\n      order_meta: {\n        ok: false,\n        reason: \"Missing option contract symbol (OCC symbol required)\",\n        isOptionBuy,\n      }\n    }\n  };\n}\n\n// If entry price is missing, fall back to market order instead of failing\nif (entry == null || entry <= 0) {\n  entryType = \"market\";\n}\n\n// -------- Build Alpaca OPTIONS order payload --------\n// Alpaca options orders:\n// - symbol: OCC option symbol (e.g. \"SPY250217C00600000\")\n// - side: \"buy\"\n// - type: \"limit\" or \"market\" (only these two for options)\n// - time_in_force: \"day\" (only \"day\" for options)\n// - order_class: \"simple\" (bracket NOT supported for options)\n// - position_intent: \"buy_to_open\" (opening a new long option position)\n// - qty: number of contracts\n// - limit_price: premium per share (for limit orders)\n\nconst order_payload = {\n  symbol,\n  qty: String(qty),\n  side: \"buy\",\n  type: entryType,\n  time_in_force: tif,\n  order_class: \"simple\",\n  position_intent: \"buy_to_open\",\n};\n\n// Set limit price for entry when using limit\nif (entryType === \"limit\") {\n  order_payload.limit_price = String(entry);\n}\n\nreturn {\n  json: {\n    ...plan,\n\n    // echo the final chosen values (handy for debugging)\n    resolved_trade: {\n      isOptionBuy: true,\n      decision: decisionRaw,\n      desiredRight,\n      symbol,\n      qty,\n      entry,\n      stopLoss,\n      takeProfit,\n      tick: OPT_TICK,\n      tif,\n      entryType,\n    },\n\n    order_payload,\n\n    order_meta: {\n      ok: true,\n      isOptionBuy: true,\n      decision: decisionRaw,\n      symbol,\n      qty,\n    },\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        36288,
        33840
      ],
      "id": "8c7826ce-88b6-4a35-8c41-db5907982ff7",
      "name": "Parse Order Payload"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "9dd1163e-0a3f-402a-ae7c-c9fe6c78f9f6",
              "leftValue": "={{ $node[\"Parse Order Payload\"].json.order_meta.ok }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        36512,
        33840
      ],
      "id": "2dc26ce0-8c68-4622-8281-ead02c632f32",
      "name": "If Order1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://paper-api.alpaca.markets/v2/orders",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{$json.order_payload }}",
        "options": {}
      },
      "onError": "continueRegularOutput",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        36784,
        33824
      ],
      "id": "685ff568-07b1-4776-94ec-321fa70dc600",
      "name": "Submit Order"
    },
    {
      "parameters": {
        "url": "https://paper-api.alpaca.markets/v2/account",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        35616,
        33840
      ],
      "id": "8f4099f1-16a6-43b2-b044-40da54abaa58",
      "name": "HTTP Account"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: Compute Size (with Conviction-Based Sizing)\n// MODE: Run Once for Each Item\n//\n// Options-only sizing with conviction multiplier:\n//   1. Base qty = floor(maxRiskUsd / riskPerContract)\n//   2. Conviction score (0\u201310) computed from alignment, confidence,\n//      ADX, R:R, spread, confirmation count, and TD Sequential phase.\n//   3. Tier: REGULAR (0\u20133), SIZABLE (4\u20136), MAX_CONVICTION (7+)\n//   4. effectiveRisk = maxRiskUsd * multiplier (1x / 2x / 3x)\n//   5. Hard cap: MAX_QTY_CAP (default 10) prevents oversizing.\n//\n// Env vars are OPTIONAL (safe-read). Falls back to input JSON.\n\nfunction safeNum(x) {\n  if (typeof x === \"number\" && Number.isFinite(x)) return x;\n  if (typeof x === \"string\") {\n    const n = Number.parseFloat(x);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\nfunction safeStr(x) {\n  if (x == null) return null;\n  const s = String(x).trim().toLowerCase();\n  return s || null;\n}\n\nfunction normalizePct(x) {\n  const n = safeNum(x);\n  if (n == null) return null;\n  if (n > 1) return n / 100;\n  return n;\n}\n\nfunction envNumSafe(name) {\n  return null;\n}\n\nfunction pickFirstNum(...vals) {\n  for (const v of vals) {\n    const n = safeNum(v);\n    if (n != null) return n;\n  }\n  return null;\n}\n\nfunction pickFirstStr(...vals) {\n  for (const v of vals) {\n    const s = safeStr(v);\n    if (s != null) return s;\n  }\n  return null;\n}\n\n// ============================================================\n// Conviction scoring: deterministic, based on upstream signals\n// ============================================================\nfunction computeConvictionScore(plan) {\n  let score = 0;\n  const details = [];\n\n  // 1. Alignment (+2 all_aligned, +1 htf_mtf_aligned)\n  const alignment = pickFirstStr(\n    plan.alignment_pre, plan.alignment,\n    plan.summary?.alignment\n  );\n  if (alignment === \"all_aligned\") {\n    score += 2;\n    details.push(\"alignment=all_aligned +2\");\n  } else if (alignment === \"htf_mtf_aligned\") {\n    score += 1;\n    details.push(\"alignment=htf_mtf_aligned +1\");\n  } else {\n    details.push(`alignment=${alignment ?? \"unknown\"} +0`);\n  }\n\n  // 2. Confidence (+2 if >=80%, +1 if >=70%)\n  let conf = safeNum(plan.confidence_pre) ?? safeNum(plan.confidence) ?? safeNum(plan.confidencePct);\n  // Normalize: if 0..1 range, convert to pct\n  if (conf != null && conf > 0 && conf <= 1) conf = conf * 100;\n  if (conf != null && conf >= 80) {\n    score += 2;\n    details.push(`confidence=${conf.toFixed(1)}% +2`);\n  } else if (conf != null && conf >= 70) {\n    score += 1;\n    details.push(`confidence=${conf.toFixed(1)}% +1`);\n  } else {\n    details.push(`confidence=${conf != null ? conf.toFixed(1) + \"%\" : \"n/a\"} +0`);\n  }\n\n  // 3. ADX confirmation (+1 if confirmed)\n  const adxConf = pickFirstStr(\n    plan.adx_confirmation_pre, plan.adx_confirmation\n  );\n  if (adxConf === \"confirmed\") {\n    score += 1;\n    details.push(\"adx_confirmation=confirmed +1\");\n  } else {\n    details.push(`adx_confirmation=${adxConf ?? \"n/a\"} +0`);\n  }\n\n  // 4. Trend strength score (+1 if strong: score >= 7 out of 10 or 70+)\n  let tss = safeNum(plan.trend_strength_score_pre) ?? safeNum(plan.trend_strength_score);\n  const tsStr = pickFirstStr(plan.trend_strength_pre, plan.trend_strength);\n  if (tsStr === \"strong\" || tsStr === \"very_strong\" || (tss != null && tss >= 7)) {\n    score += 1;\n    details.push(`trend_strength=${tsStr ?? tss} +1`);\n  } else {\n    details.push(`trend_strength=${tsStr ?? tss ?? \"n/a\"} +0`);\n  }\n\n  // 5. Option R:R (+1 if >= 2.0)\n  const rr = safeNum(plan.option_risk_reward);\n  if (rr != null && rr >= 2.0) {\n    score += 1;\n    details.push(`option_rr=${rr.toFixed(2)} +1`);\n  } else {\n    details.push(`option_rr=${rr != null ? rr.toFixed(2) : \"n/a\"} +0`);\n  }\n\n  // 6. Option spread tightness (+1 if spread < 0.5%)\n  const spread = safeNum(plan.option_spread_pct);\n  if (spread != null && spread < 0.005) {\n    score += 1;\n    details.push(`spread=${(spread * 100).toFixed(2)}% +1`);\n  } else {\n    details.push(`spread=${spread != null ? (spread * 100).toFixed(2) + \"%\" : \"n/a\"} +0`);\n  }\n\n  // 7. Confirmation count (+1 if >= 3 consecutive confirms)\n  const confirms = safeNum(\n    plan.confirmation_count ??\n    plan._orchestration_result?.confirmation_count ??\n    plan.signal_summary?.consecutive_confirms\n  );\n  if (confirms != null && confirms >= 3) {\n    score += 1;\n    details.push(`consecutive_confirms=${confirms} +1`);\n  } else {\n    details.push(`consecutive_confirms=${confirms ?? \"n/a\"} +0`);\n  }\n\n  // 8. TD Sequential phase (+1 if early setup: count 1\u20134)\n  //    TD data lives in plan.timeframes[tf].demark or plan.demark_snapshot\n  let tdEarly = false;\n  const tfs = plan.timeframes;\n  if (tfs && typeof tfs === \"object\") {\n    for (const tf of Object.keys(tfs)) {\n      const dm = tfs[tf]?.demark;\n      if (dm && typeof dm === \"object\") {\n        const count = safeNum(dm.count) ?? safeNum(dm.td_count) ?? safeNum(dm.setup_count);\n        if (count != null && count >= 1 && count <= 4) {\n          tdEarly = true;\n          break;\n        }\n      }\n    }\n  }\n  if (tdEarly) {\n    score += 1;\n    details.push(\"td_sequential=early_setup(1-4) +1\");\n  } else {\n    details.push(\"td_sequential=not_early +0\");\n  }\n\n  // Determine tier and multiplier\n  let tier = \"REGULAR\";\n  let multiplier = 1.0;\n  if (score >= 7) {\n    tier = \"MAX_CONVICTION\";\n    multiplier = 3.0;\n  } else if (score >= 4) {\n    tier = \"SIZABLE\";\n    multiplier = 2.0;\n  }\n\n  return { score, tier, multiplier, details };\n}\n\n// ============================================================\n// Main sizing logic\n// ============================================================\nconst plan = ($json && typeof $json === \"object\") ? $json : {};\nconst decision = String(plan.option_decision || plan.decision || \"\").toUpperCase();\n\n// Account (guarded)\nconst accountJson = $node?.[\"HTTP Account\"]?.json ?? {};\nconst equity = safeNum(accountJson.equity);\nconst buyingPower = safeNum(accountJson.buying_power);\n\n// ---- Risk budget (priority order) ----\nconst inputMaxRiskUsd = pickFirstNum(\n  plan.maxRiskUsd,\n  plan.max_risk_usd,\n  plan.risk?.maxRiskUsd,\n  plan.risk_config?.maxRiskUsd\n);\n\nconst inputMaxRiskPct = normalizePct(\n  pickFirstNum(\n    plan.maxRiskPct,\n    plan.max_risk_pct,\n    plan.risk?.maxRiskPct,\n    plan.risk_config?.maxRiskPct\n  )\n);\n\nconst envMaxRiskUsd = envNumSafe(\"MAX_RISK_USD\");\nconst envMaxRiskPct = normalizePct(envNumSafe(\"MAX_RISK_PCT\"));\n\nlet baseMaxRiskUsd = null;\n\nif (inputMaxRiskUsd != null) baseMaxRiskUsd = inputMaxRiskUsd;\nelse if (envMaxRiskUsd != null) baseMaxRiskUsd = envMaxRiskUsd;\nelse if (inputMaxRiskPct != null && equity != null) baseMaxRiskUsd = equity * inputMaxRiskPct;\nelse if (envMaxRiskPct != null && equity != null) baseMaxRiskUsd = equity * envMaxRiskPct;\nelse if (equity != null) baseMaxRiskUsd = equity * 0.005;\nelse baseMaxRiskUsd = 25;\n\n// ---- OPTIONS-ONLY sizing ----\nconst isOptionBuy = decision.startsWith(\"BUY_CALL\") || decision.startsWith(\"BUY_PUT\");\n\n// ---- RISK GATE: Block if portfolio risk limits exceeded ----\nconst riskBlocked = plan._risk_blocked === true;\nconst riskBlockedReasons = plan._risk_blocked_reasons || [];\nif (riskBlocked && isOptionBuy) {\n  return [{\n    json: {\n      ...plan,\n      qty: 0,\n      sizing: {\n        equity,\n        buyingPower,\n        maxRiskUsd: baseMaxRiskUsd,\n        entry: null,\n        stop: null,\n        riskPerContract: null,\n        qty: 0,\n        mode: \"blocked_by_risk_limits\",\n        reason: `Portfolio risk limits exceeded: ${riskBlockedReasons.join(', ')}`,\n        env_access: envMaxRiskUsd != null || envMaxRiskPct != null ? \"used\" : \"not_used_or_denied\",\n        conviction: null,\n        risk_blocked: true,\n        risk_blocked_reasons: riskBlockedReasons,\n      }\n    }\n  }];\n}\n\n\nif (!isOptionBuy) {\n  return [{\n    json: {\n      ...plan,\n      qty: 0,\n      sizing: {\n        equity,\n        buyingPower,\n        maxRiskUsd: baseMaxRiskUsd,\n        entry: null,\n        stop: null,\n        riskPerContract: null,\n        qty: 0,\n        mode: \"skipped_not_option_buy\",\n        reason: `Decision '${decision}' is not an option buy. This workflow only sizes option orders.`,\n        env_access: envMaxRiskUsd != null || envMaxRiskPct != null ? \"used\" : \"not_used_or_denied\",\n        conviction: null,\n      }\n    }\n  }];\n}\n\n// ---- ADD_POSITION shortcut: orchestrator said buy N more, just do it ----\nconst qtyOverride = safeNum(plan._qty_override);\nif (qtyOverride != null && qtyOverride > 0) {\n  const addQty = Math.min(qtyOverride, 10);\n  const addEntry = pickFirstNum(\n    plan.option_entry_premium,\n    plan.optionContext?.quote?.ask,\n    plan.optionContext?.quote?.mid\n  );\n  return [{\n    json: {\n      ...plan,\n      qty: addQty,\n      entry_type: (addEntry == null) ? \"market\" : \"limit\",\n      sizing: {\n        equity,\n        buyingPower,\n        baseMaxRiskUsd,\n        effectiveMaxRiskUsd: null,\n        entry: addEntry,\n        stop: null,\n        riskPerContract: null,\n        qty: addQty,\n        mode: \"add_position_override\",\n        reason: `ADD_POSITION: buying ${addQty} more per orchestrator`,\n        conviction: null,\n        maxQtyCap: 10,\n        wasCapped: qtyOverride > 10,\n      }\n    }\n  }];\n}\n\n// ---- Conviction scoring ----\nconst conviction = computeConvictionScore(plan);\n\n// Apply conviction multiplier to risk budget\nconst effectiveMaxRiskUsd = baseMaxRiskUsd * conviction.multiplier;\n\nconst entry = pickFirstNum(\n  plan.option_entry_premium,\n  plan.optionContext?.quote?.ask,\n  plan.optionContext?.quote?.mid\n);\n\nconst stop = pickFirstNum(\n  plan.option_stop_premium,\n  plan.option_stop,\n  plan.stopPrem,\n  plan.stop_premium\n);\n\nlet qty = 0;\nlet riskPerContract = null;\nlet sizingMode = \"options_premium\";\n\nif (entry != null && stop != null) {\n  const riskPerShare = entry - stop;\n  riskPerContract = riskPerShare > 0 ? riskPerShare * 100 : null;\n  if (riskPerContract != null && riskPerContract > 0) {\n    qty = Math.floor(effectiveMaxRiskUsd / riskPerContract);\n  }\n}\n\nqty = Math.max(0, qty);\n\n// ---- FALLBACK: if qty is still 0 but this is a valid option buy ----\nif (qty === 0 && isOptionBuy) {\n  const orchQty = safeNum(\n    plan.position_action?.qty_change ??\n    plan._orchestration_result?.position_action?.qty_change\n  );\n  qty = Math.max(1, orchQty ?? 1);\n  sizingMode = \"fallback_market\";\n}\n\n// ---- GUARDRAIL: hard max qty cap ----\nconst MAX_QTY_CAP = 10;\nconst preCap = qty;\nqty = Math.min(qty, MAX_QTY_CAP);\nconst wasCapped = qty < preCap;\n\n// ---- GUARDRAIL: don't exceed buying power ----\nif (buyingPower != null && entry != null) {\n  const totalCost = entry * 100 * qty;\n  if (totalCost > buyingPower) {\n    qty = Math.max(1, Math.floor(buyingPower / (entry * 100)));\n    qty = Math.min(qty, MAX_QTY_CAP);\n  }\n}\n\nreturn [{\n  json: {\n    ...plan,\n    qty,\n    entry_type: (entry == null) ? \"market\" : (plan.entry_type || \"limit\"),\n    sizing: {\n      equity,\n      buyingPower,\n      baseMaxRiskUsd,\n      effectiveMaxRiskUsd,\n      entry,\n      stop,\n      riskPerContract,\n      qty,\n      mode: sizingMode,\n      env_access: envMaxRiskUsd != null || envMaxRiskPct != null ? \"used\" : \"not_used_or_denied\",\n      conviction: {\n        score: conviction.score,\n        tier: conviction.tier,\n        multiplier: conviction.multiplier,\n        details: conviction.details,\n      },\n      maxQtyCap: MAX_QTY_CAP,\n      wasCapped,\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        36016,
        33840
      ],
      "id": "5f0322f0-2bf4-4cdb-aca9-170fdf8cbdf2",
      "name": "Compute Size"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $node[\"Normalize Confidence\"].json.confidencePct >= 65 && $node[\"Set Request\"].json.mode === \"AUTO\" }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "b791615b-330b-4f84-944d-1bf38aaa9b75"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "47f601b2-60c5-4656-aab5-641671dcd221",
                    "leftValue": "={{ $node[\"Set Request\"].json.mode === \"MANUAL\"}}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "65f89eb6-c750-4828-bc5e-3fa3a8eab45e",
                    "leftValue": "={{ $node[\"Normalize Confidence\"].json.confidencePct >= 65 }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {
          "allMatchingOutputs": false
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        35136,
        33616
      ],
      "id": "c3184476-8e2a-4723-a9ad-036b87d93ffc",
      "name": "Switch"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO workflow_decisions (ticker, action_type, decision, raw_payload)\nVALUES (\n  {{ $json.symbol ? \"'\" + $json.symbol.replace(/'/g, \"''\") + \"'\" : \"NULL\" }},\n  {{ $json.side ? \"'\" + $json.side.replace(/'/g, \"''\") + \"'\" : \"NULL\" }},\n  {{ $json.text ? \"'\" + $json.text.replace(/'/g, \"''\") + \"'\" : \"NULL\" }},\n  '{{ JSON.stringify($json).replace(/'/g, \"''\") }}'::jsonb\n)\nRETURNING id, created_at;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        37200,
        33824
      ],
      "id": "621adac7-a841-4e50-a0fc-9f36fe5a89e0",
      "name": "Insert row1",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Function node (Run Once for Each Item)\n * Purpose: flatten Alpaca order payload so Data Table Insert Row won't fail on nested objects.\n *\n * Handles API error responses gracefully so the decision is still saved to DB.\n *\n * Expected input (any of these):\n *  - $json.order_payload (recommended)\n *  - $json.order\n *  - or the order fields at top-level ($json.symbol, $json.take_profit, etc.)\n *  - API error response (when Submit Order fails)\n */\n\nfunction asString(x) {\n  if (x === undefined || x === null) return null;\n  if (typeof x === 'string') return x;\n  if (typeof x === 'number' || typeof x === 'boolean') return String(x);\n  // objects/arrays -> stringify\n  try { return JSON.stringify(x); } catch { return String(x); }\n}\n\nfunction pickOrder(j) {\n  return j?.order_payload ?? j?.order ?? j;\n}\n\nfunction isApiError(j) {\n  // Alpaca error responses typically have { message: \"...\", code: ... }\n  // n8n continueRegularOutput wraps errors with statusCode, etc.\n  if (j?.statusCode && j.statusCode >= 400) return true;\n  if (j?.error) return true;\n  if (j?.message && !j?.id && !j?.symbol) return true;\n  if (j?.code && typeof j.code === 'number' && j.code >= 40000000) return true;\n  return false;\n}\n\nconst j = $json;\n\n// --- Handle API error case ---\nif (isApiError(j)) {\n  // Try to retrieve original order payload from upstream nodes\n  let originalPayload = null;\n  let ticker = null;\n  let side = null;\n  let orderType = null;\n  let qty = null;\n\n  try {\n    const upstream = $('Parse Order Payload').first().json;\n    originalPayload = upstream?.order_payload || upstream;\n    ticker = asString(originalPayload?.symbol || upstream?.symbol);\n    side = asString(originalPayload?.side || upstream?.side);\n    orderType = asString(originalPayload?.type || originalPayload?.order_type || upstream?.type);\n    qty = asString(originalPayload?.qty || upstream?.qty);\n  } catch (e) {\n    // upstream node not reachable, use whatever we have\n  }\n\n  // Build error details string\n  let apiError = null;\n  try {\n    apiError = JSON.stringify({\n      statusCode: j?.statusCode,\n      message: j?.message || j?.error,\n      code: j?.code,\n      body: j,\n    });\n  } catch (e) {\n    apiError = asString(j?.message || j?.error || 'Unknown API error');\n  }\n\n  return [\n    {\n      json: {\n        created_at: asString(j?.created_at || new Date().toISOString()),\n        client_order_id: asString(originalPayload?.client_order_id),\n        symbol: ticker,\n        qty: qty,\n        notional: null,\n        side: side,\n        position_intent: asString(originalPayload?.position_intent),\n        type: orderType,\n        time_in_force: asString(originalPayload?.time_in_force),\n        limit_price: asString(originalPayload?.limit_price),\n        stop_price: asString(originalPayload?.stop_price),\n        extended_hours: asString(originalPayload?.extended_hours),\n        order_class: asString(originalPayload?.order_class),\n        take_profit_limit_price: null,\n        stop_loss_stop_price: null,\n        status: 'API_ERROR',\n        id: null,\n        order_json: apiError,\n      },\n    },\n  ];\n}\n\n// --- Normal (success) path ---\nconst order = pickOrder(j);\n\n// Flatten nested bracket objects\nconst takeProfitLimit = order?.take_profit?.limit_price ?? null;\nconst stopLossStop = order?.stop_loss?.stop_price ?? null;\n\n// Full payload string for audit/debug\nlet orderJsonStr = null;\ntry {\n  orderJsonStr = JSON.stringify(order);\n} catch (e) {\n  orderJsonStr = asString(order);\n}\n\n/**\n * Output: one item whose json contains ONLY scalars.\n * Map these fields directly into Data Table columns.\n */\nreturn [\n  {\n    json: {\n      // identity / audit\n      created_at: asString(order?.created_at ?? j?.created_at),\n      client_order_id: asString(order?.client_order_id ?? j?.client_order_id),\n      symbol: asString(order?.symbol ?? j?.symbol),\n\n      // order basics\n      qty: asString(order?.qty ?? j?.qty),\n      notional: asString(order?.notional ?? j?.notional),\n      side: asString(order?.side ?? j?.side),\n      position_intent: asString(order?.position_intent ?? j?.position_intent),\n      type: asString(order?.type ?? order?.order_type ?? j?.type ?? j?.order_type),\n      time_in_force: asString(order?.time_in_force ?? j?.time_in_force),\n      limit_price: asString(order?.limit_price ?? j?.limit_price),\n      stop_price: asString(order?.stop_price ?? j?.stop_price),\n      extended_hours: asString(order?.extended_hours ?? j?.extended_hours),\n      order_class: asString(order?.order_class ?? j?.order_class),\n\n      // bracket legs (flattened)\n      take_profit_limit_price: asString(takeProfitLimit),\n      stop_loss_stop_price: asString(stopLossStop),\n\n      // optional status fields (safe)\n      status: asString(order?.status ?? j?.status),\n      id: asString(order?.id ?? j?.id),\n\n      // store entire original payload safely in one column\n      order_json: orderJsonStr,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        36992,
        33824
      ],
      "id": "069dfaf9-df24-43f3-9758-875e02c4a2cc",
      "name": "Normalize Order"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: Derive Option Intent\n// MODE: Run Once for All Items\n//\n// OPTION A behavior:\n// - Outputs 2 items per input (call + put) unless force_right=true\n// - NO forced CALL default: derived_right may be null\n// - option_intent.force_right is ONLY true when explicitly provided\n// - Fix: inferUnderlyingPx() now reads your actual payload shape (summary.priceContext + timeframes.*.price.last_close)\n// - Fix: effective_end can fall back to generatedAt\n\nfunction isPlainObject(x) {\n  return x != null && typeof x === \"object\" && !Array.isArray(x);\n}\n\nfunction safeNum(x) {\n  if (typeof x === \"number\" && Number.isFinite(x)) return x;\n  if (typeof x === \"string\") {\n    const n = Number.parseFloat(x);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\nfunction boolVal(x) {\n  if (x === true || x === false) return x;\n  if (typeof x === \"string\") {\n    const s = x.trim().toLowerCase();\n    if ([\"true\", \"1\", \"yes\", \"y\"].includes(s)) return true;\n    if ([\"false\", \"0\", \"no\", \"n\"].includes(s)) return false;\n  }\n  return null;\n}\n\nfunction normRight(v) {\n  if (!v) return null;\n  const s = String(v).trim().toLowerCase();\n  if (s === \"call\" || s === \"c\") return \"call\";\n  if (s === \"put\" || s === \"p\") return \"put\";\n  return null;\n}\n\nfunction stripReservedKeys(obj) {\n  if (!isPlainObject(obj)) return {};\n  const out = {};\n  for (const [k, v] of Object.entries(obj)) {\n    if (k === \"pairedItem\") continue;\n    out[k] = v;\n  }\n  return out;\n}\n\nfunction ymdFromAnyDateLike(v) {\n  if (!v) return null;\n  const ms = Date.parse(v);\n  if (!Number.isFinite(ms)) return null;\n  return new Date(ms).toISOString().slice(0, 10);\n}\n\n\n\n// Return YYYY-MM-DD in a specific timezone (use NY as the trading \"date\")\nfunction ymdInTzFromAnyDateLike(v, timeZone = \"America/New_York\") {\n  if (!v) return null;\n  const ms = Date.parse(v);\n  if (!Number.isFinite(ms)) return null;\n  const d = new Date(ms);\n  // en-CA formats as YYYY-MM-DD\n  return new Intl.DateTimeFormat(\"en-CA\", {\n    timeZone,\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n  }).format(d);\n}\n\nfunction addDaysYMD(ymd, days) {\n  if (!ymd) return null;\n  const ms = Date.parse(ymd + \"T00:00:00Z\");\n  if (!Number.isFinite(ms)) return null;\n  return new Date(ms + days * 86400000).toISOString().slice(0, 10);\n}\n\n\n// Next business day: +1, then bump Sat/Sun to Monday.\n// (Requirement: +1 day; if Friday -> next Monday.)\nfunction nextBusinessDayYMD(anchorYmd) {\n  if (!anchorYmd) return null;\n  let d = addDaysYMD(anchorYmd, 1);\n  if (!d) return null;\n\n  // 0=Sun, 6=Sat based on UTC day-of-week for the YYYY-MM-DD string\n  const dow = new Date(d + \"T00:00:00Z\").getUTCDay();\n  if (dow === 6) d = addDaysYMD(d, 2); // Sat -> Mon\n  else if (dow === 0) d = addDaysYMD(d, 1); // Sun -> Mon\n\n  return d;\n}\n\n\n// FIXED: reads price from your payload structure\nfunction inferUnderlyingPx(input) {\n  // 1) root-level (existing behavior)\n  const root =\n    safeNum(input?.underlying_last) ??\n    safeNum(input?.underlying_price) ??\n    safeNum(input?.last_price) ??\n    safeNum(input?.price?.last_close) ??\n    safeNum(input?.price?.close) ??\n    safeNum(input?.price?.last) ??\n    null;\n  if (root != null) return root;\n\n  // 2) summary.priceContext.{htf,mtf,ltf}.price.last_close\n  const pc = input?.summary?.priceContext;\n  const fromSummary =\n    safeNum(pc?.htf?.price?.last_close) ??\n    safeNum(pc?.htf?.price?.close) ??\n    safeNum(pc?.mtf?.price?.last_close) ??\n    safeNum(pc?.mtf?.price?.close) ??\n    safeNum(pc?.ltf?.price?.last_close) ??\n    safeNum(pc?.ltf?.price?.close) ??\n    null;\n  if (fromSummary != null) return fromSummary;\n\n  // 3) timeframes[tf].price.last_close (prefer summary.htf if present)\n  const tfs = input?.timeframes;\n  if (tfs && typeof tfs === \"object\") {\n    const htf = input?.summary?.htf; // e.g. \"5m\"\n    if (htf && tfs[htf]) {\n      const p =\n        safeNum(tfs[htf]?.price?.last_close) ??\n        safeNum(tfs[htf]?.price?.close) ??\n        null;\n      if (p != null) return p;\n    }\n\n    // fallback: try common TFs\n    for (const tf of [\"5m\", \"3m\", \"2m\", \"1m\", \"15m\", \"60m\"]) {\n      if (tfs[tf]) {\n        const p =\n          safeNum(tfs[tf]?.price?.last_close) ??\n          safeNum(tfs[tf]?.price?.close) ??\n          null;\n        if (p != null) return p;\n      }\n    }\n\n    // last resort: any timeframe\n    for (const k of Object.keys(tfs)) {\n      const p =\n        safeNum(tfs[k]?.price?.last_close) ??\n        safeNum(tfs[k]?.price?.close) ??\n        null;\n      if (p != null) return p;\n    }\n  }\n\n  return null;\n}\n\nfunction inferStrikeStep(underlying) {\n  // SPY/QQQ/most ETFs: 1\n  const u = String(underlying || \"\").toUpperCase();\n  if ([\"SPY\", \"QQQ\", \"IWM\", \"DIA\"].includes(u)) return 1;\n  return 1;\n}\n\nfunction computeNearAtmStrikeRange(px, strikeCount, step) {\n  const half = Math.max(1, Math.floor((strikeCount || 12) / 2));\n  const atm = Math.round(px / step) * step;\n  return {\n    strike_gte: atm - half * step,\n    strike_lte: atm + half * step,\n  };\n}\n\nfunction deriveRightFromSignals(input) {\n  // Optional hint only (does not force CALL)\n  const bias =\n    (typeof input?.technical_bias === \"string\" ? input.technical_bias : \"\") ||\n    (typeof input?.trend_direction === \"string\" ? input.trend_direction : \"\") ||\n    \"\";\n  const b = bias.toUpperCase();\n  if (b.includes(\"BULL\") || b.includes(\"UP\")) return \"call\";\n  if (b.includes(\"BEAR\") || b.includes(\"DOWN\")) return \"put\";\n  return null;\n}\n\nconst inputs = $input.all().map(i => stripReservedKeys(i.json || {}));\nconst outputs = [];\n\nfor (const input of inputs) {\n  const existingIntent = isPlainObject(input.option_intent) ? input.option_intent : {};\n\n  const underlying = existingIntent.underlying || input.underlying || input.ticker || \"SPY\";\n\n  // FIX: include generatedAt fallback\n  const effective_end =\n    input.effective_end ||\n    existingIntent.effective_end ||\n    input.end_time ||\n    input.time ||\n    input.generatedAt ||\n    null;\n\n  \nconst anchor_ymd =\n  input.anchor_ymd ||\n  existingIntent.anchor_ymd ||\n  ymdInTzFromAnyDateLike(effective_end, \"America/New_York\") ||\n  ymdInTzFromAnyDateLike(new Date().toISOString(), \"America/New_York\");\n\n// REQUIREMENT: take +1 (next trading day) expiry; if Friday -> next Monday\nconst nextExp = nextBusinessDayYMD(anchor_ymd);\n\n// Force \"next day only\" unless explicitly overridden upstream\nconst exp_gte = input.exp_gte || existingIntent.exp_gte || nextExp;\nconst exp_lte = input.exp_lte || existingIntent.exp_lte || nextExp;\n\n\n  const strike_mode = input.strike_mode || existingIntent.strike_mode || \"near_atm\";\n  const strike_count = safeNum(input.strike_count) ?? safeNum(existingIntent.strike_count) ?? 8;\n  const min_oi = safeNum(input.min_oi) ?? safeNum(existingIntent.min_oi) ?? 0;\n  const max_spread_pct = safeNum(input.max_spread_pct) ?? safeNum(existingIntent.max_spread_pct) ?? 0.01;\n\n  const underlyingPx = inferUnderlyingPx(input);\n  const step = inferStrikeStep(underlying);\n\n  let strike_gte = safeNum(input.strike_gte) ?? safeNum(existingIntent.strike_gte) ?? null;\n  let strike_lte = safeNum(input.strike_lte) ?? safeNum(existingIntent.strike_lte) ?? null;\n\n  // Compute near-ATM strike bounds if missing and we have a price\n  if ((strike_gte == null || strike_lte == null) && strike_mode === \"near_atm\" && underlyingPx != null) {\n    const r = computeNearAtmStrikeRange(underlyingPx, strike_count, step);\n    if (strike_gte == null) strike_gte = r.strike_gte;\n    if (strike_lte == null) strike_lte = r.strike_lte;\n  }\n\n  // force_right only if explicitly provided\n  const force_right = boolVal(input.force_right) || boolVal(existingIntent.force_right);\n\n  // OPTION A: do NOT default derived_right to \"call\"\n  const derived_right = deriveRightFromSignals(input) || normRight(existingIntent.right) || null;\n\n  function buildOut(right) {\n    return {\n      ...input,\n      option_intent: {\n        underlying,\n        right, // explicit per emitted item\n        exp_gte,\n        exp_lte,\n        strike_mode,\n        strike_count,\n        strike_gte,\n        strike_lte,\n        min_oi,\n        max_spread_pct,\n        force_right: force_right === true,\n        effective_end,\n        anchor_ymd,\n      },\n      derived_right,\n      candidate_side: right === \"call\" ? \"CALL\" : right === \"put\" ? \"PUT\" : null,\n\n      // helpful debugging\n      _debug_intent: {\n        underlyingPx,\n        used_step: step,\n        computed_strike_bounds: (strike_gte != null && strike_lte != null && strike_mode === \"near_atm\"),\n      },\n    };\n  }\n\n  if (force_right) {\n    const r = normRight(existingIntent.right || input.right || derived_right) || derived_right;\n    if (r !== \"call\" && r !== \"put\") {\n      throw new Error(`force_right=true but no valid right was provided or inferred (got: ${r})`);\n    }\n    outputs.push({ json: buildOut(r) });\n  } else {\n    // OPTION A: ALWAYS emit both sides for candidate compare\n    outputs.push({ json: buildOut(\"call\") });\n    outputs.push({ json: buildOut(\"put\") });\n  }\n}\n\nreturn outputs;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        31024,
        33792
      ],
      "id": "a5074be8-91e5-416e-bc34-47057f244701",
      "name": "Derive Option Intent"
    },
    {
      "parameters": {
        "url": "https://paper-api.alpaca.markets/v2/options/contracts",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "underlying_symbols",
              "value": "={{$json.ticker}}"
            },
            {
              "name": "type",
              "value": "={{$json.option_intent.right}}"
            },
            {
              "name": "expiration_date_gte",
              "value": "={{$json.option_intent.exp_gte}}"
            },
            {
              "name": "expiration_date_lte",
              "value": "={{$json.option_intent.exp_lte}}"
            },
            {
              "name": "strike_price_gte",
              "value": "={{$json.option_intent.strike_gte}}"
            },
            {
              "name": "strike_price_lte",
              "value": "={{$json.option_intent.strike_lte}}"
            },
            {
              "name": "limit",
              "value": "200"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        31312,
        33888
      ],
      "id": "5830f7d8-e28d-4da5-85d9-1d6f2d1a0bb6",
      "name": "Get Option Contracts"
    },
    {
      "parameters": {
        "url": "https://data.alpaca.markets/v1beta1/options/snapshots",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "symbols",
              "value": "={{ $json.selected_option.contract_symbol }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        32960,
        33792
      ],
      "id": "ca6972e8-70c8-498d-bd5f-66bf045f0c4e",
      "name": "Get Option Snapshot"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Enrich Payload for AI (Run Once for Each Item)\n// Returns ONE item: { json: <object> }\n//\n// FIX (COMPLETED):\n// - Snapshot input has ONLY {snapshots:{...}} so most fields become null unless we pull upstream context.\n// - Merges from: Build AI Payload, Derive Option Intent, Select Contract (Shortlist),\n//   Select Contract (Liquid), Compare Candidates (EXPLICIT $node call), Force WAIT (Liquidity Gate)\n// - Merge is \"prefer defined\" (won\u2019t overwrite good values with null/undefined)\n// - Passes other_candidate forward\n// - Passes greeks.delta forward (optionContext.greeks + top-level option_delta)\n// - If option premiums missing, fills entry from quote and stop/tp from underlying move (only if missing)\n//\n// \u2705 TD Sequential FIX (Option A):\n// - Keep TD under intervals[tf].demark (NOT dmi.td)\n// - When building intervals from timeframes, copy tfEntry.demark (or tdSummary aliases) into intervals[tf].demark\n// - When base.intervals is already present, normalize so intervals[tf].demark exists (fallback from dmi.td if needed)\n\nfunction safeNum(x) {\n  if (typeof x === \"number\" && Number.isFinite(x)) return x;\n  if (typeof x === \"string\") {\n    const n = Number.parseFloat(x.trim());\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\nfunction round2(x) {\n  const n = safeNum(x);\n  if (n == null) return null;\n  return Math.round(n * 100) / 100;\n}\n\nfunction isPlainObject(x) {\n  return x != null && typeof x === \"object\" && !Array.isArray(x);\n}\n\nfunction clamp(x, lo, hi) {\n  const n = safeNum(x);\n  if (n == null) return null;\n  return Math.min(hi, Math.max(lo, n));\n}\n\nfunction mergePreferDefined(target, source) {\n  if (!isPlainObject(source)) return target;\n  for (const [k, v] of Object.entries(source)) {\n    if (v === undefined || v === null) continue;\n\n    // shallow object merge for plain objects\n    if (isPlainObject(v) && isPlainObject(target[k])) {\n      target[k] = mergePreferDefined({ ...target[k] }, v);\n      continue;\n    }\n    target[k] = v;\n  }\n  return target;\n}\n\n// n8n helper: safely read first item from a node output (same index if possible)\nfunction safeFirstJson(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    if (!Array.isArray(arr) || arr.length === 0) return {};\n    if (arr.length === 1) return arr[0].json ?? {};\n    return (arr[$itemIndex]?.json ?? arr[0].json ?? {});\n  } catch {\n    return {};\n  }\n}\n\n// Parse OCC option symbol like: SPY260107P00686000\nfunction parseOccSymbol(sym) {\n  if (typeof sym !== \"string\") return null;\n  const s = sym.trim().toUpperCase();\n  const m = s.match(/^([A-Z]{1,6})(\\d{6})([CP])(\\d{8})$/);\n  if (!m) return null;\n\n  const underlying = m[1];\n  const yymmdd = m[2];\n  const right = m[3] === \"C\" ? \"call\" : \"put\";\n  const strikeInt = Number.parseInt(m[4], 10);\n  if (!Number.isFinite(strikeInt)) return null;\n  const strike = strikeInt / 1000;\n\n  const yy = yymmdd.slice(0, 2);\n  const mm = yymmdd.slice(2, 4);\n  const dd = yymmdd.slice(4, 6);\n  const expiration = `20${yy}-${mm}-${dd}`;\n\n  return { underlying, right, expiration, strike };\n}\n\n// Extract the snapshots map from $json (supports array-wrapped)\nfunction extractSnapshotsMap(raw) {\n  if (!raw) return null;\n\n  if (Array.isArray(raw)) {\n    if (raw.length === 0) return null;\n    raw = raw[0];\n  }\n\n  if (!raw || typeof raw !== \"object\") return null;\n\n  if (raw.snapshots && typeof raw.snapshots === \"object\") return raw.snapshots;\n  if (raw.data && raw.data.snapshots && typeof raw.data.snapshots === \"object\") return raw.data.snapshots;\n\n  // Sometimes the whole payload is already snapshots map\n  const keys = Object.keys(raw);\n  if (keys.length > 0) {\n    const occLike = keys.find(k => /^[A-Z]{1,6}\\d{6}[CP]\\d{8}$/.test(k));\n    if (occLike) return raw;\n  }\n  return null;\n}\n\nfunction computeQuoteFromSnapshot(snap) {\n  if (!snap || typeof snap !== \"object\") return { bid: null, ask: null, mid: null, spread_pct: null };\n\n  const bid =\n    safeNum(snap?.latestQuote?.bp) ??\n    safeNum(snap?.latest_quote?.bp) ??\n    safeNum(snap?.quote?.bid) ??\n    safeNum(snap?.bid) ??\n    null;\n\n  const ask =\n    safeNum(snap?.latestQuote?.ap) ??\n    safeNum(snap?.latest_quote?.ap) ??\n    safeNum(snap?.quote?.ask) ??\n    safeNum(snap?.ask) ??\n    null;\n\n  const mid = (bid != null && ask != null) ? (bid + ask) / 2 : null;\n\n  const spread_pct =\n    (bid != null && ask != null && mid != null && mid > 0)\n      ? (ask - bid) / mid\n      : null;\n\n  return {\n    bid: bid != null ? round2(bid) : null,\n    ask: ask != null ? round2(ask) : null,\n    mid: mid != null ? round2(mid) : null,\n    spread_pct: spread_pct != null ? spread_pct : null,\n  };\n}\n\n// -------------------- TD / DeMark normalization (Option A) --------------------\nfunction normalizeDemark(tf, raw) {\n  if (!raw || typeof raw !== \"object\" || Array.isArray(raw)) return null;\n\n  const setupDir = raw.setupDir ?? raw.setup_dir ?? null;\n  const setupCount = safeNum(raw.setupCount ?? raw.setup_count) ?? null;\n  const setupCompleted = raw.setupCompleted ?? raw.setup_completed;\n\n  const countdownDir = raw.countdownDir ?? raw.countdown_dir ?? null;\n  const countdownCount = safeNum(raw.countdownCount ?? raw.countdown_count) ?? null;\n  const countdownCompleted = raw.countdownCompleted ?? raw.countdown_completed;\n\n  return {\n    tf: raw.tf ?? tf ?? null,\n    setupDir: setupDir ?? null,\n    setupCount,\n    setupCompleted: (setupCompleted === true || setupCompleted === false) ? setupCompleted : false,\n    countdownDir: countdownDir ?? null,\n    countdownCount,\n    countdownCompleted: (countdownCompleted === true || countdownCompleted === false) ? countdownCompleted : false,\n  };\n}\n\nfunction pickDemark(tf, tfEntry) {\n  if (!tfEntry || typeof tfEntry !== \"object\") return null;\n\n  // Prefer explicit \"demark\" if present (your upstream nodes use timeframes[tf].demark)\n  const raw =\n    tfEntry.demark ??\n    tfEntry.deMark ??\n    tfEntry.demarkSummary ??\n    tfEntry.tdSummary ??        // some nodes name it tdSummary\n    tfEntry.tdSequential ??     // sometimes whole object is here\n    tfEntry.tdseq ??\n    tfEntry.td ??\n    null;\n\n  return normalizeDemark(tf, raw);\n}\n\nfunction normalizeIntervalsDemark(intervals) {\n  if (!isPlainObject(intervals)) return intervals;\n\n  const out = { ...intervals };\n  for (const [tf, obj] of Object.entries(out)) {\n    if (!isPlainObject(obj)) continue;\n\n    // If demark exists, normalize it\n    if (obj.demark) {\n      out[tf] = { ...obj, demark: normalizeDemark(tf, obj.demark) };\n      continue;\n    }\n\n    // Else: try to backfill from dmi.td (legacy)\n    const fallbackRaw = obj?.dmi?.td ?? obj?.td ?? null;\n    const dm = normalizeDemark(tf, fallbackRaw);\n\n    out[tf] = { ...obj, demark: dm };\n  }\n  return out;\n}\n\nfunction buildIntervalsFromTimeframes(timeframes) {\n  if (!timeframes || typeof timeframes !== \"object\") return {};\n  const intervals = {};\n\n  for (const [tf, tfEntry] of Object.entries(timeframes)) {\n    if (!tfEntry || typeof tfEntry !== \"object\") continue;\n\n    const latest = tfEntry.latest || tfEntry.dmi || null;\n\n    const dmi = latest ? {\n      diPlus: safeNum(latest.diPlus ?? latest.di_plus ?? latest.plus_di ?? latest[\"DI+\"]),\n      diMinus: safeNum(latest.diMinus ?? latest.di_minus ?? latest.minus_di ?? latest[\"DI-\"]),\n      adx: safeNum(latest.adx),\n\n      // keep legacy slot (optional)\n      td: tfEntry.td ?? tfEntry.tdseq ?? tfEntry.tdSequential ?? null,\n    } : {\n      diPlus: null,\n      diMinus: null,\n      adx: null,\n\n      // keep legacy slot (optional)\n      td: tfEntry.td ?? tfEntry.tdseq ?? tfEntry.tdSequential ?? null,\n    };\n\n    const demark = pickDemark(tf, tfEntry);\n\n    const price = tfEntry.price || tfEntry.priceContext || null;\n\n    intervals[tf] = {\n      dmi,\n      demark, // \u2705 primary TD location\n      price: price ? {\n        last_close: safeNum(price.last_close ?? price.close ?? price.c),\n        last_high: safeNum(price.last_high ?? price.high ?? price.h),\n        last_low: safeNum(price.last_low ?? price.low ?? price.l),\n        swing_high_n: safeNum(price.swing_high_n),\n        swing_low_n: safeNum(price.swing_low_n),\n        atr_n_sma: safeNum(price.atr_n_sma ?? price.atr),\n        true_range_avg_n: safeNum(price.true_range_avg_n),\n      } : {\n        last_close: null,\n        last_high: null,\n        last_low: null,\n        swing_high_n: null,\n        swing_low_n: null,\n        atr_n_sma: null,\n        true_range_avg_n: null,\n      }\n    };\n  }\n\n  return normalizeIntervalsDemark(intervals);\n}\n// ---------------------------------------------------------------------------\n\nfunction computeLevelsIfMissing(existing, intervals) {\n  const trig = safeNum(existing.trigger_price);\n  const inv = safeNum(existing.invalidation_level);\n  const tgt = safeNum(existing.target_level);\n\n  if (trig != null && inv != null && tgt != null) {\n    return { trigger_price: trig, invalidation_level: inv, target_level: tgt };\n  }\n\n  const tf = intervals[\"5m\"] ? \"5m\" : (intervals[\"2m\"] ? \"2m\" : (intervals[\"1m\"] ? \"1m\" : null));\n  if (!tf) return { trigger_price: trig ?? null, invalidation_level: inv ?? null, target_level: tgt ?? null };\n\n  const dmi = intervals[tf]?.dmi || {};\n  const price = intervals[tf]?.price || {};\n\n  const diPlus = safeNum(dmi.diPlus);\n  const diMinus = safeNum(dmi.diMinus);\n\n  const lastClose = safeNum(price.last_close);\n  const swingHigh = safeNum(price.swing_high_n) ?? safeNum(price.last_high);\n  const swingLow = safeNum(price.swing_low_n) ?? safeNum(price.last_low);\n  const atr = safeNum(price.atr_n_sma) ?? safeNum(price.true_range_avg_n);\n\n  if (lastClose == null) return { trigger_price: trig ?? null, invalidation_level: inv ?? null, target_level: tgt ?? null };\n\n  const dir =\n    (diPlus != null && diMinus != null)\n      ? (diPlus > diMinus ? \"bullish\" : (diMinus > diPlus ? \"bearish\" : null))\n      : null;\n\n  const trigger_price = trig ?? lastClose;\n\n  if (inv != null && tgt != null) return { trigger_price, invalidation_level: inv, target_level: tgt };\n\n  if (!dir) return { trigger_price, invalidation_level: inv ?? null, target_level: tgt ?? null };\n\n  if (dir === \"bullish\") {\n    const invalidation_level = inv ?? (swingLow ?? null);\n    const target_level = tgt ?? (atr != null ? (lastClose + atr) : null);\n    return { trigger_price, invalidation_level, target_level };\n  } else {\n    const invalidation_level = inv ?? (swingHigh ?? null);\n    const target_level = tgt ?? (atr != null ? (lastClose - atr) : null);\n    return { trigger_price, invalidation_level, target_level };\n  }\n}\n\nfunction trimSelectedContract(c) {\n  if (!c || typeof c !== \"object\") return null;\n  const sym = c.symbol || c.contract_symbol || c.id || null;\n  const exp = c.expiration_date || c.expiration || c.expiry || null;\n  const strike = safeNum(c.strike ?? c.strike_price);\n  const right = (c.type || c.right || \"\").toString().toLowerCase() || null;\n\n  return {\n    symbol: sym,\n    expiration: exp ? String(exp).slice(0, 10) : null,\n    strike: strike != null ? strike : null,\n    right: (right === \"call\" || right === \"put\") ? right : null,\n  };\n}\n\nfunction trimSelectedOption(o) {\n  if (!o || typeof o !== \"object\") return null;\n  const sym = o.contract_symbol || o.symbol || null;\n  const right = (o.right || o.type || \"\").toString().toLowerCase() || null;\n  const exp = o.expiration || o.expiration_date || null;\n  const strike = safeNum(o.strike ?? o.strike_price);\n\n  return {\n    contract_symbol: sym,\n    symbol: sym,\n    right: (right === \"call\" || right === \"put\") ? right : null,\n    expiration: exp ? String(exp).slice(0, 10) : null,\n    strike: strike != null ? strike : null,\n  };\n}\n\nfunction trimOptionIntent(oi, fallbackUnderlyingPx) {\n  if (!oi || typeof oi !== \"object\") return null;\n  return {\n    underlying: oi.underlying ?? null,\n    right: oi.right ?? null,\n    exp_gte: oi.exp_gte ?? null,\n    exp_lte: oi.exp_lte ?? null,\n    strike_mode: oi.strike_mode ?? null,\n    strike_count: safeNum(oi.strike_count) ?? null,\n    strike_gte: safeNum(oi.strike_gte) ?? null,\n    strike_lte: safeNum(oi.strike_lte) ?? null,\n    min_oi: safeNum(oi.min_oi) ?? null,\n    max_spread_pct: safeNum(oi.max_spread_pct) ?? null,\n    force_right: oi.force_right === true,\n    effective_end: oi.effective_end ?? null,\n    anchor_ymd: oi.anchor_ymd ?? null,\n    fallback_underlying_px: safeNum(fallbackUnderlyingPx) ?? null,\n  };\n}\n\nfunction rrLong(entry, stop, tp) {\n  const e = safeNum(entry), s = safeNum(stop), t = safeNum(tp);\n  if (e == null || s == null || t == null) return null;\n  const risk = e - s;\n  const reward = t - e;\n  if (!(risk > 0) || !(reward > 0)) return null;\n  return Number((reward / risk).toFixed(2));\n}\n\nfunction trimOtherCandidate(o) {\n  if (!isPlainObject(o)) return null;\n\n  const sym =\n    o.option_contract_symbol ??\n    o.option_contract ??\n    o.option_symbol ??\n    o.optionContext?.contract?.symbol ??\n    o.contract_symbol ??\n    null;\n\n  const greeks = o.optionContext?.greeks ?? o.greeks ?? null;\n  const odelta = safeNum(o.option_delta) ?? safeNum(greeks?.delta);\n\n  const q = o.optionContext?.quote ?? o.quote ?? null;\n  const obid = safeNum(o.option_bid) ?? safeNum(q?.bid);\n  const oask = safeNum(o.option_ask) ?? safeNum(q?.ask);\n  const omid = safeNum(o.option_mid) ?? safeNum(q?.mid);\n  const osp  = safeNum(o.option_spread_pct) ?? safeNum(q?.spread_pct);\n\n  return {\n    candidate_side: o.candidate_side ?? null,\n    option_contract_symbol: sym,\n    candidate_pass: (o.candidate_pass === true || o.candidate_pass === false) ? o.candidate_pass : null,\n    candidate_score: safeNum(o.candidate_score),\n    candidate_reasons: o.candidate_reasons ?? o.reasons ?? null,\n\n    option_bid: obid != null ? round2(obid) : null,\n    option_ask: oask != null ? round2(oask) : null,\n    option_mid: omid != null ? round2(omid) : null,\n    option_spread_pct: osp,\n\n    option_risk_reward: safeNum(o.option_risk_reward),\n    option_delta: odelta,\n  };\n}\n\n// ----------------------------------------------------\n// 1) Build a proper \"base\" by merging upstream nodes\n// ----------------------------------------------------\nconst base = {};\nmergePreferDefined(base, safeFirstJson(\"Build AI Payload\"));\nmergePreferDefined(base, safeFirstJson(\"Derive Option Intent\"));\nmergePreferDefined(base, safeFirstJson(\"Select Contract (Shortlist)\"));\nmergePreferDefined(base, safeFirstJson(\"Select Contract (Liquid)\"));\n\n// \u2705 EXPLICIT: pull Compare Candidates using $node\ntry {\n  mergePreferDefined(base, $node[\"Compare Candidates\"].json);\n} catch (e) {\n  // ignore if node not found in this execution path\n}\n// \u2705 fallback (some executions prefer $items)\nmergePreferDefined(base, safeFirstJson(\"Compare Candidates\"));\n\n// keep Force WAIT last so it can override if it sets anything\nmergePreferDefined(base, safeFirstJson(\"Force WAIT (Liquidity Gate)\"));\n\n// ----------------------------------------------------\n// 2) Snapshot input (this node\u2019s direct input)\n// ----------------------------------------------------\nconst snapshotsMap = extractSnapshotsMap($json);\n\n// Symbol selection preference: from base, else shortlist, else snapshot-only key\nconst selected_contract = trimSelectedContract(base.selected_contract || base.selected || null);\n\nlet sym =\n  base.option_contract_symbol ??\n  base.selected_option?.contract_symbol ??\n  base.selected_option?.symbol ??\n  selected_contract?.symbol ??\n  base.optionContext?.contract?.symbol ??\n  null;\n\nsym = (typeof sym === \"string\") ? sym.trim().toUpperCase() : null;\n\n// If symbol doesn't exist in snapshots, but snapshots has exactly one key, use that key\nif (snapshotsMap) {\n  const keys = Object.keys(snapshotsMap);\n  if (sym && !snapshotsMap[sym] && keys.length === 1) sym = keys[0];\n  if (!sym && keys.length === 1) sym = keys[0];\n}\n\nconst occ = sym ? parseOccSymbol(sym) : null;\nconst snap = (snapshotsMap && sym && snapshotsMap[sym]) ? snapshotsMap[sym] : null;\nconst snapQuote = computeQuoteFromSnapshot(snap);\n\n// ----------------------------------------------------\n// 3) Intervals + deterministic levels (from base)\n// ----------------------------------------------------\nlet intervals = {};\nif (isPlainObject(base.intervals) && Object.keys(base.intervals).length > 0 && !isPlainObject(base.timeframes)) {\n  intervals = base.intervals;\n} else {\n  intervals = buildIntervalsFromTimeframes(base.timeframes || {});\n}\n\n// \u2705 ensure intervals[tf].demark exists (Option A)\nintervals = normalizeIntervalsDemark(intervals);\n\nconst fallbackUnderlyingPx =\n  safeNum(intervals?.[\"5m\"]?.price?.last_close) ??\n  safeNum(intervals?.[\"2m\"]?.price?.last_close) ??\n  safeNum(intervals?.[\"1m\"]?.price?.last_close) ??\n  safeNum(base?.trigger_price) ??\n  null;\n\nconst computedLevels = computeLevelsIfMissing(\n  {\n    trigger_price: base.trigger_price,\n    invalidation_level: base.invalidation_level,\n    target_level: base.target_level,\n  },\n  intervals\n);\n\nconst trigger_price = safeNum(base.trigger_price) ?? computedLevels.trigger_price ?? null;\nconst invalidation_level = safeNum(base.invalidation_level) ?? computedLevels.invalidation_level ?? null;\nconst target_level = safeNum(base.target_level) ?? computedLevels.target_level ?? null;\n\n// ----------------------------------------------------\n// 4) optionContext + liquidity gate (snapshot quote + compare greeks)\n// ----------------------------------------------------\nconst bid = snapQuote.bid ?? safeNum(base.option_bid) ?? safeNum(base.optionContext?.quote?.bid) ?? null;\nconst ask = snapQuote.ask ?? safeNum(base.option_ask) ?? safeNum(base.optionContext?.quote?.ask) ?? null;\nconst mid = snapQuote.mid ?? safeNum(base.option_mid) ?? safeNum(base.optionContext?.quote?.mid) ?? ((bid != null && ask != null) ? (bid + ask) / 2 : null);\nconst spread_pct =\n  snapQuote.spread_pct ??\n  safeNum(base.option_spread_pct) ??\n  safeNum(base.optionContext?.quote?.spread_pct) ??\n  ((bid != null && ask != null && mid != null && mid > 0) ? ((ask - bid) / mid) : null);\n\nlet selected_option = trimSelectedOption(base.selected_option);\nif (!selected_option && occ && sym) {\n  selected_option = {\n    symbol: sym,\n    contract_symbol: sym,\n    right: occ.right,\n    expiration: occ.expiration,\n    strike: occ.strike,\n  };\n}\n\n// Greeks: prefer snapshot, else Compare Candidates (base.optionContext.greeks)\nconst greeks =\n  snap?.greeks ??\n  snap?.latestGreeks ??\n  snap?.latest_greeks ??\n  base.optionContext?.greeks ??\n  base.optionContext?.latestGreeks ??\n  base.optionContext?.latest_greeks ??\n  base.greeks ??\n  null;\n\n// Top-level delta so Telegram can always display it\nconst option_delta = safeNum(greeks?.delta) ?? safeNum(base.option_delta) ?? null;\n\n// Trade: snapshot first, else upstream\nconst trade =\n  snap?.latestTrade ??\n  snap?.latest_trade ??\n  base.optionContext?.trade ??\n  null;\n\nconst optionContext = {\n  contract: {\n    symbol: sym,\n    right: occ?.right ?? base?.option_intent?.right ?? base.option_right ?? null,\n    expiration: occ?.expiration ?? selected_option?.expiration ?? selected_contract?.expiration ?? null,\n    strike: occ?.strike ?? selected_option?.strike ?? selected_contract?.strike ?? null,\n  },\n  quote: {\n    bid: bid != null ? round2(bid) : null,\n    ask: ask != null ? round2(ask) : null,\n    mid: mid != null ? round2(mid) : null,\n    spread_pct,\n  },\n  greeks,\n  trade,\n};\n\nconst maxSpreadPct = safeNum(base?.option_intent?.max_spread_pct) ?? 0.02;\n\nlet option_liquidity_ok = false;\nlet option_liquidity_reason = null;\n\nif (bid != null && ask != null && spread_pct != null) {\n  if (spread_pct <= maxSpreadPct) {\n    option_liquidity_ok = true;\n  } else {\n    option_liquidity_ok = false;\n    option_liquidity_reason = `Spread too wide: ${(spread_pct * 100).toFixed(2)}% > ${(maxSpreadPct * 100).toFixed(2)}%`;\n  }\n} else {\n  option_liquidity_ok = false;\n  option_liquidity_reason = \"Missing option quote (bid/ask)\";\n}\n\n// ----------------------------------------------------\n// 5) Option premiums: pass-through, else compute fallback\n// ----------------------------------------------------\nconst option_right = base.option_right ?? occ?.right ?? base?.option_intent?.right ?? null;\n\nlet option_entry_premium =\n  safeNum(base.option_entry_premium) ??\n  (ask != null ? ask : (mid != null ? mid : (bid != null ? bid : null)));\n\nlet option_stop_premium = safeNum(base.option_stop_premium);\nlet option_take_profit_premium = safeNum(base.option_take_profit_premium);\nlet option_risk_reward = safeNum(base.option_risk_reward);\n\n// If stop/tp missing, estimate from underlying move (ONLY if we have levels)\nif (option_entry_premium != null && (option_stop_premium == null || option_take_profit_premium == null)) {\n  const trig = trigger_price;\n  const inv = invalidation_level;\n  const tgt = target_level;\n\n  if (trig != null && trig > 0 && inv != null && tgt != null) {\n    let riskPct = Math.abs(trig - inv) / trig;\n    let rewardPct = Math.abs(tgt - trig) / trig;\n\n    riskPct = clamp(riskPct, 0.05, 0.25) ?? 0.08;\n    rewardPct = clamp(rewardPct, 0.07, 0.60) ?? Math.max(0.12, riskPct * 1.6);\n\n    if (option_stop_premium == null) option_stop_premium = Math.max(0.01, option_entry_premium * (1 - riskPct));\n    if (option_take_profit_premium == null) option_take_profit_premium = Math.max(0.01, option_entry_premium * (1 + rewardPct));\n  }\n}\n\nif (option_risk_reward == null) {\n  option_risk_reward = rrLong(option_entry_premium, option_stop_premium, option_take_profit_premium);\n}\n\n// ----------------------------------------------------\n// 6) Final payload\n// ----------------------------------------------------\nconst minimalPayload = {\n  // carry forward main plan context\n  ticker: base.ticker ?? base.underlying ?? occ?.underlying ?? null,\n  overall_timeframe: base.overall_timeframe ?? base.overall_timeframe_hint ?? base?.summary?.overall_timeframe ?? null,\n\n  // indicators / structure\n  intervals,\n\n  // deterministic underlying levels\n  trigger_price,\n  invalidation_level,\n  target_level,\n\n  // intent + selections\n  option_intent: trimOptionIntent(base.option_intent, fallbackUnderlyingPx),\n  selected_contract,\n  selected_option,\n\n  option_contract_symbol: sym,\n  optionContext,\n\n  // \u2705 top-level delta\n  option_delta,\n\n  // compare metadata (from Compare Candidates)\n  candidate_side: base.candidate_side ?? null,\n  derived_right: base.derived_right ?? null,\n  time_gate_ok: base.time_gate_ok ?? null,\n  time_gate_reason: base.time_gate_reason ?? null,\n  other_candidate: trimOtherCandidate(base.other_candidate) ?? null,\n  candidate_pass: base.candidate_pass ?? null,\n  candidate_score: safeNum(base.candidate_score) ?? null,\n  candidate_reasons: base.candidate_reasons ?? null,\n\n  // normalized option fields (AI must not invent)\n  option_right,\n\n  option_bid: safeNum(base.option_bid) ?? (bid != null ? round2(bid) : null),\n  option_ask: safeNum(base.option_ask) ?? (ask != null ? round2(ask) : null),\n  option_mid: safeNum(base.option_mid) ?? (mid != null ? round2(mid) : null),\n  option_spread_pct: safeNum(base.option_spread_pct) ?? spread_pct ?? null,\n\n  option_entry_premium: option_entry_premium != null ? round2(option_entry_premium) : null,\n  option_stop_premium: option_stop_premium != null ? round2(option_stop_premium) : null,\n  option_take_profit_premium: option_take_profit_premium != null ? round2(option_take_profit_premium) : null,\n  option_risk_reward: option_risk_reward != null ? Number(option_risk_reward) : null,\n\n  // gates\n  option_liquidity_ok,\n  option_liquidity_reason,\n};\n\nreturn { json: minimalPayload };\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        33232,
        33792
      ],
      "id": "1ca1d20f-96a5-4304-9fe2-ebc6b4f57a9d",
      "name": "Enrich Payload for AI"
    },
    {
      "parameters": {
        "url": "https://data.alpaca.markets/v1beta1/options/snapshots",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "symbols",
              "value": "={{ (() => {\n  const px = Number($json.underlying_last ?? $json.underlying_price ?? $json.last ?? NaN);\n  const arr = ($json.option_contracts || [])\n    .filter(c => c && c.tradable === true && c.status === 'active');\n\n  if (Number.isFinite(px)) {\n    arr.sort((a,b) =>\n      Math.abs(Number(a.strike_price) - px) - Math.abs(Number(b.strike_price) - px)\n    );\n  }\n\n  return arr.slice(0, 100).map(c => c.symbol).join(',');\n})() }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        32112,
        33808
      ],
      "id": "86fc2715-1457-49f1-ae50-576e644f2e7d",
      "name": "Get Option Snapshots (Shortlist)"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// n8n Code node: Verify Option Liquidity (Run Once for Each Item)\n// Preserves original JSON output structure and sets:\n// - option_liquidity_ok (boolean)\n// - option_liquidity_reason (string|null)\n// - quote { bid, ask, mid, spread_pct } (or nulls)\n// Also mirrors: option_bid/option_ask/option_mid/option_spread_pct\n//\n// Input expectation:\n// $json.snapshots is an OBJECT: { [contractSymbol]: snapshot }\n// Alpaca: snapshot.latestQuote.bp (bid), .ap (ask), .t (time)\n\nfunction isTemplateString(s) {\n  return typeof s === \"string\" && s.includes(\"{{$\") && s.includes(\"}}\");\n}\n\nfunction safeParseMs(s) {\n  if (typeof s !== \"string\" || isTemplateString(s)) return NaN;\n  const ms = Date.parse(s);\n  return Number.isFinite(ms) ? ms : NaN;\n}\n\nfunction finiteNum(x) {\n  return typeof x === \"number\" && Number.isFinite(x) ? x : null;\n}\n\nconst snapshots = $json.snapshots;\n\n// Tunables\nconst maxQuoteAgeSec = finiteNum($json.max_quote_age_sec) ?? 120;\nconst maxSpreadPct = finiteNum($json.max_spread_pct) ?? 0.02; // 2%\n\nconst baseOut = { ...$json }; // preserve everything\n\n// Guard: snapshots must be an object keyed by contract symbol\nif (!snapshots || typeof snapshots !== \"object\" || Array.isArray(snapshots)) {\n  return {\n    ...baseOut,\n\n    candidate_pass: false,\n    candidate_score: 1e6,\n\n    option_liquidity_ok: false,\n    option_liquidity_reason:\n      \"Missing or invalid snapshots (expected object keyed by contract symbol).\",\n    // preserve downstream shape\n    quote: { bid: null, ask: null, mid: null, spread_pct: null },\n    option_bid: null,\n    option_ask: null,\n    option_mid: null,\n    option_spread_pct: null,\n  };\n}\n\n// Iterate and pick \u201cbest\u201d passing candidate\nlet best = null;\n\n// diagnostics\nlet total = 0;\nlet missingBidAsk = 0;\nlet wideSpread = 0;\nlet staleQuote = 0;\n\nfor (const [symbol, snap] of Object.entries(snapshots)) {\n  total++;\n\n  const q = snap?.latestQuote;\n  const bid = finiteNum(q?.bp);\n  const ask = finiteNum(q?.ap);\n\n  if (bid == null || ask == null || ask <= 0 || bid < 0) {\n    missingBidAsk++;\n    continue;\n  }\n\n  const mid = (bid + ask) / 2;\n  const spreadPct = mid > 0 ? (ask - bid) / mid : null;\n\n  if (spreadPct == null || spreadPct > maxSpreadPct) {\n    wideSpread++;\n    continue;\n  }\n\n  // quote time\n  const quoteMs = safeParseMs(q?.t);\n  const nowMs = Date.now();\n  const ageSec = Number.isFinite(quoteMs) ? (nowMs - quoteMs) / 1000 : Infinity;\n\n  if (!Number.isFinite(ageSec) || ageSec > maxQuoteAgeSec) {\n    staleQuote++;\n    continue;\n  }\n\n  // choose best: lowest spreadPct, then freshest quote\n  if (\n    !best ||\n    spreadPct < best.spreadPct ||\n    (spreadPct === best.spreadPct && ageSec < best.quoteAgeSec)\n  ) {\n    best = {\n      symbol,\n      bid,\n      ask,\n      mid,\n      spreadPct,\n      quoteTime: q?.t ?? null,\n      quoteAgeSec: Number.isFinite(ageSec) ? ageSec : null,\n    };\n  }\n}\n\nif (!best) {\n  return {\n    ...baseOut,\n\n    candidate_pass: false,\n    candidate_score: 1e6,\n\n    option_liquidity_ok: false,\n    option_liquidity_reason:\n      `No option passed liquidity filters. total=${total}, missingBidAsk=${missingBidAsk}, wideSpread=${wideSpread}, staleQuote=${staleQuote}. ` +\n      `Check that you're reading Alpaca quote fields latestQuote.bp/ap.`,\n    quote: { bid: null, ask: null, mid: null, spread_pct: null },\n    option_bid: null,\n    option_ask: null,\n    option_mid: null,\n    option_spread_pct: null,\n  };\n}\n\n// Success: write in the SAME STRUCTURE downstream expects\nconst updatedSelected = (() => {\n  const sel = baseOut.selected_option;\n  if (sel && typeof sel === \"object\" && !Array.isArray(sel)) {\n    return { ...sel, contract_symbol: best.symbol };\n  }\n  // if selected_option missing, create minimal structure without breaking\n  return { contract_symbol: best.symbol };\n})();\n\nreturn {\n  ...baseOut,\n\n  // Candidate gating for Compare Candidates node\n  candidate_pass: (typeof baseOut.candidate_pass === \"boolean\") ? baseOut.candidate_pass : true,\n  candidate_score: (typeof baseOut.candidate_score === \"number\" && Number.isFinite(baseOut.candidate_score))\n    ? baseOut.candidate_score\n    : Math.round(((best.spreadPct ?? 1) * 100000) + (best.quoteAgeSec ?? 0)),\n\n  // preserve/update contract symbol fields commonly used downstream\n  option_contract_symbol: best.symbol,\n  selected_option: updatedSelected,\n\n  // REQUIRED by your downstream logic:\n  option_liquidity_ok: true,\n  option_liquidity_reason: null,\n\n  // Keep the exact quote object shape:\n  quote: {\n    bid: best.bid,\n    ask: best.ask,\n    mid: best.mid,\n    spread_pct: best.spreadPct,\n  },\n\n  // Mirrors (if your other nodes read these):\n  option_bid: best.bid,\n  option_ask: best.ask,\n  option_mid: best.mid,\n  option_spread_pct: best.spreadPct,\n\n  // helpful extras (won\u2019t break anything):\n  option_quote_time: best.quoteTime,\n  option_quote_age_sec: best.quoteAgeSec,\n};\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        32320,
        33808
      ],
      "id": "d736f674-2a4e-4be3-9570-b7eb2539e57c",
      "name": "Select Contract (Liquid)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "eef2066c-f8c6-49f7-bedd-ba19db456167",
              "leftValue": "={{$json.option_liquidity_ok === true}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        32736,
        33808
      ],
      "id": "31e3438c-cee5-4721-8849-7aef1b02fdc9",
      "name": "Liquidity OK?"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Code node: Force WAIT (Liquidity Gate) - Run Once for Each Item\n// Output an AI-like payload forcing WAIT due to liquidity gate.\n// Also sets _gate_blocked metadata so downstream persist nodes can\n// record CANCELLED in order_lifecycle if an INTENT was created.\n\nconst base = $json; // comes from Select Contract (Liquid + Gate)\n\nconst ticker = base?.ticker || base?.symbol || base?.option_intent?.underlying_symbol || \"UNKNOWN\";\nconst gateReason = base?.option_liquidity_reason || \"Liquidity gate failed\";\n\nreturn {\n  ...base,\n  option_decision: \"WAIT\",\n  option_contract_symbol: null,\n  option_right: base?.option_intent?.right || null,\n\n  option_bid: null,\n  option_ask: null,\n  option_mid: null,\n  option_spread_pct: null,\n\n  option_entry_premium: null,\n  option_stop_premium: null,\n  option_take_profit_premium: null,\n  option_risk_reward: null,\n\n  confidence: base?.confidence ?? 0.0,\n  key_factors: [\n    ...(Array.isArray(base?.key_factors) ? base.key_factors : []),\n    `Liquidity gate: ${gateReason}`,\n    base?.optionContext?.reason ? `Detail: ${base.optionContext.reason}` : null,\n  ].filter(Boolean),\n  plain_explanation: `Forced WAIT: ${gateReason}`,\n\n  // Gate-blocked metadata for order_lifecycle tracking\n  _gate_blocked: true,\n  _gate_blocked_by: \"liquidity\",\n  _gate_blocked_reason: gateReason,\n  _gate_blocked_at: new Date().toISOString()\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        32960,
        34000
      ],
      "id": "8f22dbe7-f83b-4e52-b2c3-f49f0b42da6d",
      "name": "Force WAIT (Liquidity Gate)"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// n8n Code node: Select Contract (Shortlist)\n// MODE: Run Once for Each Item\n//\n// OPTION A behavior:\n// - Prefer intentRight first (each item already has option_intent.right = call/put)\n// - NO default to CALL\n// - If no right can be determined, FAIL with candidate_pass=false (instead of silently choosing CALL)\n//\n// IMPORTANT: Returns ONE OBJECT (not an array) for \"Run Once for Each Item\"\n\nfunction safeNum(x) {\n  if (typeof x === \"number\" && Number.isFinite(x)) return x;\n  if (typeof x === \"string\") {\n    const n = Number.parseFloat(x);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\nfunction isPlainObject(x) {\n  return x != null && typeof x === \"object\" && !Array.isArray(x);\n}\nfunction unwrapItem(x) {\n  if (!isPlainObject(x)) return x;\n  if (isPlainObject(x.json)) return x.json;\n  return x;\n}\nfunction normRight(v) {\n  if (!v) return null;\n  const s = String(v).trim().toLowerCase();\n  if (s === \"call\" || s === \"c\") return \"call\";\n  if (s === \"put\" || s === \"p\") return \"put\";\n  return null;\n}\nfunction getExp(c) {\n  const v =\n    c?.expiration ||\n    c?.expiration_date ||\n    c?.exp_date ||\n    c?.exp ||\n    c?.expiry ||\n    null;\n  if (!v) return null;\n  return String(v).slice(0, 10);\n}\nfunction getRight(c) {\n  const v = c?.type || c?.right || c?.option_type || null;\n  return normRight(v);\n}\nfunction getStrike(c) {\n  return safeNum(c?.strike_price ?? c?.strike ?? null);\n}\nfunction getOi(c) {\n  return safeNum(c?.open_interest ?? c?.oi ?? null) ?? 0;\n}\nfunction getSpreadPct(c) {\n  // If bid/ask exist\n  const bid = safeNum(c?.bid ?? c?.quote?.bid ?? null);\n  const ask = safeNum(c?.ask ?? c?.quote?.ask ?? null);\n  if (bid != null && ask != null && ask > 0) return (ask - bid) / ask;\n  // If API already gives spread%:\n  const sp = safeNum(c?.spread_pct ?? null);\n  return sp;\n}\nfunction dedupeBySymbol(list) {\n  const out = [];\n  const seen = new Set();\n  for (const x of list) {\n    const sym = x?.symbol || x?.contract_symbol;\n    if (!sym) continue;\n    if (seen.has(sym)) continue;\n    seen.add(sym);\n    out.push(x);\n  }\n  return out;\n}\n\n// --- INPUTS ---\nconst cur = unwrapItem($json || {});\nconst intent =\n  (isPlainObject(cur.option_intent) ? cur.option_intent :\n   isPlainObject(cur.optionIntent) ? cur.optionIntent :\n   {}) || {};\n\nconst forced = intent.force_right === true;\n\nconst intentRight = normRight(intent.right);\n// Candidate-side desired right (per item): used ONLY to choose contracts for this candidate.\nconst derivedRight = normRight(cur.derived_right) || normRight(cur.option_right) || null;\n\n// OPTION A: prefer intentRight first; NO default to CALL (candidate-side)\nlet desiredRight =\n  (forced && intentRight) ? intentRight :\n  (intentRight || derivedRight || null);\n\n// Market-level desired right (GLOBAL): used by Compare Candidates as \"desired\".\n// IMPORTANT: Never set desired_option_right from option_intent.right (self-referential).\nfunction getTrendCtx() {\n  try {\n    const arr = $items(\"Compute Trend & Confidence\");\n    if (Array.isArray(arr) && arr.length) return arr[0].json || {};\n  } catch {}\n  try {\n    return $node[\"Compute Trend & Confidence\"].json || {};\n  } catch {}\n  return {};\n}\nfunction deriveMarketDesiredRight(obj) {\n  const b = String(obj?.technical_bias_pre ?? obj?.technical_bias ?? \"\").toLowerCase();\n  if (b.includes(\"bear\")) return \"put\";\n  if (b.includes(\"bull\")) return \"call\";\n  const td = String(obj?.trend_direction_pre ?? obj?.trend_direction ?? \"\").toLowerCase();\n  if (td.includes(\"down\")) return \"put\";\n  if (td.includes(\"up\")) return \"call\";\n  return null;\n}\nconst trendCtx = getTrendCtx();\nconst marketDesiredRight =\n  normRight(cur.marketDesiredRight) ||\n  normRight(cur.desired_right_market) ||\n  normRight(cur.desired_option_right_market) ||\n  normRight(trendCtx?.marketDesiredRight) ||\n  normRight(trendCtx?.desired_right_market) ||\n  normRight(trendCtx?.desired_option_right_market) ||\n  normRight(cur.desired_right) ||\n  normRight(trendCtx?.desired_right) ||\n  deriveMarketDesiredRight(cur) ||\n  deriveMarketDesiredRight(trendCtx) ||\n  null;\n\nif (!desiredRight) {\n  return {\n    ...cur,\n    option_intent: intent,\n    desired_option_right: marketDesiredRight || null,\n    marketDesiredRight: marketDesiredRight || null,\n    candidate_side: null,\n    candidates_narrowed: [],\n    option_contract_symbol: null,\n    snapshots_symbols: \"\",\n    candidate_pass: false,\n    candidate_score: 1e9,\n    candidate_reasons: [\"missing_desired_right\"],\n    shortlist_debug: { reason: \"No intent.right or derived_right; not defaulting to CALL.\" },\n    error: null,\n  };\n}\n\n// Expiry window\nconst expGte = intent.exp_gte || null;\nconst expLte = intent.exp_lte || null;\n\nconst all = Array.isArray(cur.contracts) ? cur.contracts :\n            Array.isArray(cur.option_contracts) ? cur.option_contracts :\n            Array.isArray(cur.contracts_raw) ? cur.contracts_raw :\n            [];\n\n// Filter by right + expiry\nlet pool = all.filter(c => {\n  const r = getRight(c);\n\n  if (forced) {\n    // forced: require known match\n    if (r !== desiredRight) return false;\n  } else {\n    // not forced: enforce if known, allow unknown\n    if (r && r !== desiredRight) return false;\n  }\n\n  const exp = getExp(c);\n  if (expGte && exp && exp < expGte) return false;\n  if (expLte && exp && exp > expLte) return false;\n\n  return true;\n});\n\n// earliest expiry in pool\nconst exps = pool.map(getExp).filter(Boolean).sort();\nconst minExpiry = exps.length ? exps[0] : null;\n\n// Optional: earliest expiry + 1 day protection is handled later in your workflow;\n// shortlist keeps earliest expiry; downstream logic/safety can bump it.\n\n// Narrow to earliest expiry (if known)\nif (minExpiry) pool = pool.filter(c => getExp(c) === minExpiry);\n\n// Additional filters\nconst minOi = safeNum(intent.min_oi) ?? 0;\npool = pool.filter(c => getOi(c) >= minOi);\n\n// Spread filter (if spread can be computed)\nconst maxSpreadPct = safeNum(intent.max_spread_pct);\nif (maxSpreadPct != null) {\n  pool = pool.filter(c => {\n    const sp = getSpreadPct(c);\n    if (sp == null) return true; // allow unknown here; Liquid node will gate strictly using snapshots\n    return sp <= maxSpreadPct;\n  });\n}\n\n// Prefer near-ATM by strike distance if we have underlying price hint\nconst underlyingPx =\n  safeNum(cur?.underlying_last) ??\n  safeNum(cur?.underlying_price) ??\n  safeNum(cur?.price?.last_close) ??\n  null;\n\nfunction score(c) {\n  const strike = getStrike(c);\n  const oi = getOi(c);\n  const sp = getSpreadPct(c);\n\n  // Lower score is better\n  let s = 0;\n  if (underlyingPx != null && strike != null) s += Math.abs(strike - underlyingPx);\n  s += (sp != null ? sp * 100 : 2);         // prefer tighter spreads when known\n  s -= Math.min(oi, 5000) / 5000;          // prefer higher OI a bit\n  return s;\n}\n\npool = dedupeBySymbol(pool);\n\npool.sort((a, b) => score(a) - score(b));\n\n// keep top N for downstream snapshots (<=100 symbols total)\nconst keepN = 30;\nconst finalPool = pool.slice(0, keepN);\n\nconst selected = finalPool.length ? finalPool[0] : null;\nconst optionContractSymbol = selected ? (selected.symbol || selected.contract_symbol || null) : null;\n\n// Build snapshots_symbols (<=100)\nconst snapshotsSymbolsArr = finalPool.map(x => x.symbol || x.contract_symbol).filter(Boolean).slice(0, 100);\nconst snapshots_symbols = snapshotsSymbolsArr.join(\",\");\n\nconst shortlist_debug = {\n  desiredRight,\n  forced,\n  expGte,\n  expLte,\n  minExpiry,\n  counts: {\n    all: all.length,\n    after_filters: pool.length,\n    finalPool: finalPool.length,\n  },\n};\n\nconst candidate_pass = Boolean(optionContractSymbol);\n\nreturn {\n  ...cur,\n  // keep intent stable for downstream\n  option_intent: isPlainObject(cur.option_intent) ? cur.option_intent : intent,\n\n  target_expiration: minExpiry,\n  desired_option_right: marketDesiredRight || null,\n  marketDesiredRight: marketDesiredRight || null,\n\n  shortlist_contracts: finalPool,\n  candidates_narrowed: finalPool,\n  selected,\n  selected_expiration: selected ? getExp(selected) : null,\n  option_contract_symbol: optionContractSymbol,\n\n  snapshots_symbols,\n  shortlist_debug,\n  candidate_pass,\n  candidate_score: candidate_pass ? 0 : 1e9,\n  candidate_reasons: candidate_pass ? [] : [\"no_contract_selected\"],\n  error: null,\n};\n\n\n\n\n\n\n\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        31872,
        33808
      ],
      "id": "5af6b60a-8c02-4359-9a45-002e24bf9a7e",
      "name": "Select Contract (Shortlist)"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (Run Once for Each Item)\n// Compute trend_direction / strength_score / confidence deterministically.\n// Output fields:\n// - confidence_pre (0..1)\n// - confidencePct_pre (0..100)\n// - trend_direction_pre, trend_strength_score_pre, trend_strength_pre, alignment_pre, adx_confirmation_pre\n//\n// AI will be instructed to NOT recompute confidence.\n\nfunction toNum(x) {\n  if (typeof x === 'number' && Number.isFinite(x)) return x;\n  if (typeof x === 'string') {\n    const n = Number.parseFloat(x);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\nfunction clamp(x, lo, hi) {\n  if (!Number.isFinite(x)) return null;\n  return Math.min(hi, Math.max(lo, x));\n}\n\n// \"1m\",\"2m\",\"5m\",\"15m\",\"60m\",\"1h\",\"4h\",\"1d\"\nfunction tfToMinutes(tf) {\n  const s = String(tf ?? '').trim().toLowerCase();\n  const m = s.match(/^(\\d+)\\s*(m|h|d)$/);\n  if (!m) return null;\n  const n = Number(m[1]);\n  if (!Number.isFinite(n) || n <= 0) return null;\n  const unit = m[2];\n  if (unit === 'm') return n;\n  if (unit === 'h') return n * 60;\n  if (unit === 'd') return n * 1440;\n  return null;\n}\n\nfunction pickHighTf(tfs) {\n  // Follow your policy: prefer 5m else 15m else 60m else slowest.\n  const set = new Set(tfs);\n  if (set.has('5m')) return '5m';\n  if (set.has('15m')) return '15m';\n  if (set.has('60m')) return '60m';\n\n  // slowest = largest minutes\n  let best = null;\n  let bestMin = -1;\n  for (const tf of tfs) {\n    const mins = tfToMinutes(tf);\n    if (mins != null && mins > bestMin) {\n      bestMin = mins;\n      best = tf;\n    }\n  }\n  return best ?? (tfs[0] ?? null);\n}\n\nfunction normDirFromDmi(diPlus, diMinus) {\n  if (diPlus == null || diMinus == null) return null;\n  if (diPlus > diMinus) return 'bullish';\n  if (diMinus > diPlus) return 'bearish';\n  return 'flat';\n}\n\nfunction strengthLabel(score) {\n  if (score == null) return null;\n  if (score < 25) return 'weak';\n  if (score < 60) return 'moderate';\n  return 'strong';\n}\n\n// TD adjustment: only small. Penalize if TD direction is against trend AND setupCompleted.\nfunction tdAdjust(intervals, trendDirection /* 'uptrend'|'downtrend'|null */) {\n  if (!trendDirection) return 0;\n\n  const want = trendDirection === 'uptrend' ? 'bullish' : 'bearish';\n  const oppose = want === 'bullish' ? 'bearish' : 'bullish';\n\n  let supports = false;\n  let against = false;\n\n  for (const tf of Object.keys(intervals || {})) {\n    const dm = intervals?.[tf]?.demark;\n    if (!dm) continue;\n\n    const setupDir = (dm.setupDir ?? null);\n    const countdownDir = (dm.countdownDir ?? null);\n\n    const setupCompleted = !!dm.setupCompleted;\n    const setupCount = toNum(dm.setupCount);\n    const hasSetupSignal = setupCompleted || (setupCount != null && setupCount >= 9);\n\n    const dir = setupDir || countdownDir;\n\n    if (dir === want && hasSetupSignal) supports = true;\n    if (dir === oppose && hasSetupSignal) against = true;\n  }\n\n  if (against) return -0.05;\n  if (supports) return +0.03;\n  return 0;\n}\n\n// ---------------- main ----------------\nconst payload = ($json && typeof $json === 'object') ? $json : {};\nconst intervals = (payload.intervals && typeof payload.intervals === 'object') ? payload.intervals : (payload.timeframes || {});\nconst tfKeys = Object.keys(intervals || {});\n\nlet bull = 0, bear = 0, known = 0;\nlet spreads = [];\n\nfor (const tf of tfKeys) {\n  const dmi = intervals?.[tf]?.dmi || {};\n  const diPlus = toNum(dmi.diPlus ?? dmi.di_plus ?? dmi.plus_di ?? dmi[\"DI+\"]);\n  const diMinus = toNum(dmi.diMinus ?? dmi.di_minus ?? dmi.minus_di ?? dmi[\"DI-\"]);\n\n  const dir = normDirFromDmi(diPlus, diMinus);\n  if (dir === 'bullish') { bull++; known++; }\n  else if (dir === 'bearish') { bear++; known++; }\n\n  if (diPlus != null && diMinus != null) {\n    spreads.push(Math.abs(diPlus - diMinus));\n  }\n}\n\nlet trend_direction_pre = null;\nlet alignment_pre = null;\n\nif (known === 0) {\n  trend_direction_pre = null;\n  alignment_pre = null;\n} else if (bull === known) {\n  trend_direction_pre = 'uptrend';\n  alignment_pre = 'all_aligned';\n} else if (bear === known) {\n  trend_direction_pre = 'downtrend';\n  alignment_pre = 'all_aligned';\n} else {\n  trend_direction_pre = 'mixed';\n  alignment_pre = 'mixed';\n}\n\n// strength score\nlet trend_strength_score_pre = null;\nif (spreads.length > 0) {\n  const avg = spreads.reduce((a,b) => a + b, 0) / spreads.length;\n  trend_strength_score_pre = clamp(Math.round(avg * 5), 0, 100);\n}\n\nconst trend_strength_pre = strengthLabel(trend_strength_score_pre);\n\n// ADX confirmation (context only) using \"high tf\"\nconst highTf = pickHighTf(tfKeys);\nlet adx_confirmation_pre = null;\nif (highTf) {\n  const adx = toNum(intervals?.[highTf]?.dmi?.adx ?? intervals?.[highTf]?.dmi?.ADX);\n  if (adx != null) adx_confirmation_pre = (adx > 25 ? 'confirmed' : 'not_confirmed');\n}\n\n// confidence\nlet conf = 0.40;\nif ((trend_direction_pre === 'uptrend' || trend_direction_pre === 'downtrend') && trend_strength_score_pre != null) {\n  conf = 0.45 + 0.40 * clamp(trend_strength_score_pre, 0, 100) / 100;\n}\nif (adx_confirmation_pre === 'confirmed') conf += 0.05;\n\n// TD adjustment\nconf += tdAdjust(intervals, (trend_direction_pre === 'mixed') ? null : trend_direction_pre);\n\nconf = clamp(Math.round(conf * 100) / 100, 0, 1);\nconst confidence_pre = conf;\nconst confidencePct_pre = confidence_pre == null ? null : Math.round(confidence_pre * 10000) / 100; // 2dp pct\n\nreturn [\n  {\n    json: {\n      ...payload,\n\n      // deterministic fields (preferred)\n      confidence_pre,\n      confidencePct_pre,\n      trend_direction_pre,\n      trend_strength_score_pre,\n      trend_strength_pre,\n      alignment_pre,\n      adx_confirmation_pre,\n\n      // debug (optional)\n      confidence_debug: {\n        tfKeys,\n        known_count: known,\n        bull_count: bull,\n        bear_count: bear,\n        spreads,\n        highTf\n      }\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        34064,
        33792
      ],
      "id": "6674007b-0d8d-46c5-b31a-fd9883e2da8f",
      "name": "Compute Trend & Confidence"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: Compare Candidates\n// MODE: Run Once for All Items\n\nfunction isPlainObject(x) {\n  return x != null && typeof x === \"object\" && !Array.isArray(x);\n}\n\nfunction safeStr(x) {\n  if (x == null) return null;\n  const s = String(x).trim();\n  return s === \"\" ? null : s;\n}\n\nfunction toNum(x) {\n  if (typeof x === \"number\" && Number.isFinite(x)) return x;\n  if (typeof x === \"string\" && x.trim() !== \"\") {\n    const n = Number.parseFloat(x);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\n// FIX: safeNum used by DMI helpers\nfunction safeNum(x) {\n  return toNum(x);\n}\n\nfunction toInt(x) {\n  const n = toNum(x);\n  return n == null ? null : Math.trunc(n);\n}\n\nfunction normSide(v) {\n  const s = safeStr(v);\n  if (!s) return null;\n  const t = s.toUpperCase();\n  if (t === \"CALL\" || t === \"C\") return \"CALL\";\n  if (t === \"PUT\" || t === \"P\") return \"PUT\";\n  return null;\n}\n\nfunction pickSubset(c) {\n  return {\n    ticker: c?.ticker ?? null,\n    overall_timeframe: c?.overall_timeframe ?? c?.timeframes ?? null,\n    candidate_side: normSide(c?.candidate_side) ?? null,\n    candidate_pass:\n      c?.candidate_pass === true || c?.candidate_pass === false ? c.candidate_pass : null,\n\n    option_contract_symbol: safeStr(c?.option_contract_symbol),\n    option_bid: toNum(c?.option_bid),\n    option_ask: toNum(c?.option_ask),\n    option_mid: toNum(c?.option_mid),\n    option_spread_pct: toNum(c?.option_spread_pct),\n    option_entry_premium: toNum(c?.option_entry_premium),\n\n    option_risk_reward: toNum(c?.option_risk_reward),\n    option_delta: toNum(c?.option_delta),\n\n    option_liquidity_ok:\n      c?.option_liquidity_ok === true || c?.option_liquidity_ok === false ? c.option_liquidity_ok : null,\n    option_liquidity_reason: safeStr(c?.option_liquidity_reason),\n\n    trigger_price: toNum(c?.trigger_price),\n    invalidation_level: toNum(c?.invalidation_level),\n    target_level: toNum(c?.target_level),\n  };\n}\n\n// Prefer pulling market/trend context from the deterministic node so desired inputs are not \"n/a\"\nfunction getTrendCtxSafe() {\n  try {\n    const arr = $items(\"Compute Trend & Confidence\");\n    if (Array.isArray(arr) && arr.length) return arr[0].json || {};\n  } catch {}\n  try {\n    return $node[\"Compute Trend & Confidence\"].json || {};\n  } catch {}\n  return {};\n}\n\nfunction readExplicitSide(obj) {\n  if (!obj) return { side: null, field: null };\n  const checks = [\n    [\"winner_side\", obj?.winner_side],\n    [\"desired_side\", obj?.desired_side],\n    [\"marketDesiredRight\", obj?.marketDesiredRight],\n    [\"desired_right\", obj?.desired_right],\n    [\"desired_option_right\", obj?.desired_option_right],\n  ];\n  for (const [field, val] of checks) {\n    const s = normSide(val);\n    if (s) return { side: s, field };\n  }\n  return { side: null, field: null };\n}\n\nfunction inferDesiredMetaPair(left, right) {\n  const trendCtx = getTrendCtxSafe();\n  const base = left || right || {};\n  const inputs = {\n    bias: safeStr(base?.technical_bias_pre ?? base?.technical_bias ?? trendCtx?.technical_bias_pre ?? trendCtx?.technical_bias) ?? null,\n    trend: safeStr(base?.trend_direction_pre ?? base?.trend_direction ?? trendCtx?.trend_direction_pre ?? trendCtx?.trend_direction) ?? null,\n    derived_right: safeStr(base?.derived_right ?? base?.desired_right ?? base?.marketDesiredRight ?? trendCtx?.derived_right ?? trendCtx?.desired_right ?? trendCtx?.marketDesiredRight) ?? null,\n    dmi_vote: null,\n    explicit: null,\n  };\n\n  // Explicit consensus logic\n  const exL = readExplicitSide(left);\n  const exR = readExplicitSide(right);\n\n  if (exL.side && exR.side) {\n    if (exL.side === exR.side) {\n      inputs.explicit = { mode: \"consensus\", left: exL, right: exR };\n      return { side: exL.side, source: \"explicit_consensus\", inputs };\n    } else {\n      inputs.explicit = { mode: \"conflict_ignored\", left: exL, right: exR };\n    }\n  } else if (exL.side || exR.side) {\n    const ex = exL.side ? exL : exR;\n    inputs.explicit = { mode: \"single\", from: exL.side ? \"left\" : \"right\", value: ex };\n    return { side: ex.side, source: \"explicit_single\", inputs };\n  }\n\n  // Deterministic bias/trend\n  const bias = (inputs.bias || \"\").toLowerCase();\n  if (bias.includes(\"bear\")) return { side: \"PUT\", source: \"technical_bias_pre_or_bias\", inputs };\n  if (bias.includes(\"bull\")) return { side: \"CALL\", source: \"technical_bias_pre_or_bias\", inputs };\n\n  const td = (inputs.trend || \"\").toLowerCase();\n  if (td.includes(\"down\")) return { side: \"PUT\", source: \"trend_direction_pre_or_trend\", inputs };\n  if (td.includes(\"up\")) return { side: \"CALL\", source: \"trend_direction_pre_or_trend\", inputs };\n\n  // derived_right fallback\n  const dr = (inputs.derived_right || \"\").toLowerCase();\n  if (dr === \"put\" || dr === \"p\") return { side: \"PUT\", source: \"derived_right\", inputs };\n  if (dr === \"call\" || dr === \"c\") return { side: \"CALL\", source: \"derived_right\", inputs };\n\n  // DMI vote fallback\n  function readDmi(tfObj) {\n    const latest = tfObj?.latest ?? tfObj?.dmi ?? null;\n    const diPlus = safeNum(latest?.diPlus ?? latest?.di_plus ?? latest?.plusDI ?? latest?.plus_di ?? latest?.diP ?? null);\n    const diMinus = safeNum(latest?.diMinus ?? latest?.di_minus ?? latest?.minusDI ?? latest?.minus_di ?? latest?.diM ?? null);\n    if (diPlus == null || diMinus == null) return null;\n    return { diPlus, diMinus };\n  }\n\n  function dmiVoteFrom(obj) {\n    const tfs = obj?.timeframes ?? obj?.intervals ?? null;\n    if (!tfs || typeof tfs !== \"object\") return null;\n    let bull = 0, bear = 0;\n    const seen = [];\n    for (const [k, v] of Object.entries(tfs)) {\n      const r = readDmi(v);\n      if (!r) continue;\n      const dir = r.diMinus > r.diPlus ? \"bear\" : r.diPlus > r.diMinus ? \"bull\" : \"flat\";\n      if (dir === \"bear\") bear++;\n      if (dir === \"bull\") bull++;\n      seen.push({ tf: k, diPlus: r.diPlus, diMinus: r.diMinus, dir });\n    }\n    if (!seen.length) return null;\n    return { bull, bear, seen };\n  }\n\n  const vote = dmiVoteFrom(base) || dmiVoteFrom(trendCtx);\n  if (vote) {\n    inputs.dmi_vote = vote;\n    if (vote.bear > vote.bull) return { side: \"PUT\", source: \"dmi_vote\", inputs };\n    if (vote.bull > vote.bear) return { side: \"CALL\", source: \"dmi_vote\", inputs };\n  }\n\n  return { side: null, source: \"unknown\", inputs };\n}\n\nfunction scoreCandidate(c, desiredSide) {\n  const side = normSide(c?.candidate_side) ?? normSide(c?.option_intent?.right) ?? null;\n\n  const passOk = c?.candidate_pass === true ? 1 : 0;\n  const liqOk = c?.option_liquidity_ok === true ? 1 : 0;\n  const sideMatch = desiredSide && side && side === desiredSide ? 1 : 0;\n\n  const rr = toNum(c?.option_risk_reward);\n  const rrScore = rr == null ? Number.NEGATIVE_INFINITY : rr;\n\n  const sp = toNum(c?.option_spread_pct);\n  const spScore = sp == null ? Number.POSITIVE_INFINITY : sp; // lower is better\n\n  const oi =\n    toInt(c?.selected?.open_interest) ??\n    toInt(c?.open_interest) ??\n    toInt(c?.selected?.oi) ??\n    null;\n  const oiScore = oi == null ? -1 : oi;\n\n  return { passOk, liqOk, sideMatch, rrScore, spScore, oiScore, side };\n}\n\nfunction better(a, b) {\n  const keys = [\"passOk\",\"liqOk\",\"sideMatch\",\"rrScore\",\"spScore\",\"oiScore\"];\n  for (const k of keys) {\n    if (a[k] === b[k]) continue;\n    if (k === \"spScore\") return a[k] < b[k]; // lower spread better\n    return a[k] > b[k];\n  }\n  return false;\n}\n\n// ---- main ----\nconst items = $input.all();\nconst candidates = items.map(i => i?.json).filter(isPlainObject);\n\nif (candidates.length === 0) {\n  return [{\n    json: { candidate_pass: false, winner_side: null, other_candidate: null, error: \"no_candidates\" }\n  }];\n}\n\n// keep best per side\nconst bySide = { CALL: null, PUT: null };\nfor (const c of candidates) {\n  const side = normSide(c?.candidate_side) ?? normSide(c?.option_intent?.right);\n  if (!side) continue;\n  if (!bySide[side]) bySide[side] = c;\n  else {\n    // choose better within same side (desired side doesn't matter much here; pass/liq/spread/oi dominate)\n    const s1 = scoreCandidate(c, null);\n    const s2 = scoreCandidate(bySide[side], null);\n    if (better(s1, s2)) bySide[side] = c;\n  }\n}\n\nlet callCand = bySide.CALL || null;\nlet putCand  = bySide.PUT  || null;\n\nif (!callCand && !putCand) {\n  const winner = candidates[0];\n  const out = { ...winner };\n  out.winner_side = normSide(out?.candidate_side) ?? null;\n  out.other_candidate = null;\n  const dm = inferDesiredMetaPair(winner, null);\n  out.candidate_compare = {\n    desired_side: dm.side,\n    desired_source: dm.source,\n    desired_inputs: dm.inputs,\n    candidates_seen: candidates.length,\n    sides_seen: candidates.map(c => normSide(c?.candidate_side) ?? null).filter(Boolean),\n    reason: \"no_side_labels_fell_back_to_first\"\n  };\n  return [{ json: out }];\n}\n\nconst desiredMeta = inferDesiredMetaPair(callCand, putCand);\nconst desiredSide = desiredMeta.side;\n\nif (!callCand || !putCand) {\n  const winner = callCand || putCand;\n  const out = { ...winner };\n  out.winner_side = normSide(winner?.candidate_side) ?? (callCand ? \"CALL\" : \"PUT\");\n  out.other_candidate = null;\n  out.candidate_compare = {\n    desired_side: desiredSide,\n    desired_source: desiredMeta.source,\n    desired_inputs: desiredMeta.inputs,\n    candidates_seen: candidates.length,\n    sides_seen: Object.entries(bySide).filter(([_,v]) => !!v).map(([k]) => k),\n    winner_side: out.winner_side,\n    other_side: null,\n    reason: \"single_side_available\",\n    call: callCand ? pickSubset(callCand) : null,\n    put: putCand ? pickSubset(putCand) : null,\n  };\n  return [{ json: out }];\n}\n\n// both sides exist\nconst sCall = scoreCandidate(callCand, desiredSide);\nconst sPut  = scoreCandidate(putCand, desiredSide);\n\nlet winner = callCand;\nlet loser  = putCand;\nlet reason = \"score_call_ge_put\";\nif (better(sPut, sCall)) {\n  winner = putCand;\n  loser = callCand;\n  reason = \"score_put_gt_call\";\n}\n\nconst out = { ...winner };\nout.winner_side = normSide(winner?.candidate_side) ?? null;\nout.other_candidate = pickSubset(loser);\n\nout.option_liquidity_ok =\n  (winner?.option_liquidity_ok === true || winner?.option_liquidity_ok === false)\n    ? winner.option_liquidity_ok\n    : out.option_liquidity_ok;\n\n// FIX: never keep a stale \"spread too wide\" reason when liquidity is OK\nif (out.option_liquidity_ok === true) {\n  out.option_liquidity_reason = null;\n} else {\n  out.option_liquidity_reason =\n    safeStr(winner?.option_liquidity_reason) ?? out.option_liquidity_reason ?? null;\n}\n\nout.candidate_compare = {\n  desired_side: desiredSide,\n  desired_source: desiredMeta.source,\n  desired_inputs: desiredMeta.inputs,\n  winner_side: out.winner_side,\n  other_side: normSide(loser?.candidate_side) ?? null,\n  reason,\n  call: pickSubset(callCand),\n  put: pickSubset(putCand),\n};\n\nreturn [{ json: out }];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        32512,
        33808
      ],
      "id": "1a6a3dd2-6a6c-4a1c-a6a5-f28be600fe78",
      "name": "Compare Candidates"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        31600,
        33808
      ],
      "id": "bc66387d-acea-4530-83e7-ad70efe60229",
      "name": "Merge1"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Merge orchestration result with risk config for Compute Size\n// Handles both NEW_ENTRY and ADD_POSITION.\n// ADD_POSITION = just buy more (same pipeline, qty override).\n\nlet orchResult = {};\nlet orchContext = {};\ntry {\n  const saved = $('Save Orchestration Decision').first().json;\n  orchResult = saved._orchestration_result || {};\n  orchContext = saved._orchestration || {};\n} catch (e) {\n  orchResult = $json._orchestration_result || {};\n  orchContext = $json._orchestration || {};\n}\n\nconst signalSummary = orchResult.signal_summary || {};\nconst posAction = orchResult.position_action || {};\nconst optionDetails = orchContext.signal_snapshot?.option_details || {};\nconst decisionType = orchResult.decision_type || null;\n\n// For ADD_POSITION, the orchestrator says qty_change (e.g. +1).\n// Skip the full conviction sizing \u2014 just buy that many more.\nconst isAdd = decisionType === 'ADD_POSITION';\nconst qtyOverride = isAdd ? Math.abs(posAction.qty_change || 1) : null;\n\n\n// ---- RISK GATE: Check portfolio risk before committing capital ----\n// Pass the risk_check result from orchestration context downstream.\n// The Compute Size node can use this to block oversized positions.\nlet riskCheck = null;\ntry {\n  const orchCtx = $('Save Orchestration Decision').first().json._orchestration || {};\n  riskCheck = orchCtx.risk_check || null;\n} catch {\n  riskCheck = null;\n}\n\nconst riskBlocked = riskCheck && riskCheck.allowed === false;\nconst riskBlockedReasons = riskBlocked ? (riskCheck.blocked_reasons || []) : [];\n\nreturn {\n  json: {\n    risk_config: { maxRiskPct: 0.5 },\n    option_decision: signalSummary.option_decision || null,\n    decision: decisionType,\n    option_entry_premium: optionDetails.entry_premium ?? null,\n    option_stop_premium: optionDetails.stop_premium ?? null,\n    option_take_profit_premium: optionDetails.tp_premium ?? null,\n    option_contract_symbol: signalSummary.contract || optionDetails.contract_symbol || null,\n    ai_confidence: orchResult.ai_confidence ?? null,\n    position_action: posAction,\n    signal_summary: signalSummary,\n    optionContext: {\n      quote: {\n        bid: optionDetails.bid ?? null,\n        ask: optionDetails.ask ?? null,\n        mid: optionDetails.mid ?? null,\n        spread_pct: optionDetails.spread_pct ?? null\n      }\n    },\n    _orchestration_result: orchResult,\n    _qty_override: qtyOverride,\n    _risk_check: riskCheck,\n    _risk_blocked: riskBlocked,\n    _risk_blocked_reasons: riskBlockedReasons\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        35824,
        33840
      ],
      "id": "86fdddc7-0fab-4805-9f7e-113015deb964",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "f2e23c00-7da6-4a99-9d0c-c618b5fc32cf",
              "leftValue": "={{ $json.option_decision != 'WAIT' }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        35392,
        33856
      ],
      "id": "fce95b93-fcfc-4f43-9e3b-67841ecf6ac8",
      "name": "If"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Code node: Enforce Desired Right + Slim Payload (before AI)\n// MODE: Run Once for Each Item\n//\n// Goal: reduce tokens sent into AI node by keeping only fields required by system schema/rules.\n\nfunction normRight(v) {\n  if (!v) return null;\n  const s = String(v).trim().toLowerCase();\n  if (s === \"call\" || s === \"c\") return \"call\";\n  if (s === \"put\" || s === \"p\") return \"put\";\n  return null;\n}\n\nfunction pick(obj, keys) {\n  const out = {};\n  for (const k of keys) {\n    if (obj && Object.prototype.hasOwnProperty.call(obj, k)) out[k] = obj[k];\n  }\n  return out;\n}\n\nfunction isObj(x) {\n  return x != null && typeof x === \"object\" && !Array.isArray(x);\n}\n\n// 1) Compute desired right from winner, fallback to existing desired_option_right\nconst winnerRight =\n  normRight($json.winner_right) ||\n  (String($json.winner_side || \"\").toUpperCase() === \"CALL\" ? \"call\" :\n   String($json.winner_side || \"\").toUpperCase() === \"PUT\" ? \"put\" : null);\n\nconst desiredRight = winnerRight || normRight($json.desired_option_right) || (() => {\n  // If Compare Candidates hasn't set desired right yet, infer from deterministic trend/bias or DMI alignment.\n  const td = String($json.trend_direction_pre || $json.trend_direction || \"\").toLowerCase();\n  const tb = String($json.technical_bias || \"\").toLowerCase();\n  if (td.includes(\"down\")) return \"put\";\n  if (td.includes(\"up\")) return \"call\";\n  if (tb === \"bearish\") return \"put\";\n  if (tb === \"bullish\") return \"call\";\n\n  const intervals = isObj($json.intervals) ? $json.intervals : null;\n  if (!intervals) return null;\n\n  let bull = 0;\n  let bear = 0;\n  for (const tf of Object.keys(intervals)) {\n    const dmi = intervals?.[tf]?.dmi;\n    const diPlus = Number.isFinite(+dmi?.diPlus) ? +dmi.diPlus : null;\n    const diMinus = Number.isFinite(+dmi?.diMinus) ? +dmi.diMinus : null;\n    if (diPlus == null || diMinus == null) continue;\n    if (diMinus > diPlus) bear += 1;\n    else if (diPlus > diMinus) bull += 1;\n  }\n  if (bear > bull && bear > 0) return \"put\";\n  if (bull > bear && bull > 0) return \"call\";\n  return null;\n})() || null;\n\n// 2) Minimize intervals payload (keep only what prompt uses)\nconst intervalsIn = isObj($json.intervals) ? $json.intervals : {};\nconst keepTFs = [\"5m\", \"3m\", \"2m\", \"1m\"];\nconst intervalsOut = {};\n\nfor (const tf of keepTFs) {\n  const tfObj = intervalsIn[tf];\n  if (!isObj(tfObj)) continue;\n\n  const dmiIn = isObj(tfObj.dmi) ? tfObj.dmi : null;\n  const demarkIn = isObj(tfObj.demark) ? tfObj.demark : null;\n  const priceIn = isObj(tfObj.price) ? tfObj.price : null;\n\n  intervalsOut[tf] = {\n    dmi: dmiIn\n      ? pick(dmiIn, [\"diPlus\", \"diMinus\", \"adx\"]) // drop \"td\" to save tokens (prompt says demark is separate)\n      : { diPlus: null, diMinus: null, adx: null },\n    demark: demarkIn ?? null,\n    price: priceIn\n      ? pick(priceIn, [\n          \"last_close\",\n          \"last_high\",\n          \"last_low\",\n          \"swing_high_n\",\n          \"swing_low_n\",\n          \"atr_n_sma\",\n          \"true_range_avg_n\"\n        ])\n      : null\n  };\n}\n\n// 3) Keep only the needed optionContext subfields\nlet optionContextOut = null;\nif (isObj($json.optionContext)) {\n  const oc = $json.optionContext;\n  optionContextOut = {\n    contract: isObj(oc.contract) ? pick(oc.contract, [\"symbol\", \"right\", \"expiration\", \"strike\"]) : null,\n    quote: isObj(oc.quote) ? pick(oc.quote, [\"bid\", \"ask\", \"mid\", \"spread_pct\"]) : null,\n    greeks: isObj(oc.greeks) ? pick(oc.greeks, [\"delta\", \"gamma\", \"theta\", \"vega\", \"iv\"]) : null\n    // trade dropped (not required by schema/rules); add back if you truly need it\n  };\n}\n\n// 4) max_spread_pct: keep as top-level scalar (avoid shipping whole option_intent)\nconst maxSpreadPct =\n  (isObj($json.option_intent) && typeof $json.option_intent.max_spread_pct === \"number\")\n    ? $json.option_intent.max_spread_pct\n    : (typeof $json.max_spread_pct === \"number\" ? $json.max_spread_pct : null);\n\n// 5) Build slim payload\nconst out = {\n  ticker: $json.ticker ?? null,\n  overall_timeframe: $json.overall_timeframe ?? null,\n\n  intervals: intervalsOut,\n\n  // underlying levels\n  trigger_price: $json.trigger_price ?? null,\n  invalidation_level: $json.invalidation_level ?? null,\n  target_level: $json.target_level ?? null,\n\n  // gates\n  time_gate_ok: $json.time_gate_ok ?? null,\n  time_gate_reason: $json.time_gate_reason ?? null,\n  option_liquidity_ok: $json.option_liquidity_ok ?? null,\n  option_liquidity_reason: $json.option_liquidity_reason ?? null,\n\n  // trend/confidence (authoritative)\n  confidence_pre: $json.confidence_pre ?? null,\n  confidencePct_pre: $json.confidencePct_pre ?? null,\n  trend_direction_pre: $json.trend_direction_pre ?? null,\n  trend_strength_pre: $json.trend_strength_pre ?? null,\n  trend_strength_score_pre: $json.trend_strength_score_pre ?? null,\n  alignment_pre: $json.alignment_pre ?? null,\n  adx_confirmation_pre: $json.adx_confirmation_pre ?? null,\n\n  // option side + contract + pricing\n  desired_option_right: desiredRight,\n  option_right: $json.option_right ?? desiredRight ?? null, // small helper for your prompt\u2019s fallback chain\n  option_contract_symbol: $json.option_contract_symbol ?? null,\n\n  // quote + greeks\n  optionContext: optionContextOut,\n\n  // premiums / RR (copy-through)\n  option_entry_premium: $json.option_entry_premium ?? null,\n  option_stop_premium: $json.option_stop_premium ?? null,\n  option_take_profit_premium: $json.option_take_profit_premium ?? null,\n  option_risk_reward: $json.option_risk_reward ?? null,\n\n  // spread limit scalar\n  max_spread_pct: maxSpreadPct\n};\n\nreturn { json: out };\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        34288,
        33664
      ],
      "id": "faccaf5d-7e55-4958-a52f-ead9e9cf4c50",
      "name": "Enforce Desired Right"
    },
    {
      "parameters": {
        "jsCode": "// Code node: Compute Option Metrics (Gamma scalp helper)\n// MODE: Run Once for Each Item\n// Adds intrinsic/extrinsic/theta% and simple expected-move.\n// Expects optionContext from Enrich Payload for AI.\n\nfunction n(x) {\n  const v = (typeof x === 'string') ? Number.parseFloat(x) : x;\n  return (typeof v === 'number' && Number.isFinite(v)) ? v : null;\n}\nfunction clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }\n\nconst j = ($json && typeof $json === 'object') ? $json : {};\nconst oc = j.optionContext || {};\nconst c = oc.contract || {};\nconst q = oc.quote || {};\nconst g = oc.greeks || {};\n\nconst right = (c.right || '').toString().toLowerCase();\nconst strike = n(c.strike);\nconst mid = n(q.mid) ?? n(j.option_mid) ?? n(j.option_entry_premium);\n\nconst underlying =\n  n(j.underlying_last) ??\n  n(j.underlying_price) ??\n  n(j.trigger_price) ??\n  n(j?.intervals?.['60m']?.price?.last_close) ??\n  n(j?.intervals?.['15m']?.price?.last_close) ??\n  n(j?.intervals?.['1m']?.price?.last_close) ??\n  null;\n\n// DTE (calendar days)\nlet dte_days = null;\nif (c.expiration) {\n  const exp = new Date(String(c.expiration).slice(0, 10) + \"T00:00:00Z\").getTime();\n  const now = Date.now();\n  if (Number.isFinite(exp)) {\n    dte_days = Math.max(0, Math.round((exp - now) / (24*60*60*1000)));\n  }\n}\n\nlet intrinsic = null;\nlet extrinsic = null;\nlet extrinsic_pct = null;\n\nif (underlying != null && strike != null && mid != null) {\n  if (right === 'call') intrinsic = Math.max(0, underlying - strike);\n  else if (right === 'put') intrinsic = Math.max(0, strike - underlying);\n\n  extrinsic = mid - (intrinsic ?? 0);\n  extrinsic_pct = (mid > 0) ? clamp(extrinsic / mid, -5, 5) : null;\n}\n\nconst delta = n(g.delta);\nconst gamma = n(g.gamma);\nconst theta = n(g.theta);\nconst vega  = n(g.vega);\nconst iv    = n(g.iv);\n\n// theta \u201ccost\u201d as % of premium per day\nconst theta_pct_per_day = (mid != null && mid > 0 && theta != null)\n  ? clamp((-theta) / mid, -5, 5)\n  : null;\n\n// simple expected move to expiry from IV (calendar)\nconst expected_move_to_exp = (underlying != null && iv != null && dte_days != null)\n  ? underlying * iv * Math.sqrt(Math.max(dte_days, 1) / 365)\n  : null;\n\nreturn {\n  json: {\n    ...j,\n    optionMetrics: {\n      underlying,\n      right: right || null,\n      strike,\n      mid,\n      dte_days,\n      intrinsic,\n      extrinsic,\n      extrinsic_pct,\n      delta,\n      gamma,\n      theta,\n      theta_pct_per_day,\n      vega,\n      iv,\n      expected_move_to_exp,\n    }\n  }\n};"
      },
      "id": "25549f3f-e9bb-4ed6-affa-e4fe22974d2e",
      "name": "Compute Option Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        33424,
        33792
      ]
    },
    {
      "parameters": {
        "jsCode": "// Code node: Compute Option ATR Stops/TP (Gamma scalp)\n// MODE: Run Once for Each Item\n// Merges option bars response back into the enriched payload and computes ATR-based stop/TP.\n//\n// Assumes upstream node name: \"Compute Option Metrics\"\n// Assumes current $json is the response from Get Option Bars (likely { bars: {SYM:[...]} } )\n\nfunction n(x) {\n  const v = (typeof x === 'string') ? Number.parseFloat(x) : x;\n  return (typeof v === 'number' && Number.isFinite(v)) ? v : null;\n}\nfunction round2(x){ return (x == null) ? null : Math.round(x * 100) / 100; }\n\n// Pull full payload from Compute Option Metrics (to preserve context)\nconst base = ($items(\"Compute Option Metrics\")?.[0]?.json && typeof $items(\"Compute Option Metrics\")[0].json === \"object\")\n  ? $items(\"Compute Option Metrics\")[0].json\n  : (typeof $json === \"object\" ? $json : {});\n\nconst resp = (typeof $json === \"object\" && $json) ? $json : {};\n\nconst sym = (base.option_contract_symbol || base?.optionContext?.contract?.symbol || '').toString().toUpperCase();\n\n// Get bars map\nconst barsMap = resp?.bars ?? resp?.data?.bars ?? resp?.optionBars ?? resp ?? null;\n\n// Extract bars array\nconst bars = (barsMap && sym && Array.isArray(barsMap[sym])) ? barsMap[sym]\n  : (Array.isArray(resp?.bars) ? resp.bars : null);\n\nif (!Array.isArray(bars) || bars.length < 15) {\n  return {\n    json: {\n      ...base,\n      optionStops: {\n        reason: \"Not enough option bars to compute ATR\",\n        atr: null,\n        entry: base?.option_mid ?? base?.option_entry_premium ?? null,\n        stop: null,\n        tp: null,\n        rr: null\n      }\n    }\n  };\n}\n\n// ATR (simple average TR) over last N bars\nconst N = Math.min(14, bars.length - 1);\nlet trs = [];\nfor (let i = bars.length - N; i < bars.length; i++) {\n  const cur = bars[i];\n  const prev = bars[i - 1];\n  const h = n(cur.h), l = n(cur.l), pc = n(prev.c);\n  if (h == null || l == null || pc == null) continue;\n  const tr = Math.max(h - l, Math.abs(h - pc), Math.abs(l - pc));\n  trs.push(tr);\n}\nconst atr = trs.length ? (trs.reduce((a,b)=>a+b,0) / trs.length) : null;\n\n// Entry from current quote mid if available; else last close\nconst entry =\n  n(base?.optionContext?.quote?.mid) ??\n  n(base?.option_mid) ??\n  n(base?.option_entry_premium) ??\n  n(bars[bars.length - 1]?.c) ??\n  null;\n\nif (atr == null || entry == null) {\n  return {\n    json: {\n      ...base,\n      optionStops: {\n        reason: \"Missing ATR or entry\",\n        atr: round2(atr),\n        entry: round2(entry),\n        stop: null,\n        tp: null,\n        rr: null\n      }\n    }\n  };\n}\n\n// Gamma scalp multipliers\nconst STOP_ATR = 0.8;\nconst TP_ATR   = 1.6;\n\nconst stop = Math.max(0.01, entry - STOP_ATR * atr);\nconst tp   = entry + TP_ATR * atr;\n\nconst risk = entry - stop;\nconst reward = tp - entry;\nconst rr = (risk > 0) ? (reward / risk) : null;\n\n// Clean bars out of payload to keep tokens down; keep a tiny summary\nconst bars_summary = {\n  symbol: sym || null,\n  timeframe: \"1Min\",\n  bars_used: bars.length,\n  last_bar_time: bars[bars.length - 1]?.t ?? null\n};\n\nreturn {\n  json: {\n    ...base,\n    option_entry_premium: round2(entry),\n    option_stop_premium: round2(stop),\n    option_take_profit_premium: round2(tp),\n    option_risk_reward: (rr == null) ? null : Number(rr.toFixed(2)),\n    optionStops: {\n      atr: round2(atr),\n      stop_atr: STOP_ATR,\n      tp_atr: TP_ATR,\n      bars_summary\n    }\n  }\n};"
      },
      "id": "82270016-4895-4096-9a4f-a9abc7fda2ff",
      "name": "Compute Option ATR Stops/TP",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        33840,
        33792
      ]
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: Compute Synthetic Option Stops/TP (Delta-Gamma)\n// MODE: Run Once for Each Item\n//\n// Requires from upstream payload (your \"Compute Option Metrics\" output typically has these):\n// - trigger_price, invalidation_level, target_level  (underlying levels)\n// - option_bid / option_ask / option_mid\n// - option_delta, option_gamma (or optionMetrics.delta/gamma)\n//\n// Produces: option_entry_premium, option_stop_premium, option_take_profit_premium, option_risk_reward\n\nfunction n(x) {\n  const v = (typeof x === 'string') ? Number.parseFloat(x) : x;\n  return (typeof v === 'number' && Number.isFinite(v)) ? v : null;\n}\nfunction round2(x){ return (x == null) ? null : Math.round(x * 100) / 100; }\n\nconst base = ($json && typeof $json === 'object') ? $json : {};\n\nconst S0   = n(base.trigger_price) ?? n(base.underlying_last) ?? n(base?.optionMetrics?.underlying) ?? null;\nconst Sinv = n(base.invalidation_level);\nconst Stgt = n(base.target_level);\n\nconst bid = n(base.option_bid);\nconst ask = n(base.option_ask);\nconst mid = n(base.option_mid) ?? (bid != null && ask != null ? (bid + ask) / 2 : null);\n\n// Use ask as entry for long option (more conservative)\nconst entry = (ask != null) ? ask : mid;\n\nconst delta = n(base.option_delta) ?? n(base?.optionMetrics?.delta);\nconst gamma = n(base.option_gamma) ?? n(base?.optionMetrics?.gamma);\n\n// Helper: delta-gamma approximation around current price\nfunction approxPremiumAt(S) {\n  if (entry == null || S0 == null || S == null || delta == null) return null;\n  const dS = S - S0;\n  const gTerm = (gamma != null) ? (0.5 * gamma * dS * dS) : 0;\n  return entry + (delta * dS) + gTerm;\n}\n\nlet stop = approxPremiumAt(Sinv);\nlet tp   = approxPremiumAt(Stgt);\n\n// Basic sanity clamps for a long premium trade:\nif (entry != null && stop != null) stop = Math.min(stop, entry - 0.01);\nif (entry != null && tp   != null) tp   = Math.max(tp,   entry + 0.01);\n\nif (stop != null) stop = Math.max(0.01, stop);\nif (tp   != null) tp   = Math.max(0.01, tp);\n\nlet rr = null;\nif (entry != null && stop != null && tp != null) {\n  const risk = entry - stop;\n  const reward = tp - entry;\n  rr = (risk > 0) ? (reward / risk) : null;\n}\n\nreturn [{\n  json: {\n    ...base,\n    option_entry_premium: round2(entry),\n    option_stop_premium: round2(stop),\n    option_take_profit_premium: round2(tp),\n    option_risk_reward: (rr == null) ? null : Number(rr.toFixed(2)),\n    optionStops: {\n      method: \"delta_gamma_from_underlying_levels\",\n      S0, Sinv, Stgt,\n      delta, gamma\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        33632,
        33792
      ],
      "id": "e0befa26-2af9-4d1e-813b-a6f6ba7e561b",
      "name": "Replace Get Option Bars (Selected)"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "*/5 12-20 * * 1-5"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        27888,
        34160
      ],
      "id": "c655a964-fa75-4902-95bd-6d0c7fc72bfd",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "6c11be1f-35aa-46d2-bf42-a118e3d72a11",
              "leftValue": "={{ $json.confidence_pre > 0.65 }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        34432,
        33504
      ],
      "id": "222b0f69-759c-4a00-8efc-29010a590bfd",
      "name": "If1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        32224,
        34064
      ],
      "id": "3afcec1c-c16e-4eef-92cc-752764f46655",
      "name": "Merge Snapshots (Keep Input)"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        35824,
        33648
      ],
      "id": "1cfaf696-1a8c-409d-82bc-b33208792ff3",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "yxVkFtwSghktPWAk",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "123"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        35920,
        33648
      ],
      "id": "b1b2baf0-5499-4b2f-a48c-dd9e04916bac",
      "name": "Simple Memory1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "55a6b297-6931-4c52-8ebe-719f2ec4999a",
              "leftValue": "={{ $json.output.verdict = \"OK\"}}\n\n",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        36336,
        33456
      ],
      "id": "1cbcad7e-2b45-494c-b53c-84f141d041b9",
      "name": "If3"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Ticker: {{$json.ticker}}\n\nRuntime payload (authoritative JSON):\n{{ JSON.stringify($json, null, 2) }}\n\nVerification tasks:\n\nValidate time_gate_ok and option_liquidity_ok are respected by final decision.\n\nValidate technical_bias vs selected option right and contract symbol (C/P).\n\nValidate candidate comparison includes both CALL+PUT when force_right=false (if present).\n\nValidate RR threshold logic (UPDATED): rr_threshold is a reference unless RR is way too low (see below).\n\nCompute underlying R:R if trigger/invalidation/target exist.\n\nReturn STRICT JSON in the required schema.\n\nRR THRESHOLD LOGIC (UPDATED \u2014 reference-first):\n\nTreat option_risk_reward (and any RR threshold like rr_threshold/default 1.8) as a reference/diagnostic metric, NOT a normal gating rule.\n\nDo NOT fail/flag a decision as invalid solely because option_risk_reward < 1.8 (or < rr_threshold) if gates and other rules allow BUY.\n\nOnly treat RR as a decisive gating/verification failure when it is WAY too low:\n\nIf option_risk_reward exists AND option_risk_reward < 0.6:\n\nThe decision MUST be WAIT.\n\nIf the report/decision is BUY anyway, log a CRITICAL issue code RR_WAY_TOO_LOW.\n\nOtherwise (RR >= 0.6 or missing): RR may be reported as INFO/WARNING for awareness, but must NOT be used to mark the decision as incorrect.\n\nOPTIONAL CHECK (NEW):\n\nIf payload.timeframes[*].hammer.present is true, ensure the final report (text) does not contradict it.\n\nDo not fail if hammer is omitted from text; treat as info unless the report claims the opposite.\n\nIf payload.timeframes[*].bullish_engulfing.present is true, ensure the final report (text) does not contradict it.\n\nDo not fail if engulfing is omitted from text; treat as info unless the report claims the opposite.\n\nINDICATOR VALIDATION (NEW, REQUIRED):\n\nThe Telegram report text is in payload field $json.text (string).\n\nValidate that the report\u2019s indicator statements (if present) do NOT contradict payload indicators for 60m/15m/1m.\n\nIndicators to validate:\nA) DMI: compare report bullish/bearish wording vs payload.timeframes[tf].dmi.diPlus and diMinus (bullish if diPlus>diMinus, bearish if diMinus>diPlus).\nB) TD Sequential: compare report setupDir/setupCount and countdownDir/countdownCount vs payload.timeframes[tf].demark.* (if the report includes these numbers/directions).\nC) Hammer: compare report Hammer line vs payload.timeframes[tf].hammer.{present,type}.\nD) Bullish Engulfing: compare report BullishEngulfing/Engulfing line vs payload.timeframes[tf].bullish_engulfing.{present,type}.\nE) Bearish Engulfing: compare report BearishEngulfing/Bearish Engulfing line vs payload.timeframes[tf].bearish_engulfing.{present,type}.\nF) Shooting Star: compare report ShootingStar/Shooting Star line vs payload.timeframes[tf].shooting_star.{present,type}.\n\nIf the report omits an indicator section while payload has it, log an INFO issue (do not fail) EXCEPT Hammer: if any hammer.present===true and report has no Hammer section, log WARNING issue code HAMMER_SECTION_MISSING.\n\nIf any bullish_engulfing.present===true and report has no BullishEngulfing/Engulfing section, log WARNING issue code BULLISH_ENGULFING_SECTION_MISSING.\n\nIf any bearish_engulfing.present===true and report has no BearishEngulfing/Bearish Engulfing section, log WARNING issue code BEARISH_ENGULFING_SECTION_MISSING.\n\nIf any shooting_star.present===true and report has no ShootingStar/Shooting Star section, log WARNING issue code SHOOTING_STAR_SECTION_MISSING.\n\nIf the report explicitly claims the opposite of payload (e.g., says \"Hammer 15m: none\" but payload says present), log CRITICAL issue code INDICATOR_CONTRADICTION.\n",
        "options": {
          "systemMessage": "=You are a multi-timeframe DAY-TRADING OPTIONS verifier for an automated n8n workflow.\n\nYour job:\n\nValidate internal consistency of the trading decision pipeline (bias/trend vs chosen option right, candidate compare, liquidity gating, RR logic).\n\nDetect contradictions, missing fields, and schema drift.\n\nRecompute ONLY \"derived verification metrics\" (e.g., underlying R:R from provided levels, option spread %, quote age checks if timestamps exist).\n\nNEVER recompute or override upstream deterministic fields (trend_direction, trend_strength_score, technical_bias, confidence, trigger/invalidation/target) \u2014 treat them as authoritative if present.\n\nNever invent missing values. Use null and log a validation issue.\n\nSOURCE OF TRUTH:\n\nThe runtime JSON payload you receive is the ONLY source of truth.\n\nIf a separate text report is provided, treat it as \"presentation output\" that may be wrong; verify it against the payload.\n\nHARD RULES:\n\nOutput STRICT JSON ONLY. No markdown. No extra commentary.\n\nIf payload is missing/unrendered, return:\n{\n\"verdict\": \"WAIT\",\n\"severity\": \"critical\",\n\"issues\": [{\"code\":\"PAYLOAD_MISSING\",\"severity\":\"critical\",\"message\":\"Payload missing or not rendered\",\"evidence\":null}],\n\"computed\": {},\n\"recommendations\": []\n}\n\nDecision logic for verification (do NOT change the trade decision, only verify):\n\nIf time_gate_ok === false -> decision must be WAIT. Flag if not.\n\nIf option_liquidity_ok === false -> decision must be WAIT. Flag if not.\n\nIf technical_bias is bearish -> preferred option right should be \"put\".\n\nIf technical_bias is bullish -> preferred option right should be \"call\".\n\nIf a \"winner/right\" is opposite of bias and there is no explicit reversal_mode flag -> flag mismatch.\n\nRR LOGIC (UPDATED \u2014 reference-first):\n\nTreat option_risk_reward and rr_threshold (default 1.8 unless provided) as reference/diagnostic metrics, NOT normal gating rules.\n\nDo NOT flag a decision as invalid solely because option_risk_reward < rr_threshold (or < 1.8) if other gates/consistency rules are satisfied.\n\nOnly enforce RR as a decisive gating/verification rule when it is WAY too low:\n\nIf option_risk_reward is present AND option_risk_reward < 0.6 -> decision should be WAIT. Flag if not.\n\nIf option_risk_reward is missing or >= 0.6 -> rr_threshold_respected_ok should be null (or true if you explicitly treat it as \u201cnot violated\u201d), and any note about RR should be INFO/WARNING only (not a mismatch driver).\n\nUnderlying R:R is computable if trigger_price, invalidation_level, target_level exist:\nrisk = abs(entry - stop)\nreward = abs(entry - target)\nrr = reward / risk (if risk > 0)\nDirection handling:\n- If bias bearish: entry=trigger_price, stop=invalidation_level (above), target=target_level (below)\n- If bias bullish: entry=trigger_price, stop=invalidation_level (below), target=target_level (above)\n\nOutput JSON schema (MUST follow exactly):\n{\n\"verdict\": \"OK\" | \"WAIT\" | \"MISMATCH\" | \"ERROR\",\n\"severity\": \"info\" | \"warning\" | \"critical\",\n\"summary\": {\n\"ticker\": string|null,\n\"timeframes\": string|null,\n\"technical_bias\": \"bearish\"|\"bullish\"|null,\n\"trend_direction\": string|null,\n\"confidence\": number|null,\n\"selected_option_right\": \"call\"|\"put\"|null,\n\"selected_contract\": string|null,\n\"decision\": string|null\n},\n\"computed\": {\n\"underlying_rr\": number|null,\n\"underlying_risk\": number|null,\n\"underlying_reward\": number|null\n},\n\"consistency\": {\n\"bias_vs_selected_right_ok\": boolean|null,\n\"gates_respected_ok\": boolean|null,\n\"rr_threshold_respected_ok\": boolean|null,\n\"candidate_compare_has_both_sides\": boolean|null\n},\n\"issues\": [\n{\n\"code\": string,\n\"severity\": \"info\"|\"warning\"|\"critical\",\n\"message\": string,\n\"evidence\": object|null\n}\n],\n\"recommendations\": [\n{\n\"action\": string,\n\"why\": string,\n\"where\": string|null,\n\"patch_hint\": string|null\n}\n],\n\"suggested_corrections\": {\n\"preferred_option_right\": \"call\"|\"put\"|null,\n\"suggested_winner_right\": \"call\"|\"put\"|null,\n\"reason\": string|null\n}\n}\n\nEvidence rules:\n\nEvidence should quote relevant payload fields (small objects) such as:\n{ \"technical_bias\": \"...\", \"selected_option_right\": \"...\", \"option_contract_symbol\": \"...\", \"option_risk_reward\": 1.4 }\n\nDo not include the entire payload in evidence.\n\nIf contradictions exist:\n\nverdict = \"MISMATCH\"\n\nseverity = \"warning\" or \"critical\" depending on impact (wrong-side selection is critical).\n\nIndicator text validation:\n\nIf a presentation text report is provided (payload.text), cross-check it against payload indicators.\n\nPrefer payload fields over any prose.\n\nHammer consistency: if payload.timeframes[tf].hammer.present is true and the report has no Hammer section, raise a WARNING (HAMMER_SECTION_MISSING).\n\nDMI/TD/Hammer contradictions in text vs payload are CRITICAL (INDICATOR_CONTRADICTION).\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        35824,
        33456
      ],
      "id": "203d86ab-48e5-4ca6-9e58-ba288485ca60",
      "name": "Day Trade Report Validation"
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{$json.telegram_text.replace(/_/g,'\\\\_')}}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        36880,
        33600
      ],
      "id": "de5e488e-7204-4b42-a138-ff930496c4ce",
      "name": "Send a text message1",
      "webhookId": "f0e18d53-5a73-4e3a-b9f7-6d6bc8d2924f",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: Render Verification JSON -> Telegram\n// MODE: Run Once for Each Item\n//\n// Input can be either:\n//  A) $json is already the verification object: { verdict, severity, summary, ... }\n//  B) $json.output (or verification_output/report) is a JSON string containing that object\n//\n// Output:\n// - telegram_text (string) ready for Telegram Send Message node\n// - preserves original fields by passing through\n\nfunction isPlainObject(x) {\n  return x != null && typeof x === \"object\" && !Array.isArray(x);\n}\n\nfunction safeNum(x) {\n  if (typeof x === \"number\" && Number.isFinite(x)) return x;\n  if (typeof x === \"string\") {\n    const n = Number.parseFloat(x);\n    return Number.isFinite(n) ? n : null;\n  }\n  return null;\n}\n\nfunction fmtNum(x, digits = 2) {\n  const n = safeNum(x);\n  if (n == null) return \"n/a\";\n  return n.toFixed(digits);\n}\n\nfunction pct(x, digits = 1) {\n  const n = safeNum(x);\n  if (n == null) return \"n/a\";\n  return (n * 100).toFixed(digits) + \"%\";\n}\n\nfunction fmtBool(x) {\n  if (x === true) return \"\u2705\";\n  if (x === false) return \"\u274c\";\n  return \"n/a\";\n}\n\nfunction fmtRight(r) {\n  if (!r) return \"n/a\";\n  const s = String(r).toLowerCase();\n  if (s === \"call\") return \"CALL\";\n  if (s === \"put\") return \"PUT\";\n  return s.toUpperCase();\n}\n\nfunction verdictEmoji(verdict, severity) {\n  const v = (verdict || \"\").toUpperCase();\n  const s = (severity || \"\").toLowerCase();\n\n  if (v === \"ERROR\") return \"\ud83d\uded1\";\n  if (v === \"MISMATCH\") return \"\u26a0\ufe0f\";\n  if (v === \"WAIT\") return \"\ud83d\udfe1\";\n  if (v === \"OK\") {\n    if (s === \"warning\") return \"\ud83d\udfe0\";\n    if (s === \"critical\") return \"\ud83d\udd34\";\n    return \"\ud83d\udfe2\";\n  }\n  return \"\u2139\ufe0f\";\n}\n\nfunction pick(obj, path, fallback = null) {\n  try {\n    const parts = path.split(\".\");\n    let cur = obj;\n    for (const p of parts) {\n      if (!isPlainObject(cur) && !Array.isArray(cur)) return fallback;\n      cur = cur[p];\n      if (cur === undefined) return fallback;\n    }\n    return cur == null ? fallback : cur;\n  } catch {\n    return fallback;\n  }\n}\n\nfunction clampIssues(arr) {\n  if (!Array.isArray(arr)) return [];\n  return arr.filter(Boolean).slice(0, 8); // keep message short\n}\n\nfunction clampRecs(arr) {\n  if (!Array.isArray(arr)) return [];\n  return arr.filter(Boolean).slice(0, 6);\n}\n\nfunction stripCodeFences(s) {\n  if (typeof s !== \"string\") return s;\n  let t = s.trim();\n  t = t.replace(/^```(?:json)?\\s*/i, \"\");\n  t = t.replace(/\\s*```$/i, \"\");\n  return t.trim();\n}\n\n// Parse JSON safely; if parse fails, try extracting minimal fields with regex.\nfunction parseMaybeJson(raw) {\n  if (raw == null) return null;\n  if (isPlainObject(raw)) return raw;\n\n  if (typeof raw === \"string\") {\n    const t = stripCodeFences(raw);\n    try {\n      const obj = JSON.parse(t);\n      return isPlainObject(obj) ? obj : null;\n    } catch {\n      // fallback: try to extract just verdict/severity minimally\n      const verdict = (t.match(/\"verdict\"\\s*:\\s*\"([^\"]+)\"/i) || [])[1] || null;\n      const severity = (t.match(/\"severity\"\\s*:\\s*\"([^\"]+)\"/i) || [])[1] || null;\n      if (verdict || severity) return { verdict, severity };\n      return null;\n    }\n  }\n  return null;\n}\n\n// --- Resolve the actual verification object ---\nconst root = isPlainObject($json) ? $json : {};\nconst raw =\n  root.output ??\n  root.verification_output ??\n  root.report ??\n  null;\n\n// If $json itself already looks like a report, prefer it; else parse the nested raw.\nlet data = null;\nif (root && (root.verdict || root.summary || root.computed || root.consistency)) {\n  data = root;\n} else {\n  data = parseMaybeJson(raw) || {};\n}\n\n// --- Pull fields ---\nconst verdict = pick(data, \"verdict\", null);\nconst severity = pick(data, \"severity\", null);\n\nconst ticker = pick(data, \"summary.ticker\", null);\nconst tfs = pick(data, \"summary.timeframes\", null);\nconst bias = pick(data, \"summary.technical_bias\", null);\nconst trendDir = pick(data, \"summary.trend_direction\", null);\nconst conf = safeNum(pick(data, \"summary.confidence\", null));\nconst selRight = pick(data, \"summary.selected_option_right\", null);\nconst selContract = pick(data, \"summary.selected_contract\", null);\nconst decision = pick(data, \"summary.decision\", null);\n\nconst rr = safeNum(pick(data, \"computed.underlying_rr\", null));\nconst risk = safeNum(pick(data, \"computed.underlying_risk\", null));\nconst reward = safeNum(pick(data, \"computed.underlying_reward\", null));\n\nconst c_biasRight = pick(data, \"consistency.bias_vs_selected_right_ok\", null);\nconst c_gates = pick(data, \"consistency.gates_respected_ok\", null);\nconst c_rr = pick(data, \"consistency.rr_threshold_respected_ok\", null);\nconst c_both = pick(data, \"consistency.candidate_compare_has_both_sides\", null);\n\nconst issues = clampIssues(pick(data, \"issues\", []));\nconst recs = clampRecs(pick(data, \"recommendations\", []));\n\nconst prefRight = pick(data, \"suggested_corrections.preferred_option_right\", null);\nconst sugWinRight = pick(data, \"suggested_corrections.suggested_winner_right\", null);\nconst corrReason = pick(data, \"suggested_corrections.reason\", null);\n\n// --- Render (Telegram-friendly) ---\nconst lines = [];\n\nlines.push(`${verdictEmoji(verdict, severity)} Verification: ${verdict || \"n/a\"} (${severity || \"n/a\"})`);\n\nif (ticker || tfs) {\n  lines.push(`Ticker: ${ticker || \"n/a\"} | TF: ${tfs || \"n/a\"}`);\n}\n\nlines.push(\n  `Bias: ${bias ? String(bias).toUpperCase() : \"n/a\"} | Trend: ${trendDir || \"n/a\"} | Conf: ${conf == null ? \"n/a\" : pct(conf, 0)}`\n);\n\nlines.push(\n  `Decision: ${decision || \"n/a\"} | Selected: ${fmtRight(selRight)} | Contract: ${selContract || \"n/a\"}`\n);\n\nlines.push(\n  `Underlying R:R: ${rr == null ? \"n/a\" : fmtNum(rr, 2)} (risk ${risk == null ? \"n/a\" : fmtNum(risk, 2)}, reward ${reward == null ? \"n/a\" : fmtNum(reward, 2)})`\n);\n\nlines.push(\"\");\nlines.push(\"Consistency:\");\nlines.push(`\u2022 Bias vs Selected Right: ${fmtBool(c_biasRight)}`);\nlines.push(`\u2022 Gates Respected: ${fmtBool(c_gates)}`);\nlines.push(`\u2022 RR Threshold Respected: ${fmtBool(c_rr)}`);\nlines.push(`\u2022 Both Sides Present: ${fmtBool(c_both)}`);\n\n// Issues\nif (issues.length) {\n  lines.push(\"\");\n  lines.push(`Issues (${issues.length}):`);\n  for (const it of issues) {\n    const code = it?.code ? String(it.code) : \"UNKNOWN\";\n    const sev = it?.severity ? String(it.severity) : \"info\";\n    const msg = it?.message ? String(it.message) : \"\";\n    const icon = sev === \"critical\" ? \"\ud83d\uded1\" : sev === \"warning\" ? \"\u26a0\ufe0f\" : \"\u2139\ufe0f\";\n    const clipped = msg.length > 170 ? msg.slice(0, 167) + \"\u2026\" : msg;\n    lines.push(`\u2022 ${icon} ${code}: ${clipped}`);\n  }\n}\n\n// Suggested corrections\nif (prefRight || sugWinRight || corrReason) {\n  lines.push(\"\");\n  lines.push(\"Suggested corrections:\");\n  if (prefRight) lines.push(`\u2022 Preferred Right: ${fmtRight(prefRight)}`);\n  if (sugWinRight) lines.push(`\u2022 Suggested Winner: ${fmtRight(sugWinRight)}`);\n  if (corrReason) {\n    const cr = String(corrReason);\n    const clipped = cr.length > 220 ? cr.slice(0, 217) + \"\u2026\" : cr;\n    lines.push(`\u2022 Reason: ${clipped}`);\n  }\n}\n\n// Recommendations\nif (recs.length) {\n  lines.push(\"\");\n  lines.push(`Recommendations (${recs.length}):`);\n  for (const r of recs) {\n    const action = r?.action ? String(r.action) : \"Action\";\n    const why = r?.why ? String(r.why) : \"\";\n    const where = r?.where ? String(r.where) : null;\n\n    let line = `\u2022 ${action}`;\n    if (where) line += ` (@${where})`;\n    if (why) {\n      const clipped = why.length > 180 ? why.slice(0, 177) + \"\u2026\" : why;\n      line += ` \u2014 ${clipped}`;\n    }\n    lines.push(line);\n  }\n}\n\n// Final telegram text (avoid huge messages)\nlet telegram_text = lines.join(\"\\n\").trim();\nif (telegram_text.length > 3500) {\n  telegram_text = telegram_text.slice(0, 3490) + \"\\n\u2026(truncated)\";\n}\n\nreturn {\n  json: {\n    ...root,          // preserve original wrapper fields (e.g., output string)\n    ...data,          // also expose parsed fields at top-level for downstream nodes\n    telegram_text,\n  },\n};\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        36704,
        33600
      ],
      "id": "466e505e-2943-4b2f-b0ad-9ef280508a51",
      "name": "Render Verification Report"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// n8n Code node: Parse AI Agent Output -> JSON\n// MODE: Run Once for Each Item\n//\n// Input:  $json.output is a STRING that contains JSON (sometimes wrapped in ```json fences)\n// Output: $json.output becomes an OBJECT, and also sets:\n//   - output_text (original string)\n//   - output_parse_ok (boolean)\n//   - output_parse_error (string|null)\n\nfunction stripCodeFences(s) {\n  if (typeof s !== 'string') return s;\n  return s\n    .trim()\n    .replace(/^```(?:json)?\\s*/i, '')\n    .replace(/\\s*```$/i, '')\n    .trim();\n}\n\nfunction tryParseJsonString(s) {\n  const t = stripCodeFences(s);\n\n  // 1) normal JSON.parse\n  try {\n    return { ok: true, value: JSON.parse(t), error: null };\n  } catch (e1) {}\n\n  // 2) fallback: extract first {...} block\n  try {\n    const start = t.indexOf('{');\n    const end = t.lastIndexOf('}');\n    if (start >= 0 && end > start) {\n      const slice = t.slice(start, end + 1);\n      return { ok: true, value: JSON.parse(slice), error: null };\n    }\n  } catch (e2) {}\n\n  // 3) last resort: regex pull verdict so IF can still work\n  const m = t.match(/\"verdict\"\\s*:\\s*\"([^\"]+)\"/i);\n  if (m) {\n    return { ok: true, value: { verdict: m[1] }, error: null };\n  }\n\n  return { ok: false, value: null, error: 'Unable to parse AI output as JSON' };\n}\n\nconst raw = $json.output;\n\n// Preserve original text for debugging\nconst out = {\n  ...$json,\n  output_text: typeof raw === 'string' ? raw : JSON.stringify(raw),\n  output_parse_ok: false,\n  output_parse_error: null,\n};\n\nif (raw != null && typeof raw === 'object' && !Array.isArray(raw)) {\n  // already parsed\n  out.output = raw;\n  out.output_parse_ok = true;\n} else if (typeof raw === 'string') {\n  const parsed = tryParseJsonString(raw);\n  out.output = parsed.ok ? parsed.value : { verdict: null };\n  out.output_parse_ok = parsed.ok;\n  out.output_parse_error = parsed.ok ? null : parsed.error;\n} else {\n  out.output = { verdict: null };\n  out.output_parse_ok = false;\n  out.output_parse_error = 'output is missing or not a string/object';\n}\n\nreturn { json: out };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        36144,
        33456
      ],
      "id": "14c091d1-b926-42c6-9628-98afe5109767",
      "name": "Code in JavaScript7"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Save Signal Snapshot & Query Decision History\n// Persists the current signal data and retrieves past decisions for the AI Orchestrator.\n//\n// STREAMLINED: Only passes essential fields downstream to avoid token bloat\n// in the AI Decision Orchestrator node.\n//\n// FIX: Cascading fallback so the orchestrator ALWAYS runs:\n// 1. Try 'Output Telegram' (confidence-gated path, ran AI Indicator Analyst)\n// 2. Try 'Normalize Confidence' (ran AI, pre-switch)\n// 3. Try 'Enforce Desired Right' (If1 false path \u2014 confidence < 65%, AI never ran)\n// 4. Try $json (direct input from whatever triggered this node)\n// This ensures EXIT/REDUCE/REVERSE decisions run even when confidence < 65%.\n\nlet payload;\nlet _source_path = 'unknown';\ntry {\n  payload = $('Output Telegram').first().json;\n  if (!payload || !payload.ticker) throw new Error('empty');\n  _source_path = 'output_telegram';\n} catch (_) {\n  try {\n    payload = $('Normalize Confidence').first().json;\n    if (!payload || !payload.ticker) throw new Error('empty');\n    _source_path = 'normalize_confidence';\n  } catch (__) {\n    try {\n      payload = $('Enforce Desired Right').first().json;\n      if (!payload || !payload.ticker) throw new Error('empty');\n      _source_path = 'enforce_desired_right_low_confidence';\n    } catch (___) {\n      payload = $json;\n      _source_path = 'direct_input';\n    }\n  }\n}\nconst ticker = (payload.ticker || 'UNKNOWN').toUpperCase();\nconst profile = payload.profile || 'S';\nconst today = new Date().toISOString().slice(0, 10);\nconst now = new Date().toISOString();\n\n// ---- Parse AI output (may be a JSON string) ----\nlet aiOutput = payload.output || payload;\nif (typeof aiOutput === 'string') {\n  try { aiOutput = JSON.parse(aiOutput); } catch { aiOutput = payload; }\n}\n\n// ---- Extract signal details ----\nconst optionDecision = aiOutput.option_decision || payload.option_decision || 'WAIT';\nconst confidence = payload.confidence_pre ?? payload.confidence ?? aiOutput.confidence ?? null;\nconst trendDir = payload.trend_direction_pre || payload.trend_direction || aiOutput.trend_direction || null;\nconst alignment = payload.alignment_pre || payload.alignment || aiOutput.alignment || null;\nconst desiredRight = payload.desired_option_right || aiOutput.desired_option_right || null;\nconst contractSymbol = payload.option_contract_symbol || aiOutput.option_contract_symbol || null;\nconst entryPremium = payload.option_entry_premium ?? aiOutput.option_entry_premium ?? null;\nconst stopPremium = payload.option_stop_premium ?? aiOutput.option_stop_premium ?? null;\nconst tpPremium = payload.option_take_profit_premium ?? aiOutput.option_take_profit_premium ?? null;\nconst riskReward = payload.option_risk_reward ?? aiOutput.option_risk_reward ?? null;\n\n// Build DMI snapshot from timeframes (compact: latest values only)\nconst timeframes = payload.timeframes || {};\nconst dmiSnapshot = {};\nfor (const [tf, data] of Object.entries(timeframes)) {\n  if (data && data.latest) {\n    dmiSnapshot[tf] = {\n      diPlus: data.latest.diPlus,\n      diMinus: data.latest.diMinus,\n      adx: data.latest.adx,\n      direction: data.derived?.direction || null,\n      strength: data.derived?.strength || null\n    };\n  }\n}\n\n// Build demark snapshot (compact: counts only)\nconst demarkSnapshot = {};\nfor (const [tf, data] of Object.entries(timeframes)) {\n  if (data && data.demark) {\n    demarkSnapshot[tf] = {\n      setupDir: data.demark.setupDir,\n      setupCount: data.demark.setupCount,\n      countdownDir: data.demark.countdownDir,\n      countdownCount: data.demark.countdownCount,\n      setupCompleted: data.demark.setupCompleted,\n      countdownCompleted: data.demark.countdownCompleted\n    };\n  }\n}\n\n// Build candle snapshot (only present patterns)\nconst candleSnapshot = {};\nfor (const [tf, data] of Object.entries(timeframes)) {\n  const c = {};\n  if (data?.hammer?.present) c.hammer = data.hammer.type;\n  if (data?.shooting_star?.present) c.shooting_star = data.shooting_star.type;\n  if (data?.bullish_engulfing?.present) c.bullish_engulfing = data.bullish_engulfing.type;\n  if (data?.bearish_engulfing?.present) c.bearish_engulfing = data.bearish_engulfing.type;\n  if (Object.keys(c).length > 0) candleSnapshot[tf] = c;\n}\n\n// Option details\nconst optionDetails = {\n  contract_symbol: contractSymbol,\n  desired_right: desiredRight,\n  entry_premium: entryPremium,\n  stop_premium: stopPremium,\n  tp_premium: tpPremium,\n  risk_reward: riskReward,\n  bid: payload.option_bid ?? null,\n  ask: payload.option_ask ?? null,\n  mid: payload.option_mid ?? null,\n  spread_pct: payload.option_spread_pct ?? null,\n  delta: payload.optionContext?.greeks?.delta ?? null\n};\n\n// Liquidity gate status (from Output Telegram / upstream enrichment)\nconst optionLiquidityOk = payload.option_liquidity_ok ?? null;\nconst optionLiquidityReason = payload.option_liquidity_reason ?? null;\n\n// Plain explanation from AI\nconst plainExplanation = aiOutput.plain_explanation || payload.plain_explanation || '';\nconst keyFactors = aiOutput.key_factors || payload.key_factors || [];\n\n// Derive confidencePct for downstream (orchestrator needs this)\nlet confidencePct = null;\nif (confidence != null) {\n  confidencePct = (confidence > 0 && confidence <= 1) ? confidence * 100 : confidence;\n}\n\n// Build the signal snapshot record to pass downstream\nconst signalSnapshot = {\n  ticker,\n  profile,\n  trade_date: today,\n  captured_at: now,\n  ai_option_decision: optionDecision,\n  confidence: confidence,\n  confidencePct: confidencePct,\n  trend_direction: trendDir,\n  alignment: alignment,\n  dmi_snapshot: dmiSnapshot,\n  demark_snapshot: demarkSnapshot,\n  candle_snapshot: candleSnapshot,\n  option_details: optionDetails,\n  key_factors: keyFactors,\n  plain_explanation: plainExplanation,\n  trigger_price: payload.trigger_price ?? null,\n  invalidation_level: payload.invalidation_level ?? null,\n  target_level: payload.target_level ?? null,\n  option_liquidity_ok: optionLiquidityOk,\n  option_liquidity_reason: optionLiquidityReason,\n  _source_path: _source_path\n};\n\n// Build SQL for INSERT into signal_snapshots\nconst insertSignalSQL = `\nINSERT INTO trading.signal_snapshots (\n  ticker, profile, trade_date, ai_option_decision, confidence,\n  trend_direction, alignment, dmi_snapshot, demark_snapshot,\n  candle_snapshot, option_details, plain_explanation\n) VALUES (\n  '${ticker}', '${profile}', '${today}',\n  '${optionDecision}', ${confidence != null ? confidence : 'NULL'},\n  ${trendDir ? \"'\" + trendDir + \"'\" : 'NULL'},\n  ${alignment ? \"'\" + alignment + \"'\" : 'NULL'},\n  '${JSON.stringify(dmiSnapshot)}'::jsonb,\n  '${JSON.stringify(demarkSnapshot)}'::jsonb,\n  '${JSON.stringify(candleSnapshot)}'::jsonb,\n  '${JSON.stringify(optionDetails)}'::jsonb,\n  '${plainExplanation.replace(/'/g, \"''\").substring(0, 2000)}'\n) RETURNING id;\n`;\n\n// Build SQL to query decision history (last 10 decisions for this ticker today)\nconst queryHistorySQL = `\nSELECT\n  d.decision_type, d.reasoning, d.ai_confidence,\n  d.signal_summary, d.streak_context, d.created_at,\n  s.ai_option_decision, s.confidence, s.trend_direction,\n  s.alignment, s.dmi_snapshot, s.option_details,\n  s.plain_explanation\nFROM trading.trading_decisions d\nLEFT JOIN trading.signal_snapshots s ON d.signal_snapshot_id = s.id\nWHERE d.ticker = '${ticker}'\n  AND d.trade_date = '${today}'\nORDER BY d.created_at DESC\nLIMIT 10;\n`;\n\n// Query active virtual positions\n// FIX: Query position_journal directly instead of v_active_positions.\n// The view JOINs on session_id and decision_id which are NULL when\n// positions are inserted by the workflow, so it always returns 0 rows.\nconst queryPositionsSQL = `\nSELECT * FROM trading.position_journal\nWHERE ticker = '${ticker}'\n  AND status = 'OPEN';\n`;\n\n// Query confirmation streaks\nconst queryStreaksSQL = `\nSELECT * FROM trading.v_confirmation_streaks\nWHERE ticker = '${ticker}'\n  AND trade_date = '${today}'\nLIMIT 5;\n`;\n\n// Query recent order executions (actual Alpaca API results)\nconst queryExecutionsSQL = `\nSELECT\n  decision_type, execution_action, contract_symbol,\n  side, qty, alpaca_order_id, alpaca_status,\n  fill_price, filled_qty, success, error_message,\n  orchestration_reasoning, ai_confidence, executed_at\nFROM trading.order_executions\nWHERE ticker = '${ticker}'\n  AND trade_date = '${today}'\nORDER BY executed_at DESC\nLIMIT 10;\n`;\n\n// Query real broker positions (Alpaca) \u2014 latest sync\n// This tells the orchestrator what the broker ACTUALLY holds,\n// which may differ from virtual position_journal if orders filled/cancelled externally.\nconst queryBrokerPositionsSQL = `\nSELECT\n  symbol, asset_class, side, qty, avg_entry_price,\n  market_value, cost_basis, unrealized_pl, unrealized_plpc,\n  current_price, change_today, synced_at\nFROM trading.v_broker_positions_latest\nWHERE ticker = '${ticker}'\nORDER BY synced_at DESC;\n`;\n\n// Query real broker open orders (Alpaca) \u2014 latest sync\n// Prevents duplicate orders and tells the orchestrator about pending fills.\nconst queryBrokerOpenOrdersSQL = `\nSELECT\n  alpaca_order_id, symbol, asset_class, side, qty, filled_qty,\n  order_type, time_in_force, limit_price, stop_price,\n  status, position_intent, submitted_at, synced_at\nFROM trading.v_broker_open_orders_latest\nWHERE ticker = '${ticker}'\nORDER BY synced_at DESC;\n`;\n\n// Query recent trade evaluation feedback (grades + lessons from AI evaluator)\n// so the orchestrator can learn from past graded trades.\nconst queryEvalFeedbackSQL = `\nSELECT\n  trade_date, decision_type, contract_symbol, outcome,\n  evaluation_grade, evaluation_score,\n  signal_quality, timing_quality, risk_management_quality,\n  critique, lessons_learned, would_take_again,\n  pnl_total, price_change_pct, hold_duration_minutes\nFROM trading.v_evaluation_feedback\nWHERE ticker = '${ticker}'\nORDER BY created_at DESC\nLIMIT 5;\n`;\n\n// ---- CROSS-TICKER QUERIES (multi-order lifecycle) ----\n\n// Query portfolio summary: aggregate counts across ALL tickers\nconst queryPortfolioSQL = `\nSELECT * FROM trading.v_portfolio_summary;\n`;\n\n// Query ALL open positions across all tickers (not just current ticker)\n// so the orchestrator has full portfolio awareness.\nconst queryAllOpenPositionsSQL = `\nSELECT\n  ticker, contract_symbol, side, position_intent,\n  requested_qty, filled_qty, avg_fill_price,\n  stop_level, target_level, status, decision_type,\n  confidence_at_order, conviction_tier,\n  created_at, filled_at, monitoring_since\nFROM trading.v_open_positions_live\nORDER BY ticker, created_at DESC;\n`;\n\n// Query portfolio risk check for THIS ticker\n// Returns JSON with {allowed, blocked_reasons, current_state, limits}\nconst queryRiskCheckSQL = `\nSELECT trading.check_portfolio_risk_limits('${ticker}') AS risk_check;\n`;\n\n// STREAMLINED: Only pass essential fields downstream, not the entire raw payload.\n// The AI Orchestrator only needs _orchestration.context_for_ai.\n// Save Orchestration Decision needs ticker, profile, mode, and _orchestration.\nreturn {\n  json: {\n    ticker,\n    profile,\n    mode: payload.mode || null,\n    backtest_date: payload.backtest_date || null,\n    _source_path: _source_path,\n    _orchestration: {\n      signal_snapshot: signalSnapshot,\n      sql_insert_signal: insertSignalSQL,\n      sql_query_history: queryHistorySQL,\n      sql_query_positions: queryPositionsSQL,\n      sql_query_streaks: queryStreaksSQL,\n      sql_query_executions: queryExecutionsSQL,\n      sql_query_broker_positions: queryBrokerPositionsSQL,\n      sql_query_broker_open_orders: queryBrokerOpenOrdersSQL,\n      sql_query_eval_feedback: queryEvalFeedbackSQL,\n      sql_query_portfolio: queryPortfolioSQL,\n      sql_query_all_open_positions: queryAllOpenPositionsSQL,\n      sql_query_risk_check: queryRiskCheckSQL\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        36400,
        33056
      ],
      "id": "a1b2c3d4-0001-4000-8000-000000000001",
      "name": "Save Signal Snapshot"
    },
    {
      "parameters": {
        "jsCode": "// Sync Broker State\n// Fetches real positions and open orders from Alpaca broker API\n// and builds INSERT SQL to persist them in broker_positions / broker_open_orders tables.\n// This runs BEFORE Query Decision History so the orchestrator sees fresh broker data.\n\nconst ALPACA_BASE = 'https://paper-api.alpaca.markets';\nconst HEADERS = {\n  'APCA-API-KEY-ID': 'PK52GZ34XOEQZZMS75G54IQT3I',\n  'APCA-API-SECRET-KEY': '3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV',\n  'Content-Type': 'application/json'\n};\n\nconst ticker = $json.ticker || 'UNKNOWN';\nconst syncedAt = new Date().toISOString();\n\n// Helper: extract underlying ticker from OCC symbol (e.g. 'SPY250620C00540000' \u2192 'SPY')\nfunction extractTicker(symbol) {\n  if (!symbol) return null;\n  // OCC option symbols: ticker (1-6 chars) + 6-digit date + C/P + 8-digit strike\n  const m = symbol.match(/^([A-Z]{1,6})\\\\d{6}[CP]\\\\d{8}$/);\n  if (m) return m[1];\n  return symbol.replace(/[^A-Z]/g, '').substring(0, 6) || symbol;\n}\n\nfunction esc(v) {\n  if (v == null) return 'NULL';\n  if (typeof v === 'number') return String(v);\n  return \"'\" + String(v).replace(/'/g, \"''\") + \"'\";\n}\n\nlet brokerSyncSQL = '';\n\ntry {\n  // Fetch positions\n  const posRes = await fetch(`${ALPACA_BASE}/v2/positions`, { headers: HEADERS });\n  const positions = posRes.ok ? await posRes.json() : [];\n\n  if (Array.isArray(positions) && positions.length > 0) {\n    for (const p of positions) {\n      const t = extractTicker(p.symbol) || p.symbol;\n      brokerSyncSQL += `\nINSERT INTO trading.broker_positions (\n  symbol, asset_class, ticker, side, qty, avg_entry_price,\n  market_value, cost_basis, unrealized_pl, unrealized_plpc,\n  current_price, change_today, asset_id, exchange, synced_at\n) VALUES (\n  ${esc(p.symbol)}, ${esc(p.asset_class)}, ${esc(t)},\n  ${esc(p.side)}, ${esc(Number(p.qty))}, ${esc(Number(p.avg_entry_price))},\n  ${esc(Number(p.market_value))}, ${esc(Number(p.cost_basis))},\n  ${esc(Number(p.unrealized_pl))}, ${esc(Number(p.unrealized_plpc))},\n  ${esc(Number(p.current_price))}, ${esc(Number(p.change_today))},\n  ${esc(p.asset_id)}, ${esc(p.exchange)}, ${esc(syncedAt)}\n);\n`;\n    }\n  }\n\n  // Fetch open orders\n  const ordRes = await fetch(`${ALPACA_BASE}/v2/orders?status=open`, { headers: HEADERS });\n  const orders = ordRes.ok ? await ordRes.json() : [];\n\n  if (Array.isArray(orders) && orders.length > 0) {\n    for (const o of orders) {\n      const t = extractTicker(o.symbol) || o.symbol;\n      brokerSyncSQL += `\nINSERT INTO trading.broker_open_orders (\n  alpaca_order_id, symbol, asset_class, ticker, side, qty, filled_qty,\n  order_type, time_in_force, limit_price, stop_price,\n  status, position_intent, submitted_at, created_at, synced_at\n) VALUES (\n  ${esc(o.id)}, ${esc(o.symbol)}, ${esc(o.asset_class)}, ${esc(t)},\n  ${esc(o.side)}, ${esc(Number(o.qty))}, ${esc(Number(o.filled_qty || 0))},\n  ${esc(o.type)}, ${esc(o.time_in_force)},\n  ${o.limit_price ? esc(Number(o.limit_price)) : 'NULL'},\n  ${o.stop_price ? esc(Number(o.stop_price)) : 'NULL'},\n  ${esc(o.status)}, ${esc(o.position_intent || null)},\n  ${esc(o.submitted_at)}, ${esc(o.created_at)}, ${esc(syncedAt)}\n);\n`;\n    }\n  }\n} catch (err) {\n  // If broker API fails, continue without sync \u2014 the orchestrator will see stale/empty data\n  brokerSyncSQL += `-- Broker sync error: ${String(err.message || err).replace(/'/g, \"''\").substring(0, 200)}\\n`;\n}\n\n// If nothing to sync, add a harmless SELECT so Postgres node doesn't fail on empty query\nif (!brokerSyncSQL.trim() || brokerSyncSQL.trim().startsWith('--')) {\n  brokerSyncSQL = 'SELECT 1 AS broker_sync_noop;\\n';\n}\n\n// Pass through all upstream data + add broker sync SQL\nreturn {\n  json: {\n    ...$json,\n    _broker_sync_sql: brokerSyncSQL\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        36480,
        33256
      ],
      "id": "a1b2c3d4-0010-4000-8000-000000000010",
      "name": "Sync Broker State"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._broker_sync_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        36600,
        33256
      ],
      "id": "a1b2c3d4-0011-4000-8000-000000000011",
      "name": "Persist Broker State",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Save Signal Snapshot').first().json._orchestration.sql_insert_signal }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_history }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_positions }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_streaks }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_executions }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_broker_positions }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_broker_open_orders }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_eval_feedback }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_portfolio }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_all_open_positions }}\n\n{{ $('Save Signal Snapshot').first().json._orchestration.sql_query_risk_check }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        36720,
        33056
      ],
      "id": "a1b2c3d4-0002-4000-8000-000000000002",
      "name": "Query Decision History",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Build Orchestrator Context\n// Merge the Postgres query results with the signal data\n// to create a compact context for the AI Decision Orchestrator.\n// STREAMLINED: Only passes context_for_ai to minimize token usage.\n//\n// FIX: Changed to runOnceForAllItems so that the multi-statement\n// Postgres result (which returns N items \u2014 one per result row) is\n// aggregated into a SINGLE downstream item. This prevents the\n// fan-out bug where every Postgres row triggered a separate\n// AI Orchestrator call + Orchestration Telegram message.\n\nconst original = $('Save Signal Snapshot').first()?.json || {};\n\n// Collect ALL Postgres result rows into one flat array\nconst allRows = items.map(i => i.json).filter(Boolean);\n\n// Parse Postgres results (multi-statement returns mixed rows)\nlet decisionHistory = [];\nlet activePositions = [];\nlet confirmationStreaks = [];\nlet recentExecutions = [];\nlet brokerPositions = [];\nlet brokerOpenOrders = [];\nlet evalFeedback = [];\nlet insertedSignalId = null;\nlet portfolioSummary = [];\nlet allOpenPositions = [];\nlet riskCheck = null;\n\nfor (const row of allRows) {\n  // Risk check result (from check_portfolio_risk_limits function)\n  if (row.risk_check !== undefined) {\n    try {\n      riskCheck = typeof row.risk_check === 'string' ? JSON.parse(row.risk_check) : row.risk_check;\n    } catch { riskCheck = row.risk_check; }\n  // Portfolio summary rows (from v_portfolio_summary)\n  } else if (row.total_open_orders !== undefined || row.total_open_positions !== undefined || row.distinct_tickers !== undefined) {\n    portfolioSummary.push(row);\n  // All open positions from order_lifecycle (from v_open_positions_live)\n  } else if (row.monitoring_since !== undefined || (row.conviction_tier !== undefined && row.filled_qty !== undefined)) {\n    allOpenPositions.push(row);\n  } else if (row.id && !row.decision_type && !row.virtual_qty && !row.streak_count && !row.alpaca_order_id && row.alpaca_status === undefined && !row.unrealized_pl && row.unrealized_pl === undefined && !row.evaluation_grade) {\n    if (!insertedSignalId) insertedSignalId = row.id;\n  } else if (row.unrealized_pl !== undefined || row.unrealized_plpc !== undefined || (row.market_value !== undefined && row.cost_basis !== undefined)) {\n    brokerPositions.push(row);\n  } else if (row.position_intent !== undefined && row.submitted_at !== undefined) {\n    brokerOpenOrders.push(row);\n  } else if (row.evaluation_grade !== undefined || row.evaluation_score !== undefined) {\n    evalFeedback.push(row);\n  } else if (row.alpaca_order_id !== undefined || row.execution_action !== undefined) {\n    recentExecutions.push(row);\n  } else if (row.virtual_qty != null && row.status !== undefined) {\n    // FIX: Check virtual_qty BEFORE decision_type so position_journal rows\n    // are classified as activePositions, not accidentally as decisionHistory.\n    activePositions.push(row);\n  } else if (row.decision_type) {\n    decisionHistory.push(row);\n  } else if (row.streak_count != null) {\n    confirmationStreaks.push(row);\n  }\n}\n\nconst orch = original._orchestration || {};\nconst signal = orch.signal_snapshot || {};\n\n// ---- PRE-COMPUTE confirmation streak from decision history ----\n// Scan decisionHistory (most recent first) for consecutive same-direction\n// BUY_CALL/BUY_PUT signals. This gives the AI a deterministic count.\nlet computedStreakCount = 0;\nlet computedStreakDirection = null;\n\nconst currentSignalDir = (signal.ai_option_decision || '').toUpperCase();\nconst isCurrentDirectional = (currentSignalDir === 'BUY_CALL' || currentSignalDir === 'BUY_PUT');\n\n// Walk through past decisions (newest first) and count the streak\nfor (const d of decisionHistory) {\n  // Determine the original signal direction of this past decision\n  const origSig = (d.ai_option_decision || '').toUpperCase();\n  const sigSum = (typeof d.signal_summary === 'object' && d.signal_summary)\n    ? (d.signal_summary.option_decision || '').toUpperCase() : '';\n  const sc = (d.streak_context || '').toLowerCase();\n  const dt = (d.decision_type || '').toUpperCase();\n\n  // Determine the effective direction of this past decision\n  let pastDir = null;\n  if (origSig === 'BUY_CALL' || origSig === 'BUY_PUT') {\n    pastDir = origSig;\n  } else if (sigSum === 'BUY_CALL' || sigSum === 'BUY_PUT') {\n    pastDir = sigSum;\n  } else if (sc.includes('buy_call') || sc.includes('BUY_CALL')) {\n    pastDir = 'BUY_CALL';\n  } else if (sc.includes('buy_put') || sc.includes('BUY_PUT')) {\n    pastDir = 'BUY_PUT';\n  }\n\n  // If this is a buildup WAIT (decision=WAIT but signal was directional), count it\n  if (pastDir) {\n    if (computedStreakDirection === null) {\n      computedStreakDirection = pastDir;\n      computedStreakCount = 1;\n    } else if (pastDir === computedStreakDirection) {\n      computedStreakCount += 1;\n    } else {\n      break; // direction changed, streak ends\n    }\n  } else {\n    // Genuine WAIT or non-directional \u2014 breaks the streak\n    break;\n  }\n}\n\n// If the current signal is directional and matches the streak, add +1\nif (isCurrentDirectional) {\n  if (computedStreakDirection === null) {\n    computedStreakDirection = currentSignalDir;\n    computedStreakCount = 1;\n  } else if (currentSignalDir === computedStreakDirection) {\n    computedStreakCount += 1;\n  } else {\n    // Direction flipped \u2014 new streak starting\n    computedStreakDirection = currentSignalDir;\n    computedStreakCount = 1;\n  }\n} else if (computedStreakDirection && computedStreakCount > 0) {\n  // Current signal is WAIT but we have an active buildup\n  // Check if trend still aligns with the buildup direction\n  const trendDir = (signal.trend_direction || '').toLowerCase();\n  const isBullishTrend = trendDir.includes('up') || trendDir.includes('bull');\n  const isBearishTrend = trendDir.includes('down') || trendDir.includes('bear');\n  const buildupIsBull = computedStreakDirection === 'BUY_CALL';\n  const buildupIsBear = computedStreakDirection === 'BUY_PUT';\n  if ((buildupIsBull && isBullishTrend) || (buildupIsBear && isBearishTrend)) {\n    computedStreakCount += 1; // trend-aligned WAIT continues buildup\n  }\n  // else: genuine WAIT, don't increment but don't reset either\n}\n\n// Determine the computed entry stage\nlet computedStage = 'NOT_APPLICABLE';\nif (computedStreakCount >= 3) computedStage = 'CONFIRMED_ENTRY';\nelse if (computedStreakCount === 2) computedStage = 'BUILDING_CONVICTION';\nelse if (computedStreakCount === 1) computedStage = 'OBSERVE';\n\nconst computedEntryContext = {\n  confirmation_count: computedStreakCount,\n  signal_direction: computedStreakDirection,\n  stage: computedStage,\n  confirmations_needed: 3\n};\n\n// ---- EOD WINDOW CHECK ----\n// Compute whether we are in the last 5 minutes of market hours (3:55-4:00 PM ET).\n// US equity/options market closes at 16:00 ET.\nconst nowMs = Date.now();\nconst nowET = new Date(nowMs);\nconst etTimeStr = new Intl.DateTimeFormat('en-US', {\n  timeZone: 'America/New_York',\n  hour: '2-digit', minute: '2-digit', hour12: false\n}).format(nowET);\nconst [etHour, etMinute] = etTimeStr.split(':').map(Number);\nconst etTotalMinutes = etHour * 60 + etMinute;\nconst marketCloseMinutes = 16 * 60; // 16:00 ET = 960 minutes\nconst minutesToClose = marketCloseMinutes - etTotalMinutes;\nconst isEodWindow = (minutesToClose >= 0 && minutesToClose <= 5);\n\n// Build compact context_for_ai \u2014 this is ALL the AI agent sees\nconst contextForAi = {\n  current_signal: {\n    ticker: signal.ticker,\n    profile: signal.profile,\n    option_decision: signal.ai_option_decision,\n    confidence: signal.confidence,\n    trend_direction: signal.trend_direction,\n    alignment: signal.alignment,\n    option_details: signal.option_details,\n    key_factors: signal.key_factors,\n    explanation: signal.plain_explanation,\n    trigger_price: signal.trigger_price,\n    invalidation_level: signal.invalidation_level,\n    target_level: signal.target_level,\n    dmi_snapshot: signal.dmi_snapshot,\n    demark_snapshot: signal.demark_snapshot,\n    candle_snapshot: signal.candle_snapshot,\n    option_liquidity_ok: signal.option_liquidity_ok ?? null,\n    option_liquidity_reason: signal.option_liquidity_reason ?? null,\n    is_eod_window: isEodWindow,\n    minutes_to_close: minutesToClose\n  },\n  past_decisions: decisionHistory.map(d => ({\n    decision_type: d.decision_type,\n    reasoning: d.reasoning,\n    confidence: d.ai_confidence,\n    signal_summary: d.signal_summary,\n    original_signal_decision: d.ai_option_decision || null,\n    original_signal_confidence: d.confidence || null,\n    original_trend_direction: d.trend_direction || null,\n    original_alignment: d.alignment || null,\n    streak_context: d.streak_context || null,\n    when: d.created_at\n  })),\n  virtual_positions: activePositions.map(p => ({\n    ticker: p.ticker,\n    side: p.side,\n    qty: p.virtual_qty,\n    avg_entry: p.avg_entry_premium,\n    current_stop: p.current_stop,\n    current_tp: p.current_tp,\n    status: p.status,\n    opened_at: p.opened_at\n  })),\n  confirmation_streaks: confirmationStreaks.map(s => ({\n    streak_type: s.streak_type,\n    streak_count: s.streak_count,\n    latest: s.latest_at\n  })),\n  computed_entry_context: computedEntryContext,\n  recent_executions: recentExecutions.map(e => ({\n    decision_type: e.decision_type,\n    execution_action: e.execution_action,\n    contract_symbol: e.contract_symbol,\n    side: e.side,\n    qty: e.qty,\n    alpaca_order_id: e.alpaca_order_id,\n    alpaca_status: e.alpaca_status,\n    fill_price: e.fill_price,\n    filled_qty: e.filled_qty,\n    success: e.success,\n    error_message: e.error_message,\n    reasoning: e.orchestration_reasoning,\n    confidence: e.ai_confidence,\n    when: e.executed_at\n  })),\n  broker_positions: brokerPositions.map(bp => ({\n    symbol: bp.symbol,\n    side: bp.side,\n    qty: bp.qty,\n    avg_entry_price: bp.avg_entry_price,\n    market_value: bp.market_value,\n    unrealized_pl: bp.unrealized_pl,\n    unrealized_plpc: bp.unrealized_plpc,\n    current_price: bp.current_price,\n    synced_at: bp.synced_at\n  })),\n  broker_open_orders: brokerOpenOrders.map(bo => ({\n    alpaca_order_id: bo.alpaca_order_id,\n    symbol: bo.symbol,\n    side: bo.side,\n    qty: bo.qty,\n    filled_qty: bo.filled_qty,\n    order_type: bo.order_type,\n    limit_price: bo.limit_price,\n    status: bo.status,\n    position_intent: bo.position_intent,\n    submitted_at: bo.submitted_at,\n    synced_at: bo.synced_at\n  })),\n  past_trade_evaluations: evalFeedback.map(ev => ({\n    trade_date: ev.trade_date,\n    decision_type: ev.decision_type,\n    outcome: ev.outcome,\n    grade: ev.evaluation_grade,\n    score: ev.evaluation_score,\n    signal_quality: ev.signal_quality,\n    timing_quality: ev.timing_quality,\n    risk_mgmt_quality: ev.risk_management_quality,\n    critique: ev.critique,\n    lessons: ev.lessons_learned,\n    would_take_again: ev.would_take_again,\n    pnl_total: ev.pnl_total,\n    change_pct: ev.price_change_pct\n  })),\n  portfolio: {\n    summary: portfolioSummary.length > 0 ? portfolioSummary[0] : null,\n    all_open_positions: allOpenPositions.map(p => ({\n      ticker: p.ticker,\n      contract_symbol: p.contract_symbol,\n      side: p.side,\n      position_intent: p.position_intent,\n      requested_qty: p.requested_qty,\n      filled_qty: p.filled_qty,\n      avg_fill_price: p.avg_fill_price,\n      stop_level: p.stop_level,\n      target_level: p.target_level,\n      status: p.status,\n      decision_type: p.decision_type,\n      confidence: p.confidence_at_order,\n      conviction_tier: p.conviction_tier,\n      filled_at: p.filled_at,\n      monitoring_since: p.monitoring_since\n    })),\n    risk_check: riskCheck\n  }\n};\n\n// ---- QUOTA GATE: skip AI orchestrator when not needed ----\n// If confidence is low AND there are no positions to manage,\n// there is nothing for the AI to decide \u2014 deterministic WAIT.\n// This prevents burning AI quota every 5 min on idle signals.\nconst confidence = signal.confidence;\nconst confPct = (confidence != null && confidence > 0 && confidence <= 1) ? confidence * 100 : confidence;\nconst hasActivePositions = activePositions.length > 0;\nconst hasBrokerPositions = brokerPositions.length > 0;\nconst hasBrokerOpenOrders = brokerOpenOrders.length > 0;\nconst hasPortfolioPositions = allOpenPositions.length > 0;\nconst isRiskBlocked = riskCheck && riskCheck.allowed === false;\nconst optionDecision = (signal.ai_option_decision || '').toUpperCase();\nconst isRawDirectional = (optionDecision === 'BUY_CALL' || optionDecision === 'BUY_PUT');\n// FIX: A directional signal only matters for skip purposes if confidence\n// is high enough to actually deploy capital (>= 65%). Below that threshold,\n// the orchestrator is forced to output WAIT anyway (NEW_ENTRY/ADD_POSITION\n// require >= 0.65). A 55% BUY_CALL with no positions is a deterministic WAIT\n// \u2014 no need to burn AI quota on it.\nconst isDirectionalSignal = isRawDirectional && (confPct != null && confPct >= 65);\n\n// Check if past decisions show an active directional buildup streak\n// FIX: Use the deterministic computedStreakCount (computed above) instead of\n// scanning ALL past decisions with .some(). The old logic matched ANY historical\n// BUY_CALL/BUY_PUT decision, even stale ones from hours ago, which prevented\n// the skip gate from working on low-confidence WAIT signals.\n// Now only an active, consecutive, unbroken buildup counts.\nconst hasActiveBuildup = (computedStreakCount >= 2);\n\n// ---- HARD LIQUIDITY GATE ----\n// If option_liquidity_ok is explicitly false, the option spread is too wide\n// or quote data is missing. NEW_ENTRY and ADD_POSITION must be blocked\n// deterministically, regardless of what the AI decides.\nconst optionLiquidityOk = signal.option_liquidity_ok;\nconst liquidityBlocked = (optionLiquidityOk === false);\n\n// Check if any recent execution FAILED \u2014 AI must review to handle\n// e.g. failed EXIT means position is still open at broker\nconst hasFailedExecution = recentExecutions.some(e => {\n  return e.success === false && ['EXIT', 'REDUCE_EXPOSURE', 'REVERSE'].includes(\n    (e.execution_action || e.decision_type || '').toUpperCase()\n  );\n});\n\n// Check if confirmation_streaks from DB show an active streak\nconst hasDbStreak = confirmationStreaks.some(s => {\n  return (s.streak_count || 0) >= 1;\n});\n\n// Check if the last decision was actionable (EXIT/REVERSE/REDUCE)\n// \u2014 AI may need to follow up even if current signal is weak\nconst lastDecision = decisionHistory.length > 0 ? decisionHistory[0] : null;\nconst lastWasActionable = lastDecision && [\n  'EXIT', 'REVERSE', 'REDUCE_EXPOSURE', 'NEW_ENTRY', 'ADD_POSITION'\n].includes((lastDecision.decision_type || '').toUpperCase());\n\n// Skip AI orchestrator if ALL of these are true:\n// 1. Confidence < 65% (low conviction)\n// 2. No active virtual positions (nothing to manage)\n// 3. No real broker positions (nothing at risk)\n// 4. No pending broker orders (nothing in flight)\n// 5. Signal is not directional (WAIT, not BUY_CALL/BUY_PUT)\n// 6. No active directional buildup in recent decision history\n// 7. No failed recent executions that need follow-up\n// 8. No active confirmation streak in DB\n// 9. Last decision was not an actionable one needing follow-up\nconst _skip_orchestrator = (\n  (confPct == null || confPct < 65) &&\n  !hasActivePositions &&\n  !hasBrokerPositions &&\n  !hasBrokerOpenOrders &&\n  !hasPortfolioPositions &&\n  !isDirectionalSignal &&\n  !hasActiveBuildup &&\n  !hasFailedExecution &&\n  !hasDbStreak &&\n  !lastWasActionable\n);\n\n// Return a SINGLE item so downstream nodes (AI Orchestrator,\n// Orchestration Telegram, etc.) execute exactly once.\nreturn [{\n  json: {\n    ticker: original.ticker,\n    profile: original.profile,\n    mode: original.mode,\n    backtest_date: original.backtest_date,\n    _skip_orchestrator: _skip_orchestrator,\n    _skip_reason: _skip_orchestrator ? `Low confidence (${confPct != null ? Math.round(confPct) + '%' : 'null'}), no positions, no directional signal \u2014 deterministic WAIT` : null,\n    _liquidity_blocked: liquidityBlocked,\n    _liquidity_reason: liquidityBlocked ? (signal.option_liquidity_reason || 'option_liquidity_ok=false') : null,\n    _is_eod_window: isEodWindow,\n    _minutes_to_close: minutesToClose,\n    _orchestration: {\n      signal_snapshot: signal,\n      inserted_signal_id: insertedSignalId,\n      decision_history: decisionHistory,\n      active_positions: activePositions,\n      confirmation_streaks: confirmationStreaks,\n      recent_executions: recentExecutions,\n      broker_positions: brokerPositions,\n      broker_open_orders: brokerOpenOrders,\n      eval_feedback: evalFeedback,\n      portfolio_summary: portfolioSummary,\n      all_open_positions: allOpenPositions,\n      risk_check: riskCheck,\n      context_for_ai: contextForAi\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        37040,
        33056
      ],
      "id": "a1b2c3d4-0003-4000-8000-000000000003",
      "name": "Build Orchestrator Context"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        37360,
        33280
      ],
      "id": "a1b2c3d4-0004-4000-8000-000000000004",
      "name": "OpenAI Chat Model2",
      "credentials": {
        "openAiApi": {
          "id": "yxVkFtwSghktPWAk",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "123",
        "contextWindowLength": 5
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        37520,
        33280
      ],
      "id": "a1b2c3d4-0005-4000-8000-000000000005",
      "name": "Simple Memory2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify($json._orchestration.context_for_ai, null, 2) }}",
        "options": {
          "systemMessage": "You are an experienced human day trader's decision orchestrator. You think like a disciplined trader who:\n- Reviews their position book before every new signal\n- Tracks how many consecutive confirmations they've gotten\n- Knows when to hold conviction vs. when to reduce exposure\n- Never chases trades \u2014 waits for MULTIPLE confirmations before entering\n- Requires at least 3 consecutive same-direction signals before opening a new position\n- Manages risk by tracking virtual positions (no real orders)\n- Checks real broker state (actual positions & open orders) to stay grounded\n- Learns from past trade evaluations and avoids repeating graded mistakes\n\nYou will receive:\n1. **Current Signal**: The latest AI indicator analysis (option_decision, confidence, trend, alignment, key factors)\n2. **Past Decisions**: Your previous orchestration decisions today for this ticker (chronological)\n3. **Virtual Positions**: Any open virtual positions you've previously decided to track\n4. **Confirmation Streaks**: How many consecutive times the signal has confirmed or contradicted\n5. **Recent Executions**: Actual Alpaca API order execution results (EXIT, REDUCE_EXPOSURE, REVERSE actions) showing whether real orders succeeded/failed, fill prices, and filled quantities\n6. **Broker Positions**: REAL positions the broker actually holds right now (may differ from virtual tracking if orders filled/cancelled externally). Use this as ground truth.\n7. **Broker Open Orders**: Pending/open orders at the broker that haven't filled yet. NEVER submit duplicate orders if one is already pending for this ticker.\n8. **Past Trade Evaluations**: AI evaluator grades and lessons from recently closed trades. Learn from these \u2014 avoid repeating mistakes that got D/F grades.\n9. **Portfolio Context**: Cross-ticker portfolio data including:\n   - `portfolio.summary`: Aggregate counts of open orders, positions, distinct tickers, total exposure\n   - `portfolio.all_open_positions`: Every open position across ALL tickers (not just this one)\n   - `portfolio.risk_check`: Pre-computed risk limit check for this ticker \u2014 includes whether a new order is ALLOWED, and any blocked_reasons\n\n## PORTFOLIO RISK AWARENESS\nYou now receive full portfolio context across all tickers. Use it critically:\n- **risk_check.allowed**: If `false`, you MUST NOT output NEW_ENTRY or ADD_POSITION. The risk system has blocked it. Output WAIT and mention the blocked_reasons in your reasoning.\n- **risk_check.blocked_reasons**: Array of specific limit violations (e.g., \\\"max_concurrent_positions_exceeded\\\", \\\"max_exposure_per_ticker_exceeded\\\"). Always mention these in risk_notes.\n- **portfolio.all_open_positions**: Check what other tickers have open positions. Consider:\n  - If you already have 2+ positions in correlated tickers (e.g., SPY + QQQ both CALL), be cautious about adding more directional risk\n  - If portfolio is heavily concentrated in one direction (all CALLs or all PUTs), flag the concentration risk\n  - Use this data to suggest REDUCE_EXPOSURE on over-concentrated positions\n- **portfolio.summary**: Check total_open_positions count. If approaching maximum, prioritize exiting weak positions before opening new ones.\n- When risk_check allows the trade, still mention the portfolio context in risk_notes (e.g., \\\"Portfolio has 3/5 max positions, room for this entry\\\")\n\n## YOUR TASK\nDecide what a human trader would do given this full context. Output ONE of these decision types:\n\n- **NEW_ENTRY**: Open a new virtual position ONLY after the signal has been confirmed multiple consecutive times (see NEW_ENTRY CONFIRMATION STRATEGY below). Never chase the first signal.\n- **CONFIRM_HOLD**: Signal confirms existing position direction. Hold and track.\n- **ADD_POSITION**: Strong consecutive confirmations (3+) after an existing position is open. Trader would scale in.\n- **REDUCE_EXPOSURE**: Signal weakening or mixed. Reduce virtual position size.\n- **REVERSE**: Signal has flipped direction decisively. Close existing and open opposite.\n- **EXIT**: Signal says WAIT or contradicts position multiple times. Close virtual position.\n- **WAIT**: Not enough conviction, or building conviction before entry. Do nothing. No position change.\n\n## NEW_ENTRY CONFIRMATION STRATEGY\nA disciplined trader NEVER enters on the first signal. You must wait for the signal to prove itself through multiple consecutive confirmations before committing capital. This is how a patient, professional trader avoids false signals and whipsaws.\n\n**Stage 1 \u2014 OBSERVE (1st signal, no position):**\n- Signal is BUY_CALL or BUY_PUT, no existing position, no prior same-direction signals today\n- Decision: **WAIT**\n- Reasoning must mention: \\\"First signal observed, waiting for confirmation before entry\\\"\n- Record the signal direction in streak_context (e.g., \\\"1st BUY_CALL signal, observing\\\")\n\n**Stage 2 \u2014 BUILDING CONVICTION (2nd consecutive same-direction signal):**\n- Signal is same direction as the previous signal (both BUY_CALL or both BUY_PUT), still no position\n- Decision: **WAIT**\n- Reasoning must mention: \\\"Second consecutive confirmation, building conviction but not yet entering\\\"\n- Record in streak_context (e.g., \\\"2nd consecutive BUY_CALL, conviction building\\\")\n\n**Stage 3 \u2014 CONFIRMED ENTRY (3rd+ consecutive same-direction signal):**\n- Signal is same direction for the 3rd (or more) consecutive time, still no position\n- Decision: **NEW_ENTRY**\n- Reasoning must mention: \\\"Signal confirmed 3 consecutive times, entering with conviction\\\"\n- Record in streak_context (e.g., \\\"3rd consecutive BUY_CALL, confirmed entry\\\")\n\n**Reset conditions \u2014 the confirmation count resets to 0 if:**\n- The signal direction flips (BUY_CALL \u2192 BUY_PUT or vice versa)\n- A GENUINE WAIT signal interrupts the streak (see IMPORTANT below)\n- Confidence drops below 0.65 during the buildup\n- The signal's trend or alignment quality degrades between confirmations\n\n**IMPORTANT \u2014 Distinguishing buildup WAITs from genuine WAITs:**\nDuring the confirmation buildup, YOU (the orchestrator) output WAIT as the decision_type while the underlying signal is BUY_CALL or BUY_PUT. These buildup WAITs do NOT reset the streak. To determine the actual signal direction of past WAIT decisions, check ALL of these fields in each past_decision:\n1. The original_signal_decision field (the ACTUAL upstream signal analyzer output: BUY_CALL, BUY_PUT, or WAIT \u2014 this is the most reliable)\n2. The signal_summary.option_decision field (this records what the orchestrator echoed \u2014 may also say BUY_CALL/BUY_PUT)\n3. The streak_context field (which records the buildup direction, e.g., \\\"2nd consecutive BUY_PUT\\\")\n4. The original_trend_direction and original_alignment fields (to verify directional consistency)\nA WAIT decision only resets the streak if original_signal_decision is WAIT AND signal_summary.option_decision is WAIT AND streak_context does not mention an active directional buildup.\n\n**CRITICAL \u2014 Current signal WAIT with active buildup:**\nIf the current signal's option_decision is WAIT but:\n- The trend direction is clearly bearish/bullish (not neutral)\n- The option right context aligns with the trend (e.g., put option in downtrend)\n- Past decisions show an active BUY_PUT or BUY_CALL buildup streak\nThen treat the current signal as CONTINUING the buildup direction. The signal analyzer may output WAIT due to technical gate failures (spread, delta, RR) even when the directional thesis is intact. Do NOT let a technically-gated WAIT reset a strong directional buildup.\n\n**Override \u2014 Immediate NEW_ENTRY allowed ONLY if ALL of these are true:**\n- Confidence \u2265 0.85\n- Alignment is \\\"strong\\\" or \\\"very strong\\\"\n- Trend direction is decisive (not mixed/neutral)\n- No D/F graded trades in past evaluations for similar setups\n- Reasoning must explicitly justify why the override is warranted\n\nHow to count confirmations \u2014 USE PRE-COMPUTED VALUES:\n- The input context includes a `computed_entry_context` object with pre-computed confirmation data:\n  - `confirmation_count`: deterministic count of consecutive same-direction signals (past + current)\n  - `signal_direction`: the direction of the active streak (BUY_CALL or BUY_PUT, or null)\n  - `stage`: OBSERVE (count=1), BUILDING_CONVICTION (count=2), CONFIRMED_ENTRY (count\u22653), NOT_APPLICABLE (count=0)\n  - `confirmations_needed`: always 3\n- **You MUST copy `computed_entry_context.confirmation_count` into your `entry_strategy.confirmation_count`** \u2014 do NOT re-derive it\n- **You MUST copy `computed_entry_context.stage` into your `entry_strategy.stage`** \u2014 do NOT infer independently\n- If stage is CONFIRMED_ENTRY and confidence >= 0.65 and no position \u2192 NEW_ENTRY\n- If stage is BUILDING_CONVICTION \u2192 WAIT (use the count from computed_entry_context)\n- If stage is OBSERVE \u2192 WAIT (1st signal, use count=1)\n- If stage is NOT_APPLICABLE \u2192 no active buildup, decide based on other rules\n- past_decisions are still available for reasoning context, but do NOT manually count them for confirmation_count\n\n## CONFIDENCE GATE FOR CAPITAL DEPLOYMENT\nYou now receive signals at ALL confidence levels (not just high confidence). This is intentional \u2014 position management (EXIT, REVERSE, REDUCE_EXPOSURE) must work even on weak signals to protect capital.\n\nHowever, COMMITTING NEW CAPITAL still requires strong conviction:\n- **NEW_ENTRY**: ONLY allowed if current_signal.confidence >= 0.65 (65%). If confidence < 0.65, you MUST output WAIT instead, regardless of confirmation count.\n- **ADD_POSITION**: ONLY allowed if current_signal.confidence >= 0.65 (65%). If confidence < 0.65, you MUST output WAIT instead.\n- **EXIT, REVERSE, REDUCE_EXPOSURE**: Allowed at ANY confidence level. These protect existing capital and must NEVER be blocked by low confidence.\n- **CONFIRM_HOLD, WAIT**: Allowed at ANY confidence level.\n\nAlways mention the confidence level and this gate in your reasoning when it affects your decision.\n\n## LIQUIDITY GATE FOR CAPITAL DEPLOYMENT\nYou now receive `option_liquidity_ok` and `option_liquidity_reason` in the current_signal context.\n\n**HARD RULE \u2014 option_liquidity_ok === false:**\n- **NEW_ENTRY**: ABSOLUTELY FORBIDDEN when option_liquidity_ok is false. You MUST output WAIT instead, regardless of confirmation count or confidence. You cannot enter a position with illiquid options (wide spreads, missing quotes).\n- **ADD_POSITION**: ABSOLUTELY FORBIDDEN when option_liquidity_ok is false. You MUST output WAIT instead. You cannot add to a position with illiquid options.\n- **EXIT, REVERSE, REDUCE_EXPOSURE**: ALWAYS ALLOWED regardless of liquidity. Exiting/reducing an existing position is critical for capital protection and must never be blocked by liquidity concerns.\n- **CONFIRM_HOLD, WAIT**: Always allowed regardless of liquidity.\n\nWhen option_liquidity_ok is false:\n- Always mention the liquidity reason in your reasoning (e.g., \"Liquidity gate blocked: spread too wide at X%\")\n- The confirmation streak should still be tracked (buildup WAITs continue counting) but NEW_ENTRY must not trigger until liquidity is restored\n- Set risk_notes to include the liquidity concern\n\nWhen option_liquidity_ok is true or null:\n- Proceed with normal decision rules (confidence gate, confirmation strategy, etc.)\n\n\n## DECISION RULES\n1. If current signal is WAIT and no existing position \u2192 check past_decisions for active directional buildup first. If past_decisions show 2+ consecutive same-direction buildup WAITs (signal_summary.option_decision is BUY_CALL/BUY_PUT or streak_context mentions buildup) AND the current trend/option_right still aligns \u2192 this is a confirmed entry, output NEW_ENTRY. Otherwise \u2192 WAIT\n2. If current signal is WAIT and existing position \u2192 check streak. If 2+ consecutive WAITs \u2192 EXIT. If first WAIT \u2192 CONFIRM_HOLD (give it one more chance)\n3. If current signal is BUY_CALL/BUY_PUT and no existing position \u2192 follow NEW_ENTRY CONFIRMATION STRATEGY above (do NOT immediately enter \u2014 count consecutive same-direction confirmations from past_decisions first)\n4. If current signal matches existing position direction \u2192 CONFIRM_HOLD (or ADD_POSITION if 3+ consecutive confirms)\n5. If current signal contradicts existing position \u2192 check streak. If 2+ contradictions \u2192 REVERSE. If first contradiction \u2192 CONFIRM_HOLD with caution note\n6. If confidence < 0.5 \u2192 WAIT regardless\n7. If confidence < 0.65 during NEW_ENTRY buildup \u2192 WAIT and reset confirmation count\n8. Always respect the AI indicator's option_decision as the primary signal source, but use trend_direction and option context as secondary confirmation when option_decision is WAIT during an active buildup\n\n## EXIT TRIGGERS (ACTIVE \u2014 must fire when conditions are met)\nYou MUST output EXIT when ANY of the following conditions are true and there is an existing open position (virtual or broker). Do NOT downgrade these to CONFIRM_HOLD or WAIT \u2014 these are capital-protection rules.\n\n**E1 \u2014 Broker P&L Stop-Loss:** If broker_positions shows unrealized_plpc (percent) \u2264 -0.30 (i.e., position has lost 30%+ of its value), output EXIT immediately. Reasoning must mention: \\\"Broker P&L stop-loss triggered: unrealized loss exceeds 30%\\\"\n\n**E2 \u2014 Broker P&L Extended Loss:** If broker_positions shows unrealized_plpc \u2264 -0.15 (15%+ loss) AND the current signal is WAIT or contradicts the position direction, output EXIT. Reasoning must mention: \\\"Position down 15%+ with weakening signal \u2014 exiting to protect capital\\\"\n\n**E3 \u2014 Confidence Collapse:** If there is an open position AND current signal confidence < 0.40, output EXIT. A confidence below 0.40 means the signal has no conviction \u2014 do not hold a position on a dead signal. Reasoning must mention: \\\"Confidence collapsed below 0.40 \u2014 exiting position\\\"\n\n**E4 \u2014 Consecutive WAIT Signals:** If there is an open position AND the last 2+ orchestrator decisions (including current) are WAIT-type (genuine WAITs, not buildup WAITs), output EXIT. This is existing Rule 2 above, but restated for emphasis \u2014 you MUST actually fire it.\n\n**E5 \u2014 Trend Reversal Against Position:** If there is an open CALL position AND the current trend_direction is \\\"downtrend\\\" with alignment \\\"all_aligned\\\", or there is an open PUT position AND the current trend_direction is \\\"uptrend\\\" with alignment \\\"all_aligned\\\", output EXIT. A fully aligned opposite trend is a clear exit signal. Reasoning must mention: \\\"Trend fully reversed against position \u2014 exiting\\\"\n\n**E6 \u2014 End-of-Day Liquidation:** If `current_signal.is_eod_window` is true (market closes in 5 minutes or less), output EXIT immediately for ANY open position, regardless of P&L, signal direction, or confidence. As a day trader, you NEVER hold positions overnight. Even if the position is profitable, close it. Reasoning must mention: \\\"End-of-day liquidation \u2014 closing all positions before market close (X minutes remaining)\\\". Also: when `is_eod_window` is true, NEW_ENTRY and ADD_POSITION are ABSOLUTELY FORBIDDEN \u2014 do not open or add to positions in the last 5 minutes of trading.\n\n**EXIT priority:** EXIT triggers E1-E6 take priority over CONFIRM_HOLD. If any EXIT trigger matches, you MUST output EXIT even if the signal technically \\\"matches\\\" the position direction. Protecting capital always comes first.\n\n## REDUCE_EXPOSURE TRIGGERS (ACTIVE \u2014 must fire when conditions are met)\nYou MUST output REDUCE_EXPOSURE when ANY of the following conditions are true, there is an existing open position with virtual_qty >= 2, and no EXIT trigger (E1-E6) matches. If virtual_qty is 1, use EXIT instead of REDUCE.\n\n**R1 \u2014 Alignment Degradation:** If the position was opened when alignment was \\\"all_aligned\\\" (check past_decisions) but current signal alignment is \\\"mixed\\\" or worse, output REDUCE_EXPOSURE. The thesis is weakening. Reasoning must mention: \\\"Alignment degraded from all_aligned to mixed \u2014 reducing exposure\\\"\n\n**R2 \u2014 Confidence Drop While Holding:** If there is an open position AND current signal confidence is between 0.40 and 0.55 (inclusive), output REDUCE_EXPOSURE. Confidence is weak but not collapsed \u2014 trim the position. Reasoning must mention: \\\"Confidence dropped to [X] while holding \u2014 reducing exposure to manage risk\\\"\n\n**R3 \u2014 Broker P&L Profit Protection:** If broker_positions shows unrealized_plpc >= +0.20 (20%+ profit) AND the current signal is WAIT or confidence < 0.65, output REDUCE_EXPOSURE to lock in partial gains. Reasoning must mention: \\\"Position up 20%+ but signal weakening \u2014 reducing to protect profits\\\"\n\n**R4 \u2014 Mixed Signal With Position:** If current signal is BUY_CALL but position is PUT (or vice versa), AND this is the FIRST contradiction (not yet 2 consecutive), AND virtual_qty >= 2, output REDUCE_EXPOSURE instead of CONFIRM_HOLD. Trim first, then see if the contradiction persists. Reasoning must mention: \\\"First contradictory signal \u2014 reducing exposure as precaution before potential reversal\\\"\n\n**REDUCE_EXPOSURE vs EXIT:** If a REDUCE trigger matches but virtual_qty is 1, escalate to EXIT instead. You cannot reduce below 1 \u2014 close the position entirely.\n\n## BROKER STATE AWARENESS\nYou now receive REAL broker data. Use it critically:\n- **broker_positions**: If the broker shows a real position but virtual_positions is empty, something got out of sync \u2014 acknowledge it and be cautious\n- **broker_positions**: If unrealized_pl is significantly negative, factor that into your risk assessment\n- **broker_open_orders**: If there's already an open BUY order for this ticker, do NOT issue NEW_ENTRY or ADD_POSITION \u2014 wait for it to fill or cancel\n- **broker_open_orders**: If there's a pending SELL order, do NOT issue EXIT \u2014 it's already in progress\n- Always reconcile virtual_positions with broker_positions in your reasoning\n\n## EXECUTION AWARENESS\nAll orchestrator decisions are tracked in recent_executions, including:\n- **API actions** (NEW_ENTRY, ADD_POSITION, REDUCE_EXPOSURE, REVERSE, EXIT): Show actual Alpaca API order results with fill prices, quantities, and success/failure status\n- **No-op actions** (CONFIRM_HOLD, WAIT): Logged with execution_action=NONE for complete audit trail\n\nUse this data to:\n- Verify whether a previous EXIT/REDUCE/REVERSE was actually filled before deciding next action\n- If a REVERSE close order failed (success=false), do NOT issue NEW_ENTRY \u2014 the old position may still be open\n- If a REDUCE partially filled (filled_qty < qty), account for the remaining position size\n- If an EXIT succeeded, treat the position as truly closed regardless of virtual position state\n- Track how many consecutive WAIT or CONFIRM_HOLD decisions have been made\n- Reference execution outcomes in your reasoning when relevant\n\n## LEARNING FROM PAST EVALUATIONS\nYou receive past_trade_evaluations with grades (A-F) and lessons from closed trades.\n- If a recent trade got a D or F grade, explicitly mention what went wrong and how you're avoiding it\n- If the evaluator noted poor timing or signal quality, raise your confidence threshold for similar setups\n- Reference specific lessons in your reasoning when they apply to the current situation\n- A pattern of bad grades on similar setups should make you more cautious (higher WAIT tendency)\n\n## POSITION SIZING (for virtual tracking)\n- NEW_ENTRY: 1 unit\n- ADD_POSITION: +1 unit (max 3 total)\n- REDUCE_EXPOSURE: -1 unit\n- EXIT: close all\n- REVERSE: close all, open 1 unit opposite\n\n## OUTPUT FORMAT (STRICT JSON, no markdown)\n{\n  \"ticker\": \"the ticker symbol\",\n  \"decision_type\": \"NEW_ENTRY|CONFIRM_HOLD|ADD_POSITION|REDUCE_EXPOSURE|REVERSE|EXIT|WAIT\",\n  \"reasoning\": \"2-3 sentences explaining your thinking like a human trader\",\n  \"ai_confidence\": 0.0-1.0,\n  \"position_action\": {\n    \"action\": \"OPEN|ADD|REDUCE|CLOSE|REVERSE|NONE\",\n    \"side\": \"CALL|PUT|null\",\n    \"qty_change\": 0,\n    \"new_total_qty\": 0\n  },\n  \"signal_summary\": {\n    \"option_decision\": \"BUY_CALL|BUY_PUT|WAIT\",\n    \"confidence\": 0.0-1.0,\n    \"trend\": \"string\",\n    \"alignment\": \"string\",\n    \"contract\": \"string|null\"\n  },\n  \"entry_strategy\": {\n    \"stage\": \"OBSERVE|BUILDING_CONVICTION|CONFIRMED_ENTRY|OVERRIDE_ENTRY|NOT_APPLICABLE\",\n    \"confirmation_count\": 0,\n    \"signal_direction\": \"BUY_CALL|BUY_PUT|null\",\n    \"confirmations_needed\": 3,\n    \"override_triggered\": false,\n    \"notes\": \"explanation of where we are in the confirmation process\"\n  },\n  \"risk_notes\": \"any risk concerns or observations\",\n  \"streak_context\": \"description of confirmation/contradiction pattern\",\n  \"portfolio_context\": \"brief summary: N open positions across M tickers, risk check allowed/blocked, concentration concerns\"\n}\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        37360,
        33056
      ],
      "id": "a1b2c3d4-0006-4000-8000-000000000006",
      "name": "AI Decision Orchestrator"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Save Orchestration Decision to Postgres\n// Parses the AI Decision Orchestrator output and builds INSERT SQL\n// for trading_decisions, decision_confirmations, and position_journal.\n//\n// FIX: Changed to runOnceForAllItems so that even if the upstream\n// AI Decision Orchestrator returns multiple items, we only process\n// the first one and return a SINGLE item. This prevents the fan-out\n// bug where every AI output item triggered a separate\n// Orchestration Telegram message.\n//\n// FIX: Use dollar-quoting for all embedded JSON/text to prevent SQL\n// syntax errors from backslashes, nested quotes, or special chars in\n// the AI response or orchestration context. The old single-quote\n// escaping (.replace(/'/g, \"''\")) was fragile and caused the entire\n// multi-statement batch to fail silently.\n//\n// FIX: Removed passthroughSQL (SELECT '...'::jsonb) which embedded\n// the entire $json (including _orchestration context with decision\n// history, broker positions, etc.) into a SQL string literal. This\n// frequently caused syntax errors that aborted the entire batch,\n// preventing trading_decisions and position_journal writes.\n//\n// FIX: Added action === 'ADD' to lifecycle intent SQL condition so\n// ADD_POSITION decisions also get an INTENT row in order_lifecycle.\n\nconst $json = items[0].json;\n\nfunction stripCodeFences(s) {\n  if (typeof s !== 'string') return s;\n  return s.trim().replace(/^```(?:json)?\\s*/i, '').replace(/\\s*```$/i, '').trim();\n}\n\nfunction parseMaybeJson(x) {\n  if (x == null) return {};\n  if (typeof x === 'object') return x;\n  if (typeof x !== 'string') return {};\n  const t = stripCodeFences(x);\n  try { return JSON.parse(t); } catch {}\n  try {\n    const s = t.indexOf('{');\n    const e = t.lastIndexOf('}');\n    if (s >= 0 && e > s) return JSON.parse(t.slice(s, e + 1));\n  } catch {}\n  return {};\n}\n\n// Safe SQL helpers using dollar-quoting\nfunction sqlStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction sqlJsonb(obj) {\n  if (obj === null || obj === undefined) return 'NULL';\n  try {\n    const s = typeof obj === 'string' ? obj : JSON.stringify(obj);\n    return '$jb$' + s + '$jb$::jsonb';\n  } catch { return \"'{}'::jsonb\"; }\n}\nfunction sqlText(val, maxLen) {\n  if (val === null || val === undefined) return 'NULL';\n  let s = String(val);\n  if (maxLen) s = s.substring(0, maxLen);\n  return '$tx$' + s + '$tx$';\n}\n\nconst orchestration = $json._orchestration || {};\nconst aiRaw = $json.output || $json;\nconst decision = parseMaybeJson(aiRaw);\n\n// Resolve ticker: prefer orchestration context, then AI decision output, then upstream node\nlet _upstreamTicker = null;\ntry { _upstreamTicker = $('Build Orchestrator Context').first()?.json?.ticker || null; } catch {}\nconst ticker = orchestration.signal_snapshot?.ticker || decision.ticker || $json.ticker || _upstreamTicker || 'UNKNOWN';\nlet _upstreamProfile = null;\ntry { _upstreamProfile = $('Build Orchestrator Context').first()?.json?.profile || null; } catch {}\nconst profile = orchestration.signal_snapshot?.profile || $json.profile || _upstreamProfile || 'S';\nconst today = new Date().toISOString().slice(0, 10);\nconst now = new Date().toISOString();\nconst signalId = orchestration.inserted_signal_id || null;\n\nconst decisionType = decision.decision_type || 'WAIT';\n\n// ---- HARD LIQUIDITY GATE ----\n// Deterministic override: if the upstream Build Orchestrator Context flagged\n// _liquidity_blocked=true, NEW_ENTRY and ADD_POSITION MUST be blocked.\n// This cannot be overridden by the AI \u2014 it's a code-level safety gate.\nconst liquidityBlocked = $json._liquidity_blocked === true;\nconst liquidityReason = $json._liquidity_reason || 'option_liquidity_ok=false';\nlet liquidityOverridden = false;\n\nif (liquidityBlocked && (decisionType === 'NEW_ENTRY' || decisionType === 'ADD_POSITION')) {\n  // Override to WAIT \u2014 cannot open/add positions with illiquid options\n  liquidityOverridden = true;\n}\n\n// Apply the override (we use a mutable variable below)\nlet finalDecisionType = liquidityOverridden ? 'WAIT' : decisionType;\n\n// ---- HARD EOD EXIT GATE ----\n// Deterministic override: if the upstream Build Orchestrator Context flagged\n// _is_eod_window=true (last 5 min before 4:00 PM ET) AND there are open\n// positions (virtual or broker), force EXIT regardless of what the AI decided.\n// This cannot be overridden by the AI  it's a code-level safety gate.\nconst isEodWindow = $json._is_eod_window === true;\nconst minutesToClose = $json._minutes_to_close;\nconst eodActivePositions = (orchestration.active_positions || []);\nconst eodBrokerPositions = (orchestration.broker_positions || []);\nconst hasAnyPositions = eodActivePositions.length > 0 || eodBrokerPositions.length > 0;\nlet eodOverridden = false;\n\nif (isEodWindow && hasAnyPositions && finalDecisionType !== 'EXIT') {\n  // Override to EXIT  must close all positions before market close\n  eodOverridden = true;\n  finalDecisionType = 'EXIT';\n}\n\nconst reasoning = (decision.reasoning || '').substring(0, 2000);\nconst aiConf = decision.ai_confidence ?? null;\nlet posAction = decision.position_action || {};\n\n// If EOD gate overrode the decision, force position_action to CLOSE\nif (eodOverridden) {\n  posAction = { action: 'CLOSE', side: null, qty_change: 0, new_total_qty: 0 };\n}\nconst signalSummary = decision.signal_summary || {};\nconst riskNotes = (decision.risk_notes || '').substring(0, 500);\nconst streakContext = (decision.streak_context || '').substring(0, 500);\nconst entryStrategy = decision.entry_strategy || {};\n\n// ---- SQL: Insert trading decision + confirmation using CTE ----\nconst lastDecisions = orchestration.decision_history || [];\nconst lastDecision = lastDecisions[0] || null;\nlet confirmationType = 'CONFIRM';\nif (!lastDecision) {\n  confirmationType = 'CONFIRM';\n} else if (finalDecisionType === 'REVERSE' || finalDecisionType === 'EXIT') {\n  confirmationType = 'CONTRADICT';\n} else if (finalDecisionType === 'WAIT' && lastDecision.decision_type !== 'WAIT') {\n  confirmationType = 'CONTRADICT';\n} else if (finalDecisionType === lastDecision.decision_type) {\n  confirmationType = 'CONFIRM';\n} else {\n  confirmationType = 'NEUTRAL';\n}\n\nconst insertDecisionAndConfirmSQL = `\nWITH new_decision AS (\n  INSERT INTO trading.trading_decisions (\n    ticker, profile, trade_date, signal_snapshot_id,\n    decision_type, reasoning, ai_confidence,\n    position_action, signal_summary, streak_context\n  ) VALUES (\n    ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n    ${signalId ? sqlStr(signalId) : 'NULL'},\n    ${sqlStr(finalDecisionType)},\n    ${sqlText(reasoning, 2000)},\n    ${aiConf != null ? aiConf : 'NULL'},\n    ${sqlJsonb(posAction)},\n    ${sqlJsonb(signalSummary)},\n    ${streakContext ? sqlText(streakContext, 500) : 'NULL'}\n  ) RETURNING id\n)\nINSERT INTO trading.decision_confirmations (\n  ticker, trade_date, decision_id, confirmation_type, notes\n) SELECT\n  ${sqlStr(ticker)}, ${sqlStr(today)}, new_decision.id,\n  ${sqlStr(confirmationType)},\n  ${streakContext ? sqlText(streakContext, 500) : \"''\"}\nFROM new_decision\nRETURNING *;\n`;\n\n// ---- SQL: Update position journal ----\nlet positionSQL = '';\n// If liquidity gate overrode the decision, neutralize the position action too.\n// NEW_ENTRY -> WAIT means no OPEN; ADD_POSITION -> WAIT means no ADD.\nconst rawAction = (posAction.action || 'NONE').toUpperCase();\nconst action = liquidityOverridden ? 'NONE' : rawAction;\nconst side = posAction.side || null;\nconst qtyChange = posAction.qty_change || 0;\nconst newTotalQty = posAction.new_total_qty || 0;\n\nif (action === 'OPEN' && side) {\n  const entryPremium = orchestration.signal_snapshot?.option_details?.entry_premium || null;\n  const stopPremium = orchestration.signal_snapshot?.option_details?.stop_premium || null;\n  const tpPremium = orchestration.signal_snapshot?.option_details?.tp_premium || null;\n  const contract = orchestration.signal_snapshot?.option_details?.contract_symbol || null;\n  positionSQL = `\nINSERT INTO trading.position_journal (\n  ticker, profile, trade_date, side, virtual_qty,\n  avg_entry_premium, current_stop, current_tp,\n  option_contract_symbol, status\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  ${sqlStr(side)}, ${Math.abs(qtyChange) || 1},\n  ${entryPremium != null ? entryPremium : 'NULL'},\n  ${stopPremium != null ? stopPremium : 'NULL'},\n  ${tpPremium != null ? tpPremium : 'NULL'},\n  ${contract ? sqlStr(contract) : 'NULL'},\n  'OPEN'\n)\nRETURNING *;\n`;\n} else if (action === 'CLOSE') {\n  positionSQL = `\nUPDATE trading.position_journal\nSET status = 'CLOSED', closed_at = NOW(),\n    close_reason = ${sqlStr(finalDecisionType)}\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\nRETURNING *;\n`;\n} else if (action === 'ADD' && qtyChange > 0) {\n  positionSQL = `\nUPDATE trading.position_journal\nSET virtual_qty = virtual_qty + ${qtyChange},\n    notes = COALESCE(notes, '') || ' | ADD@' || NOW()::text\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\nRETURNING *;\n`;\n} else if (action === 'REDUCE' && qtyChange < 0) {\n  positionSQL = `\nUPDATE trading.position_journal\nSET virtual_qty = GREATEST(0, virtual_qty + (${qtyChange})),\n    notes = COALESCE(notes, '') || ' | REDUCE@' || NOW()::text\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\nRETURNING *;\n`;\n} else if (action === 'REVERSE' && side) {\n  const entryPremium = orchestration.signal_snapshot?.option_details?.entry_premium || null;\n  positionSQL = `\nUPDATE trading.position_journal\nSET status = 'CLOSED', closed_at = NOW(),\n    close_reason = 'REVERSE'\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\nRETURNING *;\n\nINSERT INTO trading.position_journal (\n  ticker, profile, trade_date, side, virtual_qty,\n  avg_entry_premium, status\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  ${sqlStr(side)}, 1,\n  ${entryPremium != null ? entryPremium : 'NULL'},\n  'OPEN'\n)\nRETURNING *;\n`;\n}\n\n\n// ---- SQL: Create order_lifecycle INTENT row ----\n// When the orchestrator decides NEW_ENTRY, ADD_POSITION, or REVERSE,\n// create an INTENT row in order_lifecycle. This will be updated\n// to SUBMITTED when the actual Alpaca order is placed.\n// FIX: Added action === 'ADD' so ADD_POSITION also gets an INTENT row.\nlet lifecycleIntentSQL = '';\nif ((action === 'OPEN' || action === 'ADD' || action === 'REVERSE') && side) {\n  const contract = orchestration.signal_snapshot?.option_details?.contract_symbol || signalSummary.contract || null;\n  const entryPrem = orchestration.signal_snapshot?.option_details?.entry_premium || null;\n  const stopPrem = orchestration.signal_snapshot?.option_details?.stop_premium || null;\n  const tpPrem = orchestration.signal_snapshot?.option_details?.tp_premium || null;\n  const confAtOrder = decision.ai_confidence || null;\n  const trendAtOrder = signalSummary.trend || null;\n  const alignAtOrder = signalSummary.alignment || null;\n  const convScore = decision.entry_strategy?.confirmation_count || null;\n\n  lifecycleIntentSQL = `\nINSERT INTO trading.order_lifecycle (\n  ticker, profile, trade_date, decision_type,\n  contract_symbol, side, position_intent, order_type, time_in_force,\n  intended_entry, stop_level, target_level,\n  requested_qty, status,\n  confidence_at_order, trend_at_order, alignment_at_order,\n  conviction_score\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  ${sqlStr(finalDecisionType)},\n  ${sqlStr(contract || 'UNKNOWN')},\n  ${sqlStr(side.toLowerCase())}, 'buy_to_open', 'limit', 'day',\n  ${entryPrem != null ? entryPrem : 'NULL'},\n  ${stopPrem != null ? stopPrem : 'NULL'},\n  ${tpPrem != null ? tpPrem : 'NULL'},\n  ${Math.abs(qtyChange) || 1},\n  'INTENT',\n  ${confAtOrder != null ? confAtOrder : 'NULL'},\n  ${trendAtOrder ? sqlStr(trendAtOrder) : 'NULL'},\n  ${alignAtOrder ? sqlStr(alignAtOrder) : 'NULL'},\n  ${convScore != null ? convScore : 'NULL'}\n)\nRETURNING *;\n`;\n}\n\nconst combinedSQL = insertDecisionAndConfirmSQL + '\\n' + positionSQL + '\\n' + lifecycleIntentSQL;\n\n// ---- DEDUP: suppress repeated Telegram messages ----\nlet suppressTelegram = false;\n\n// ALWAYS suppress for WAIT and CONFIRM_HOLD \u2014 they have dedicated paths\nif (finalDecisionType === 'WAIT' || finalDecisionType === 'CONFIRM_HOLD') {\n  suppressTelegram = true;\n}\n\n// Additional dedup: suppress repeated identical decisions\nif (!suppressTelegram && lastDecision) {\n  const lastSigSum = lastDecision.signal_summary || {};\n  const lastSigDir = typeof lastSigSum === 'string' ? '' : (lastSigSum.option_decision || '');\n  const currSigDir = signalSummary.option_decision || '';\n\n  const sameDecisionType = (finalDecisionType === lastDecision.decision_type);\n  const sameSignalDir = (currSigDir === lastSigDir);\n\n  if (sameDecisionType && sameSignalDir) {\n    suppressTelegram = true;\n  }\n}\n// Never suppress actionable decisions (NEW_ENTRY, EXIT, REVERSE, ADD, REDUCE)\nconst actionableTypes = ['NEW_ENTRY', 'EXIT', 'REVERSE', 'ADD_POSITION', 'REDUCE_EXPOSURE'];\nif (actionableTypes.includes(finalDecisionType)) {\n  suppressTelegram = false;\n}\n\n// Build Telegram message for orchestration\nconst emoji = {\n  'NEW_ENTRY': '\ud83d\udfe2',\n  'CONFIRM_HOLD': '\ud83d\udd04',\n  'ADD_POSITION': '\u2b06\ufe0f',\n  'REDUCE_EXPOSURE': '\u2b07\ufe0f',\n  'REVERSE': '\ud83d\udd01',\n  'EXIT': '\ud83d\udeaa',\n  'WAIT': '\u23f3'\n};\n\nconst orchLines = [];\norchLines.push(`${emoji[finalDecisionType] || '\u2753'} AI Orchestrator: ${finalDecisionType}`);\norchLines.push(`Ticker: ${ticker} | Profile: ${profile}`);\norchLines.push(`Reasoning: ${decision.reasoning || 'n/a'}`);\norchLines.push(`AI Confidence: ${aiConf != null ? Math.round(aiConf * 100) + '%' : 'n/a'}`);\norchLines.push(`Signal: ${signalSummary.option_decision || 'n/a'} | conf=${signalSummary.confidence || 'n/a'} | trend=${signalSummary.trend || 'n/a'}`);\norchLines.push(`Alignment: ${signalSummary.alignment || 'n/a'}`);\norchLines.push(`Confirmation: ${confirmationType}`);\nif (liquidityOverridden) orchLines.push(`\\u26d4 LIQUIDITY GATE: ${decisionType} blocked \\u2192 WAIT (${liquidityReason})`);\nif (eodOverridden) orchLines.push(`\\u23f0 EOD GATE: ${decisionType} overridden \\u2192 EXIT (${minutesToClose} min to close  closing all positions)`);\nif (riskNotes) orchLines.push(`Risk: ${riskNotes}`);\nif (streakContext) orchLines.push(`Streak: ${streakContext}`);\nif (entryStrategy.stage && entryStrategy.stage !== 'NOT_APPLICABLE') orchLines.push(`Entry Strategy: ${entryStrategy.stage} (${entryStrategy.confirmation_count || 0}/${entryStrategy.confirmations_needed || 3} confirmations${entryStrategy.override_triggered ? ', OVERRIDE' : ''})`);\n\n// Return a SINGLE item so downstream nodes (Orchestration Telegram,\n// Persist Decision, Decision Router) execute exactly once.\nreturn [{\n  json: {\n    ...($json),\n    _suppress_telegram: suppressTelegram,\n    _orchestration_result: {\n      ticker: ticker,\n      profile: profile,\n      decision_type: finalDecisionType,\n      reasoning: decision.reasoning,\n      ai_confidence: aiConf,\n      position_action: posAction,\n      signal_summary: signalSummary,\n      confirmation_type: confirmationType,\n      entry_strategy: entryStrategy,\n      risk_notes: decision.risk_notes,\n      streak_context: decision.streak_context,\n      sql: combinedSQL,\n      telegram_text: orchLines.join('\\n')\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        37680,
        33056
      ],
      "id": "a1b2c3d4-0007-4000-8000-000000000007",
      "name": "Save Orchestration Decision"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._orchestration_result.sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        38000,
        33056
      ],
      "id": "a1b2c3d4-0008-4000-8000-000000000008",
      "name": "Persist Decision",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{ $('Save Orchestration Decision').first().json._orchestration_result.telegram_text.replace(/_/g,'\\\\_') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        38320,
        33056
      ],
      "id": "a1b2c3d4-0009-4000-8000-000000000009",
      "name": "Orchestration Telegram",
      "webhookId": "b2c3d4e5-1234-5678-9abc-def000000001",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "dedup-check",
              "leftValue": "={{ $json._suppress_telegram }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        38160,
        33056
      ],
      "id": "d1000001-0001-4000-8000-000000000001",
      "name": "Suppress Dup Telegram"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "sw-new-entry",
                    "leftValue": "={{ $json._orchestration_result.decision_type }}",
                    "rightValue": "NEW_ENTRY",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "NEW_ENTRY"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "sw-confirm-hold",
                    "leftValue": "={{ $json._orchestration_result.decision_type }}",
                    "rightValue": "CONFIRM_HOLD",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CONFIRM_HOLD"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "sw-add-position",
                    "leftValue": "={{ $json._orchestration_result.decision_type }}",
                    "rightValue": "ADD_POSITION",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ADD_POSITION"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "sw-reduce-exposure",
                    "leftValue": "={{ $json._orchestration_result.decision_type }}",
                    "rightValue": "REDUCE_EXPOSURE",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "REDUCE_EXPOSURE"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "sw-reverse",
                    "leftValue": "={{ $json._orchestration_result.decision_type }}",
                    "rightValue": "REVERSE",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "REVERSE"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "sw-exit",
                    "leftValue": "={{ $json._orchestration_result.decision_type }}",
                    "rightValue": "EXIT",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "EXIT"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "sw-wait",
                    "leftValue": "={{ $json._orchestration_result.decision_type }}",
                    "rightValue": "WAIT",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "WAIT"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        38640,
        33056
      ],
      "id": "a1b2c3d4-000a-4000-8000-000000000010",
      "name": "Decision Router"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Execute EXIT: Close all open positions for this ticker via Alpaca.\n// Builds the close-position request payload.\n// Downstream HTTP node will call DELETE /v2/positions/{symbol}\n\nconst orchResult = $json._orchestration_result || {};\nconst posAction = orchResult.position_action || {};\nconst signalSummary = orchResult.signal_summary || {};\nconst contract = signalSummary.contract || orchResult.signal_summary?.contract || null;\n\n// For options, we need the contract symbol to close\n// The orchestrator tracks virtual positions; for real execution we close via symbol\nconst ticker = orchResult.ticker || $json.ticker || 'UNKNOWN';\n\nreturn {\n  json: {\n    ...$json,\n    _exit_action: {\n      ticker,\n      contract_symbol: contract,\n      action: 'CLOSE_ALL',\n      reason: orchResult.decision_type,\n      reasoning: orchResult.reasoning || 'Exit signal from orchestrator'\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39040,
        33456
      ],
      "id": "b1000001-0001-4000-8000-000000000001",
      "name": "Prepare EXIT"
    },
    {
      "parameters": {
        "method": "DELETE",
        "url": "=https://paper-api.alpaca.markets/v2/positions/{{ $json._exit_action.contract_symbol || $json._exit_action.ticker }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        39360,
        33456
      ],
      "id": "b1000001-0002-4000-8000-000000000002",
      "name": "Close Position (EXIT)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// After EXIT close: Build Telegram notification\nconst exitAction = $json._exit_action || {};\nconst statusCode = $json.statusCode || $json.status || null;\nconst success = statusCode >= 200 && statusCode < 300;\nconst orchResult = $('Decision Router').first().json._orchestration_result || {};\n\nconst lines = [];\nlines.push(success ? '\ud83d\udeaa\u2705 EXIT Order Executed' : '\ud83d\udeaa\u274c EXIT Order Failed');\nlines.push(`Ticker: ${exitAction.ticker || 'n/a'}`);\nlines.push(`Contract: ${exitAction.contract_symbol || 'n/a'}`);\nlines.push(`Reason: ${exitAction.reasoning || 'n/a'}`);\nif (!success) lines.push(`Error: ${JSON.stringify($json.body || $json.error || 'unknown').substring(0, 200)}`);\n\nreturn {\n  json: {\n    telegram_text: lines.join('\\n'),\n    _exit_result: { success, statusCode }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39680,
        33456
      ],
      "id": "b1000001-0003-4000-8000-000000000003",
      "name": "Format EXIT Result"
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{ $('Format EXIT Result').first().json.telegram_text.replace(/_/g,'\\\\_') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        40000,
        33456
      ],
      "id": "b1000001-0004-4000-8000-000000000004",
      "name": "Telegram EXIT",
      "webhookId": "b1000001-tg01-4000-8000-000000000001",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Execute REDUCE_EXPOSURE: Partially close an existing position.\n// The orchestrator's position_action.qty_change tells us how many units to reduce.\n// We'll close that many contracts via Alpaca.\n\nconst orchResult = $json._orchestration_result || {};\nconst posAction = orchResult.position_action || {};\nconst signalSummary = orchResult.signal_summary || {};\nconst contract = signalSummary.contract || null;\nconst ticker = orchResult.ticker || $json.ticker || 'UNKNOWN';\nconst qtyToClose = Math.abs(posAction.qty_change || 1);\n\nreturn {\n  json: {\n    ...$json,\n    _reduce_action: {\n      ticker,\n      contract_symbol: contract,\n      qty_to_close: qtyToClose,\n      side: 'sell',\n      reason: orchResult.reasoning || 'Reduce exposure per orchestrator'\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39040,
        33656
      ],
      "id": "b1000002-0001-4000-8000-000000000001",
      "name": "Prepare REDUCE"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://paper-api.alpaca.markets/v2/orders",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "content-type",
              "value": "application/json"
            },
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"symbol\": \"{{ $json._reduce_action.contract_symbol }}\",\n  \"qty\": \"{{ $json._reduce_action.qty_to_close }}\",\n  \"side\": \"sell\",\n  \"type\": \"market\",\n  \"time_in_force\": \"day\",\n  \"position_intent\": \"sell_to_close\"\n}",
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        39360,
        33656
      ],
      "id": "b1000002-0002-4000-8000-000000000002",
      "name": "Sell to Close (REDUCE)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// After REDUCE close: Build Telegram notification\nconst reduceAction = $('Prepare REDUCE').first().json._reduce_action || {};\nconst statusCode = $json.statusCode || $json.status || null;\nconst success = statusCode >= 200 && statusCode < 300;\nconst orchResult = $('Decision Router').first().json._orchestration_result || {};\n\nconst lines = [];\nlines.push(success ? '\u2b07\ufe0f\u2705 REDUCE Order Executed' : '\u2b07\ufe0f\u274c REDUCE Order Failed');\nlines.push(`Ticker: ${reduceAction.ticker || 'n/a'}`);\nlines.push(`Contract: ${reduceAction.contract_symbol || 'n/a'}`);\nlines.push(`Qty Closed: ${reduceAction.qty_to_close || 'n/a'}`);\nlines.push(`Reason: ${reduceAction.reason || 'n/a'}`);\nif (!success) lines.push(`Error: ${JSON.stringify($json.body || $json.error || 'unknown').substring(0, 200)}`);\n\nreturn {\n  json: {\n    telegram_text: lines.join('\\n'),\n    _reduce_result: { success, statusCode }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39680,
        33656
      ],
      "id": "b1000002-0003-4000-8000-000000000003",
      "name": "Format REDUCE Result"
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{ $('Format REDUCE Result').first().json.telegram_text.replace(/_/g,'\\\\_') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        40000,
        33656
      ],
      "id": "b1000002-0004-4000-8000-000000000004",
      "name": "Telegram REDUCE",
      "webhookId": "b1000002-tg01-4000-8000-000000000001",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Execute REVERSE: Close existing position, then open opposite direction.\n// Step 1: Prepare close of existing position\n// Step 2 (downstream): Open new position in opposite direction via the order pipeline\n\nconst orchResult = $json._orchestration_result || {};\nconst posAction = orchResult.position_action || {};\nconst signalSummary = orchResult.signal_summary || {};\nconst contract = signalSummary.contract || null;\nconst ticker = orchResult.ticker || $json.ticker || 'UNKNOWN';\nconst newSide = posAction.side || null; // The new direction after reversal\n\nreturn {\n  json: {\n    ...$json,\n    _reverse_action: {\n      ticker,\n      close_contract: contract,\n      new_side: newSide,\n      reason: orchResult.reasoning || 'Reversal signal from orchestrator'\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39040,
        33856
      ],
      "id": "b1000003-0001-4000-8000-000000000001",
      "name": "Prepare REVERSE Close"
    },
    {
      "parameters": {
        "method": "DELETE",
        "url": "=https://paper-api.alpaca.markets/v2/positions/{{ $json._reverse_action.close_contract || $json._reverse_action.ticker }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "APCA-API-KEY-ID",
              "value": "=PK52GZ34XOEQZZMS75G54IQT3I"
            },
            {
              "name": "APCA-API-SECRET-KEY",
              "value": "=3xPVDT77uRiepNDnmRrCTotwdXD2yjgKYcHB94LuTHZV"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        39360,
        33856
      ],
      "id": "b1000003-0002-4000-8000-000000000002",
      "name": "Close Position (REVERSE)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// After REVERSE close: Build notification and forward to the order pipeline\n// to open the new position in opposite direction.\nconst reverseAction = $('Prepare REVERSE Close').first().json._reverse_action || {};\nconst statusCode = $json.statusCode || $json.status || null;\nconst closeSuccess = statusCode >= 200 && statusCode < 300;\nconst orchResult = $('Decision Router').first().json._orchestration_result || {};\n\nconst lines = [];\nlines.push(closeSuccess ? '\ud83d\udd01\u2705 REVERSE Close Executed' : '\ud83d\udd01\u274c REVERSE Close Failed');\nlines.push(`Ticker: ${reverseAction.ticker || 'n/a'}`);\nlines.push(`Closed: ${reverseAction.close_contract || 'n/a'}`);\nlines.push(`New Direction: ${reverseAction.new_side || 'n/a'}`);\nlines.push(`Reason: ${reverseAction.reason || 'n/a'}`);\nif (!closeSuccess) {\n  lines.push(`Error: ${JSON.stringify($json.body || $json.error || 'unknown').substring(0, 200)}`);\n  lines.push('\u26a0\ufe0f Skipping new entry due to close failure');\n}\n\nreturn {\n  json: {\n    telegram_text: lines.join('\\n'),\n    _reverse_close_success: closeSuccess,\n    _reverse_action: reverseAction,\n    _orchestration_result: orchResult\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39680,
        33856
      ],
      "id": "b1000003-0003-4000-8000-000000000003",
      "name": "Format REVERSE Close"
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{ $('Format REVERSE Close').first().json.telegram_text.replace(/_/g,'\\\\_') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        40000,
        33856
      ],
      "id": "b1000003-0004-4000-8000-000000000004",
      "name": "Telegram REVERSE Close",
      "webhookId": "b1000003-tg01-4000-8000-000000000001",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "reverse-close-ok",
              "leftValue": "={{ $json._reverse_close_success === true }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        40320,
        33856
      ],
      "id": "b1000003-0005-4000-8000-000000000005",
      "name": "If REVERSE Close OK"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// CONFIRM_HOLD: No trading action needed.\n// Just notify that we're holding the position.\n\nconst orchResult = $json._orchestration_result || {};\nconst posAction = orchResult.position_action || {};\nconst signalSummary = orchResult.signal_summary || {};\nconst orch = $json._orchestration || {};\nconst signal = orch.signal_snapshot || {};\nconst ticker = orchResult.ticker || signal.ticker || $json.ticker || 'UNKNOWN';\nconst profile = orchResult.profile || signal.profile || $json.profile || 'S';\nconst aiConf = orchResult.ai_confidence;\n\nconst optDecision = signal.ai_option_decision || signalSummary.option_decision || 'n/a';\nconst confidence = signal.confidence ?? signalSummary.confidence ?? null;\nconst trendDir = signal.trend_direction || signalSummary.trend || 'n/a';\n\nconst lines = [];\nlines.push('\ud83d\udd04 CONFIRM HOLD');\nlines.push(`Ticker: ${ticker} | Profile: ${profile}`);\nlines.push(`Reasoning: ${orchResult.reasoning || 'n/a'}`);\nlines.push(`AI Confidence: ${aiConf != null ? Math.round(aiConf * 100) + '%' : 'n/a'}`);\nlines.push(`Signal: ${optDecision} | conf=${confidence != null ? Math.round(confidence * 100) + '%' : 'n/a'} | trend=${trendDir}`);\nlines.push(`Position: ${posAction.side || 'n/a'} x${posAction.new_total_qty || 'n/a'}`);\nlines.push(`Confirmation: ${orchResult.confirmation_type || 'n/a'}`);\nif (orchResult.streak_context) lines.push(`Streak: ${orchResult.streak_context}`);\nif (orchResult.risk_notes) lines.push(`Risk: ${orchResult.risk_notes}`);\n\nreturn {\n  json: {\n    telegram_text: lines.join('\\n')\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39040,
        33056
      ],
      "id": "b1000004-0001-4000-8000-000000000001",
      "name": "Notify CONFIRM_HOLD"
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{ $('Notify CONFIRM_HOLD').first().json.telegram_text.replace(/_/g,'\\\\_') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        39360,
        33056
      ],
      "id": "b1000004-0002-4000-8000-000000000002",
      "name": "Telegram CONFIRM_HOLD",
      "webhookId": "b1000004-tg01-4000-8000-000000000001",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// WAIT: No trading action needed.\n// Notify that the orchestrator decided to wait.\n\nconst orchResult = $json._orchestration_result || {};\nconst signalSummary = orchResult.signal_summary || {};\nconst orch = $json._orchestration || {};\nconst signal = orch.signal_snapshot || {};\nconst ticker = orchResult.ticker || signal.ticker || $json.ticker || 'UNKNOWN';\nconst profile = orchResult.profile || signal.profile || $json.profile || 'S';\nconst aiConf = orchResult.ai_confidence;\n\n// Pull signal data: prefer orchestration signal_snapshot (richer), fallback to AI signal_summary\nconst optDecision = signal.ai_option_decision || signalSummary.option_decision || 'n/a';\nconst confidence = signal.confidence ?? signalSummary.confidence ?? null;\nconst trendDir = signal.trend_direction || signalSummary.trend || 'n/a';\nconst alignment = signal.alignment || 'n/a';\n\nconst lines = [];\nlines.push('\u23f3 WAIT \u2014 No Action');\nlines.push(`Ticker: ${ticker} | Profile: ${profile}`);\nlines.push(`Reasoning: ${orchResult.reasoning || 'n/a'}`);\nlines.push(`AI Confidence: ${aiConf != null ? Math.round(aiConf * 100) + '%' : 'n/a'}`);\nlines.push(`Signal: ${optDecision} | conf=${confidence != null ? Math.round(confidence * 100) + '%' : 'n/a'} | trend=${trendDir}`);\nlines.push(`Alignment: ${alignment}`);\nlines.push(`Confirmation: ${orchResult.confirmation_type || 'n/a'}`);\nif (orchResult.risk_notes) lines.push(`Risk: ${orchResult.risk_notes}`);\nif (orchResult.streak_context) lines.push(`Streak: ${orchResult.streak_context}`);\n\nreturn {\n  json: {\n    telegram_text: lines.join('\\n')\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39040,
        34056
      ],
      "id": "b1000005-0001-4000-8000-000000000001",
      "name": "Notify WAIT"
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{ $('Notify WAIT').first().json.telegram_text.replace(/_/g,'\\\\_') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        39360,
        34056
      ],
      "id": "b1000005-0002-4000-8000-000000000002",
      "name": "Telegram WAIT",
      "webhookId": "b1000005-tg01-4000-8000-000000000001",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build EXIT Persist SQL\n// Records the actual Alpaca API execution result in order_executions\n// and updates position_journal to reflect the real close.\n// RETURNING * ensures the Postgres node output contains the inserted row.\n//\n// FIX: Use dollar-quoting for all embedded JSON/text to prevent SQL\n// syntax errors from backslashes, nested quotes, or special chars.\n// Removed passthroughSQL \u2014 data passes through via return object.\n\nfunction sqlStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction sqlJsonb(obj) {\n  if (obj === null || obj === undefined) return 'NULL';\n  try {\n    const s = typeof obj === 'string' ? obj : JSON.stringify(obj);\n    return '$ej$' + s + '$ej$::jsonb';\n  } catch { return \"'{}'::jsonb\"; }\n}\nfunction sqlText(val, maxLen) {\n  if (val === null || val === undefined) return 'NULL';\n  let s = String(val);\n  if (maxLen) s = s.substring(0, maxLen);\n  return '$et$' + s + '$et$';\n}\n\nconst orchResult = $('Decision Router').first().json._orchestration_result || {};\nconst exitAction = $('Prepare EXIT').first().json._exit_action || {};\nconst exitResult = $json._exit_result || {};\nconst ticker = exitAction.ticker || orchResult.ticker || 'UNKNOWN';\nconst profile = $('Decision Router').first().json.profile || 'S';\nconst today = new Date().toISOString().slice(0, 10);\nconst now = new Date().toISOString();\n\n// Parse Alpaca response\nconst respBody = $json.body || $json.data || $json;\nconst alpacaOrderId = respBody?.id || null;\nconst alpacaStatus = respBody?.status || null;\nconst fillPrice = respBody?.filled_avg_price || null;\nconst filledQty = respBody?.filled_qty || null;\nconst httpStatus = exitResult.statusCode || null;\nconst success = exitResult.success === true;\nlet errorMsg = null;\nif (!success) {\n  try { errorMsg = String(respBody?.message || respBody?.error || JSON.stringify(respBody || {})).substring(0, 500); }\n  catch { errorMsg = 'Error serializing response'; }\n}\n\n// SQL: Insert into order_executions\nconst insertExecSQL = `\nINSERT INTO trading.order_executions (\n  ticker, profile, trade_date, decision_type, execution_action,\n  contract_symbol, side, order_type,\n  request_payload, alpaca_order_id, alpaca_status,\n  fill_price, filled_qty, http_status_code, response_payload,\n  success, error_message, orchestration_reasoning, ai_confidence\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  'EXIT', 'CLOSE_ALL',\n  ${sqlStr(exitAction.contract_symbol)},\n  'sell', 'delete_position',\n  ${sqlJsonb(exitAction)},\n  ${sqlStr(alpacaOrderId)},\n  ${sqlStr(alpacaStatus)},\n  ${fillPrice != null ? fillPrice : 'NULL'},\n  ${filledQty != null ? filledQty : 'NULL'},\n  ${httpStatus != null ? httpStatus : 'NULL'},\n  ${sqlJsonb(respBody)},\n  ${success},\n  ${errorMsg ? sqlText(errorMsg, 500) : 'NULL'},\n  ${sqlText(orchResult.reasoning, 2000)},\n  ${orchResult.ai_confidence != null ? orchResult.ai_confidence : 'NULL'}\n)\nRETURNING *;\n`;\n\n// SQL: Update position_journal \u2014 mark position as actually closed\nconst updatePosSQL = success ? `\nUPDATE trading.position_journal\nSET status = 'CLOSED',\n    closed_at = NOW(),\n    close_reason = 'EXIT_EXECUTED',\n    exit_price = ${fillPrice != null ? fillPrice : 'NULL'},\n    exit_time = NOW(),\n    exit_reason = 'EXIT_EXECUTED',\n    notes = COALESCE(notes, '') || ${sqlText(' | EXIT executed@' + now + ' alpaca_id=' + (alpacaOrderId || 'n/a'))}\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\nRETURNING *;\n` : '';\n\n\n// ---- SQL: Update order_lifecycle to CLOSED ----\nconst lifecycleExitSQL = success ? `\nUPDATE trading.order_lifecycle\nSET status = 'CLOSED',\n    close_reason = 'EXIT_SIGNAL',\n    close_fill_price = ${fillPrice != null ? fillPrice : 'NULL'},\n    close_order_id = ${sqlStr(alpacaOrderId)},\n    closed_at = NOW(),\n    updated_at = NOW()\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status IN ('MONITORING', 'FILLED', 'ACCEPTED', 'SUBMITTED')\nRETURNING *;\n` : '';\n\nreturn {\n  json: {\n    ...$json,\n    _persist_sql: insertExecSQL + '\\n' + lifecycleExitSQL + '\\n' + updatePosSQL\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39840,
        33336
      ],
      "id": "c2000001-0001-4000-8000-000000000001",
      "name": "Build EXIT Persist SQL"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._persist_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        40160,
        33336
      ],
      "id": "c2000001-0002-4000-8000-000000000002",
      "name": "Persist EXIT",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build REDUCE Persist SQL\n// Records the Alpaca sell-to-close result in order_executions\n// and updates position_journal to reflect the partial close.\n// RETURNING * ensures the Postgres node output contains the inserted/updated rows.\n//\n// FIX: Use dollar-quoting for all embedded JSON/text to prevent SQL\n// syntax errors. Removed passthroughSQL \u2014 data passes through via return object.\n\nfunction sqlStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction sqlJsonb(obj) {\n  if (obj === null || obj === undefined) return 'NULL';\n  try {\n    const s = typeof obj === 'string' ? obj : JSON.stringify(obj);\n    return '$rj$' + s + '$rj$::jsonb';\n  } catch { return \"'{}'::jsonb\"; }\n}\nfunction sqlText(val, maxLen) {\n  if (val === null || val === undefined) return 'NULL';\n  let s = String(val);\n  if (maxLen) s = s.substring(0, maxLen);\n  return '$rt$' + s + '$rt$';\n}\n\nconst orchResult = $('Decision Router').first().json._orchestration_result || {};\nconst reduceAction = $('Prepare REDUCE').first().json._reduce_action || {};\nconst reduceResult = $json._reduce_result || {};\nconst ticker = reduceAction.ticker || orchResult.ticker || 'UNKNOWN';\nconst profile = $('Decision Router').first().json.profile || 'S';\nconst today = new Date().toISOString().slice(0, 10);\nconst now = new Date().toISOString();\n\n// Parse Alpaca response\nconst respBody = $json.body || $json.data || $json;\nconst alpacaOrderId = respBody?.id || null;\nconst alpacaStatus = respBody?.status || null;\nconst fillPrice = respBody?.filled_avg_price || null;\nconst filledQty = respBody?.filled_qty || null;\nconst httpStatus = reduceResult.statusCode || null;\nconst success = reduceResult.success === true;\nconst qtyToClose = reduceAction.qty_to_close || 1;\nlet errorMsg = null;\nif (!success) {\n  try { errorMsg = String(respBody?.message || respBody?.error || JSON.stringify(respBody || {})).substring(0, 500); }\n  catch { errorMsg = 'Error serializing response'; }\n}\n\n// SQL: Insert into order_executions\nconst insertExecSQL = `\nINSERT INTO trading.order_executions (\n  ticker, profile, trade_date, decision_type, execution_action,\n  contract_symbol, side, qty, order_type,\n  request_payload, alpaca_order_id, alpaca_status,\n  fill_price, filled_qty, http_status_code, response_payload,\n  success, error_message, orchestration_reasoning, ai_confidence\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  'REDUCE_EXPOSURE', 'SELL_PARTIAL',\n  ${sqlStr(reduceAction.contract_symbol)},\n  'sell', ${qtyToClose}, 'market',\n  ${sqlJsonb(reduceAction)},\n  ${sqlStr(alpacaOrderId)},\n  ${sqlStr(alpacaStatus)},\n  ${fillPrice != null ? fillPrice : 'NULL'},\n  ${filledQty != null ? filledQty : 'NULL'},\n  ${httpStatus != null ? httpStatus : 'NULL'},\n  ${sqlJsonb(respBody)},\n  ${success},\n  ${errorMsg ? sqlText(errorMsg, 500) : 'NULL'},\n  ${sqlText(orchResult.reasoning, 2000)},\n  ${orchResult.ai_confidence != null ? orchResult.ai_confidence : 'NULL'}\n)\nRETURNING *;\n`;\n\n// SQL: Update position_journal \u2014 reduce qty, or close if qty reaches 0\nconst updatePosSQL = success ? `\nUPDATE trading.position_journal\nSET virtual_qty = GREATEST(0, virtual_qty - ${qtyToClose}),\n    notes = COALESCE(notes, '') || ${sqlText(' | REDUCE_EXECUTED -' + qtyToClose + '@' + now + ' alpaca_id=' + (alpacaOrderId || 'n/a'))}\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\nRETURNING *;\n\n-- Auto-close position if qty is now 0\nUPDATE trading.position_journal\nSET status = 'CLOSED',\n    closed_at = NOW(),\n    close_reason = 'REDUCE_TO_ZERO',\n    exit_price = ${fillPrice != null ? fillPrice : 'NULL'},\n    exit_time = NOW(),\n    exit_reason = 'REDUCE_TO_ZERO'\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\n  AND virtual_qty <= 0\nRETURNING *;\n` : '';\n\n\n// ---- SQL: Update order_lifecycle for REDUCE ----\n// Create a new order_lifecycle row for the reduce order\n// FIX: contract_symbol is NOT NULL, default to 'UNKNOWN'\nconst lifecycleReduceSQL = success ? `\nINSERT INTO trading.order_lifecycle (\n  ticker, profile, trade_date, decision_type,\n  alpaca_order_id, contract_symbol,\n  side, position_intent, order_type, time_in_force,\n  requested_qty, filled_qty, avg_fill_price,\n  status, close_reason, closed_at, updated_at\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  'REDUCE_EXPOSURE',\n  ${sqlStr(alpacaOrderId)},\n  ${sqlStr(reduceAction.contract_symbol || 'UNKNOWN')},\n  'sell', 'sell_to_close', 'market', 'day',\n  ${qtyToClose}, ${filledQty != null ? filledQty : 0},\n  ${fillPrice != null ? fillPrice : 'NULL'},\n  'CLOSED', 'REDUCE', NOW(), NOW()\n)\nON CONFLICT (alpaca_order_id) WHERE alpaca_order_id IS NOT NULL\nDO UPDATE SET status = 'CLOSED', closed_at = NOW(), updated_at = NOW()\nRETURNING *;\n` : '';\n\nreturn {\n  json: {\n    ...$json,\n    _persist_sql: insertExecSQL + '\\n' + lifecycleReduceSQL + '\\n' + updatePosSQL\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39840,
        33536
      ],
      "id": "c2000002-0001-4000-8000-000000000001",
      "name": "Build REDUCE Persist SQL"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._persist_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        40160,
        33536
      ],
      "id": "c2000002-0002-4000-8000-000000000002",
      "name": "Persist REDUCE",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build REVERSE Persist SQL\n// Records the Alpaca close-for-reverse result in order_executions\n// and updates position_journal to close the old position.\n// The new position (opposite direction) will be opened by the order pipeline\n// if If REVERSE Close OK passes.\n// RETURNING * ensures the Postgres node output contains the inserted/updated rows.\n//\n// FIX: Use dollar-quoting for all embedded JSON/text to prevent SQL\n// syntax errors. Removed passthroughSQL \u2014 data passes through via return object.\n\nfunction sqlStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction sqlJsonb(obj) {\n  if (obj === null || obj === undefined) return 'NULL';\n  try {\n    const s = typeof obj === 'string' ? obj : JSON.stringify(obj);\n    return '$vj$' + s + '$vj$::jsonb';\n  } catch { return \"'{}'::jsonb\"; }\n}\nfunction sqlText(val, maxLen) {\n  if (val === null || val === undefined) return 'NULL';\n  let s = String(val);\n  if (maxLen) s = s.substring(0, maxLen);\n  return '$vt$' + s + '$vt$';\n}\n\nconst orchResult = $('Decision Router').first().json._orchestration_result || {};\nconst reverseAction = $('Prepare REVERSE Close').first().json._reverse_action || {};\nconst success = $json._reverse_close_success === true;\nconst ticker = reverseAction.ticker || orchResult.ticker || 'UNKNOWN';\nconst profile = $('Decision Router').first().json.profile || 'S';\nconst today = new Date().toISOString().slice(0, 10);\nconst now = new Date().toISOString();\n\n// Parse Alpaca response from upstream Close Position (REVERSE) node\nlet respBody = {};\ntry {\n  respBody = $('Close Position (REVERSE)').first().json || {};\n  if (respBody.body) respBody = respBody.body;\n} catch { respBody = {}; }\nconst alpacaOrderId = respBody?.id || null;\nconst alpacaStatus = respBody?.status || null;\nconst fillPrice = respBody?.filled_avg_price || null;\nconst filledQty = respBody?.filled_qty || null;\nconst httpStatus = respBody?.statusCode || null;\nlet errorMsg = null;\nif (!success) {\n  try { errorMsg = String(respBody?.message || respBody?.error || JSON.stringify(respBody || {})).substring(0, 500); }\n  catch { errorMsg = 'Error serializing response'; }\n}\n\n// SQL: Insert into order_executions\nconst insertExecSQL = `\nINSERT INTO trading.order_executions (\n  ticker, profile, trade_date, decision_type, execution_action,\n  contract_symbol, side, order_type,\n  request_payload, alpaca_order_id, alpaca_status,\n  fill_price, filled_qty, http_status_code, response_payload,\n  success, error_message, orchestration_reasoning, ai_confidence\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  'REVERSE', 'CLOSE_FOR_REVERSE',\n  ${sqlStr(reverseAction.close_contract)},\n  'sell', 'delete_position',\n  ${sqlJsonb(reverseAction)},\n  ${sqlStr(alpacaOrderId)},\n  ${sqlStr(alpacaStatus)},\n  ${fillPrice != null ? fillPrice : 'NULL'},\n  ${filledQty != null ? filledQty : 'NULL'},\n  ${httpStatus != null ? httpStatus : 'NULL'},\n  ${sqlJsonb(respBody)},\n  ${success},\n  ${errorMsg ? sqlText(errorMsg, 500) : 'NULL'},\n  ${sqlText(orchResult.reasoning, 2000)},\n  ${orchResult.ai_confidence != null ? orchResult.ai_confidence : 'NULL'}\n)\nRETURNING *;\n`;\n\n// SQL: Update position_journal \u2014 close old position for reversal\nconst updatePosSQL = success ? `\nUPDATE trading.position_journal\nSET status = 'CLOSED',\n    closed_at = NOW(),\n    close_reason = 'REVERSE_EXECUTED',\n    exit_price = ${fillPrice != null ? fillPrice : 'NULL'},\n    exit_time = NOW(),\n    exit_reason = 'REVERSE_EXECUTED',\n    notes = COALESCE(notes, '') || ${sqlText(' | REVERSE close@' + now + ' alpaca_id=' + (alpacaOrderId || 'n/a') + ' new_side=' + (reverseAction.new_side || 'n/a'))}\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\nRETURNING *;\n` : '';\n\n\n// ---- SQL: Update order_lifecycle for REVERSE (close old position) ----\nconst lifecycleReverseSQL = success ? `\nUPDATE trading.order_lifecycle\nSET status = 'CLOSED',\n    close_reason = 'REVERSE',\n    close_fill_price = ${fillPrice != null ? fillPrice : 'NULL'},\n    close_order_id = ${sqlStr(alpacaOrderId)},\n    closed_at = NOW(),\n    updated_at = NOW()\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status IN ('MONITORING', 'FILLED', 'ACCEPTED', 'SUBMITTED')\nRETURNING *;\n` : '';\n\nreturn {\n  json: {\n    ...$json,\n    _persist_sql: insertExecSQL + '\\n' + lifecycleReverseSQL + '\\n' + updatePosSQL\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39840,
        33736
      ],
      "id": "c2000003-0001-4000-8000-000000000001",
      "name": "Build REVERSE Persist SQL"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._persist_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        40160,
        33736
      ],
      "id": "c2000003-0002-4000-8000-000000000002",
      "name": "Persist REVERSE",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build ORDER Persist SQL\n// Records the Alpaca Submit Order result (for NEW_ENTRY, ADD_POSITION, REVERSE new-leg)\n// into order_executions so the orchestrator can track what really happened.\n// RETURNING * ensures the Postgres node output contains the inserted/updated rows.\n//\n// Upstream chain: Submit Order \u2192 Normalize Order \u2192 (this node)\n// We read from Normalize Order output and reach back to Decision Router for orchestration context.\n//\n// FIX: Use dollar-quoting ($$...$$) for ALL embedded JSON/text values instead\n// of single-quote escaping. Single-quote escaping breaks when the Alpaca API\n// response contains backslashes, nested quotes, or special chars \u2014 causing the\n// entire multi-statement SQL batch to fail silently (continueOnFail swallows\n// the Postgres error, so order_executions rows were never inserted).\n//\n// FIX: Removed passthroughSQL (SELECT '...'::jsonb) which double-stringified\n// the full Alpaca response into a SQL string literal, frequently causing\n// syntax errors. Downstream nodes can use $('Build ORDER Persist SQL').first()\n// or $('Normalize Order').first() to access input data directly.\n//\n// FIX: contract_symbol in order_lifecycle is NOT NULL, so use COALESCE\n// to default to 'UNKNOWN' instead of NULL which would abort the INSERT.\n\n// Safe SQL string escaper: replaces single quotes for SQL string literals\nfunction sqlStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\n\n// Dollar-quoted JSON for safe embedding of complex payloads\n// Uses tagged dollar-quoting to avoid collisions\nfunction sqlJsonb(obj) {\n  if (obj === null || obj === undefined) return 'NULL';\n  try {\n    const s = typeof obj === 'string' ? obj : JSON.stringify(obj);\n    return '$json$' + s + '$json$::jsonb';\n  } catch {\n    return \"'{}'::jsonb\";\n  }\n}\n\n// Dollar-quoted text for safe embedding of long text with special chars\nfunction sqlText(val, maxLen) {\n  if (val === null || val === undefined) return 'NULL';\n  let s = String(val);\n  if (maxLen) s = s.substring(0, maxLen);\n  return '$txt$' + s + '$txt$';\n}\n\nlet orchResult = {};\nlet profile = 'S';\ntry {\n  const drData = $('Decision Router').first().json || {};\n  orchResult = drData._orchestration_result || {};\n  profile = drData.profile || 'S';\n} catch {\n  orchResult = $json._orchestration_result || {};\n}\n\nconst ticker = orchResult.ticker || 'UNKNOWN';\nconst today = new Date().toISOString().slice(0, 10);\nconst now = new Date().toISOString();\n\n// Determine decision type from orchestration\nconst decisionType = orchResult.decision_type || 'NEW_ENTRY';\n\n// The upstream Normalize Order node provides the flattened order data\nconst isError = ($json.status === 'API_ERROR') || (!$json.id && !$json.status);\nconst success = !isError && $json.id != null;\nconst alpacaOrderId = $json.id || null;\nconst alpacaStatus = $json.status || null;\nconst side = $json.side || null;\nconst qty = $json.qty || null;\nconst orderType = $json.type || null;\nconst contractSymbol = $json.symbol || null;\nconst limitPrice = $json.limit_price || null;\n\n// Parse response payload for storage\nlet responsePayload = {};\ntry {\n  responsePayload = $json.order_json ? JSON.parse($json.order_json) : $json;\n} catch {\n  responsePayload = { raw: String($json.order_json || '').substring(0, 2000) };\n}\n\n// Build a safe error message (truncated, no SQL-breaking chars)\nlet errorMsg = null;\nif (!success) {\n  try {\n    errorMsg = String($json.order_json || JSON.stringify($json || {})).substring(0, 500);\n  } catch {\n    errorMsg = 'Error serializing response';\n  }\n}\n\n// Determine execution_action based on decision type\nlet executionAction = 'BUY_TO_OPEN';\nif (decisionType === 'ADD_POSITION') executionAction = 'BUY_TO_ADD';\nelse if (decisionType === 'REVERSE') executionAction = 'BUY_TO_OPEN_REVERSE';\nelse executionAction = 'BUY_TO_OPEN';\n\n// Build request payload for audit\nconst requestPayload = { symbol: contractSymbol, side, qty, type: orderType, limit_price: limitPrice };\n\nconst insertExecSQL = `\nINSERT INTO trading.order_executions (\n  ticker, profile, trade_date, decision_type, execution_action,\n  contract_symbol, side, qty, order_type,\n  request_payload, alpaca_order_id, alpaca_status,\n  fill_price, filled_qty, http_status_code, response_payload,\n  success, error_message, orchestration_reasoning, ai_confidence\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  ${sqlStr(decisionType)}, ${sqlStr(executionAction)},\n  ${sqlStr(contractSymbol)},\n  ${sqlStr(side)},\n  ${qty != null ? qty : 'NULL'},\n  ${sqlStr(orderType)},\n  ${sqlJsonb(requestPayload)},\n  ${sqlStr(alpacaOrderId)},\n  ${sqlStr(alpacaStatus)},\n  NULL, NULL, NULL,\n  ${sqlJsonb(responsePayload)},\n  ${success},\n  ${errorMsg ? sqlText(errorMsg, 500) : 'NULL'},\n  ${sqlText(orchResult.reasoning, 2000)},\n  ${orchResult.ai_confidence != null ? orchResult.ai_confidence : 'NULL'}\n)\nRETURNING *;\n`;\n\n\n// ---- SQL: Create order_lifecycle row ----\n// Track this order in the unified order lifecycle table.\n// FIX: contract_symbol is NOT NULL in schema, so default to 'UNKNOWN'\nconst lifecycleSQL = success ? `\nINSERT INTO trading.order_lifecycle (\n  ticker, profile, trade_date, decision_type,\n  client_order_id, alpaca_order_id, contract_symbol,\n  side, position_intent, order_type, time_in_force,\n  limit_price, intended_entry, requested_qty,\n  filled_qty, avg_fill_price,\n  status, confidence_at_order, trend_at_order, alignment_at_order,\n  submitted_at, accepted_at\n) VALUES (\n  ${sqlStr(ticker)}, ${sqlStr(profile)}, ${sqlStr(today)},\n  ${sqlStr(decisionType)},\n  NULL, ${sqlStr(alpacaOrderId)},\n  ${sqlStr(contractSymbol || 'UNKNOWN')},\n  ${sqlStr(side || 'buy')},\n  'buy_to_open', ${sqlStr(orderType || 'limit')},\n  'day',\n  ${limitPrice != null ? limitPrice : 'NULL'},\n  ${limitPrice != null ? limitPrice : 'NULL'},\n  ${qty != null ? qty : 1},\n  0, NULL,\n  'SUBMITTED',\n  ${orchResult.ai_confidence != null ? orchResult.ai_confidence : 'NULL'},\n  ${orchResult.signal_summary?.trend ? sqlStr(orchResult.signal_summary.trend) : 'NULL'},\n  ${orchResult.signal_summary?.alignment ? sqlStr(orchResult.signal_summary.alignment) : 'NULL'},\n  NOW(), NULL\n)\nON CONFLICT (alpaca_order_id) WHERE alpaca_order_id IS NOT NULL\nDO UPDATE SET\n  status = 'SUBMITTED',\n  filled_qty = 0,\n  updated_at = NOW()\nRETURNING *;\n` : '';\n\n// If NEW_ENTRY success, also update position_journal with real Alpaca order ID\nconst updatePosSQL = success ? `\nUPDATE trading.position_journal\nSET notes = COALESCE(notes, '') || ${sqlText(' | ORDER_PLACED alpaca_id=' + (alpacaOrderId || 'n/a') + ' status=' + (alpacaStatus || 'n/a') + '@' + now)}\nWHERE ticker = ${sqlStr(ticker)}\n  AND trade_date = ${sqlStr(today)}\n  AND status = 'OPEN'\nRETURNING *;\n` : '';\n\nreturn {\n  json: {\n    ...$json,\n    _persist_order_sql: insertExecSQL + '\\n' + lifecycleSQL + '\\n' + updatePosSQL\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        37200,
        33924
      ],
      "id": "c2000004-0001-4000-8000-000000000001",
      "name": "Build ORDER Persist SQL"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._persist_order_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        37520,
        33924
      ],
      "id": "c2000004-0002-4000-8000-000000000002",
      "name": "Persist ORDER",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build HOLD Persist SQL\n// Records CONFIRM_HOLD decision in order_executions.\n// No API call is made (no position change), but we persist the decision\n// so the orchestrator can see the full execution history.\n// RETURNING * ensures the Postgres node output contains the inserted row.\n//\n// FIX: Removed the passthrough SELECT statement. The old code appended\n// a `SELECT '{...}'::jsonb AS _input_data` after the INSERT...RETURNING *,\n// causing Postgres to return 2 result rows. Since Telegram CONFIRM_HOLD\n// runs once per item, this caused the CONFIRM_HOLD Telegram message to\n// be sent twice. The INSERT...RETURNING * alone is sufficient \u2014 it returns\n// one row with all the inserted data, and downstream nodes can reference\n// upstream nodes directly via $('Notify CONFIRM_HOLD') etc.\n//\n// FIX: Read orchestration data from Decision Router node directly,\n// because Notify CONFIRM_HOLD only outputs telegram_text and does not\n// pass through _orchestration_result or ticker.\n\nlet orchResult = {};\nlet profile = 'S';\ntry {\n  const drData = $('Decision Router').first().json || {};\n  orchResult = drData._orchestration_result || {};\n  profile = drData.profile || orchResult.profile || 'S';\n} catch {\n  orchResult = $json._orchestration_result || {};\n}\n\nconst posAction = orchResult.position_action || {};\nconst signalSummary = orchResult.signal_summary || {};\nconst ticker = orchResult.ticker || $json.ticker || 'UNKNOWN';\nconst today = new Date().toISOString().slice(0, 10);\n\nconst insertExecSQL = `\nINSERT INTO trading.order_executions (\n  ticker, profile, trade_date, decision_type, execution_action,\n  contract_symbol, side, qty, order_type,\n  request_payload, alpaca_order_id, alpaca_status,\n  fill_price, filled_qty, http_status_code, response_payload,\n  success, error_message, orchestration_reasoning, ai_confidence\n) VALUES (\n  '${ticker}', '${profile}', '${today}',\n  'CONFIRM_HOLD', 'NONE',\n  ${signalSummary.contract ? \"'\" + signalSummary.contract + \"'\" : 'NULL'},\n  ${posAction.side ? \"'\" + posAction.side.toLowerCase() + \"'\" : 'NULL'},\n  ${posAction.new_total_qty || 'NULL'},\n  NULL,\n  '${JSON.stringify({ decision_type: 'CONFIRM_HOLD', position_action: posAction, signal_summary: signalSummary }).replace(/'/g, \"''\")}'::jsonb,\n  NULL, NULL, NULL, NULL, NULL,\n  '{}'::jsonb,\n  true, NULL,\n  '${(orchResult.reasoning || '').replace(/'/g, \"''\").substring(0, 2000)}',\n  ${orchResult.ai_confidence != null ? orchResult.ai_confidence : 'NULL'}\n)\nRETURNING *;\n`;\n\nreturn {\n  json: {\n    ...$json,\n    _persist_sql: insertExecSQL\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39040,
        32856
      ],
      "id": "c2000005-0001-4000-8000-000000000001",
      "name": "Build HOLD Persist SQL"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._persist_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        39360,
        32856
      ],
      "id": "c2000005-0002-4000-8000-000000000002",
      "name": "Persist HOLD",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build WAIT Persist SQL\n// Records WAIT decision in order_executions.\n// No API call is made (no action taken), but we persist the decision\n// so the orchestrator can see the full execution history.\n// RETURNING * ensures the Postgres node output contains the inserted row.\n//\n// FIX: Removed the passthrough SELECT statement. The old code appended\n// a `SELECT '{...}'::jsonb AS _input_data` after the INSERT...RETURNING *,\n// causing Postgres to return 2 result rows. Since Telegram WAIT runs\n// once per item, this caused the WAIT Telegram message to be sent twice.\n// The INSERT...RETURNING * alone is sufficient \u2014 it returns one row with\n// all the inserted data, and downstream nodes can reference upstream\n// nodes directly via $('Notify WAIT') etc.\n//\n// FIX: Read orchestration data from Decision Router node directly,\n// because Notify WAIT only outputs telegram_text and does not pass\n// through _orchestration_result or ticker.\n\nlet orchResult = {};\nlet profile = 'S';\ntry {\n  const drData = $('Decision Router').first().json || {};\n  orchResult = drData._orchestration_result || {};\n  profile = drData.profile || orchResult.profile || 'S';\n} catch {\n  orchResult = $json._orchestration_result || {};\n}\n\nconst signalSummary = orchResult.signal_summary || {};\nconst ticker = orchResult.ticker || $json.ticker || 'UNKNOWN';\nconst today = new Date().toISOString().slice(0, 10);\n\nconst insertExecSQL = `\nINSERT INTO trading.order_executions (\n  ticker, profile, trade_date, decision_type, execution_action,\n  contract_symbol, side, qty, order_type,\n  request_payload, alpaca_order_id, alpaca_status,\n  fill_price, filled_qty, http_status_code, response_payload,\n  success, error_message, orchestration_reasoning, ai_confidence\n) VALUES (\n  '${ticker}', '${profile}', '${today}',\n  'WAIT', 'NONE',\n  NULL, NULL, NULL, NULL,\n  '${JSON.stringify({ decision_type: 'WAIT', signal_summary: signalSummary }).replace(/'/g, \"''\")}'::jsonb,\n  NULL, NULL, NULL, NULL, NULL,\n  '{}'::jsonb,\n  true, NULL,\n  '${(orchResult.reasoning || '').replace(/'/g, \"''\").substring(0, 2000)}',\n  ${orchResult.ai_confidence != null ? orchResult.ai_confidence : 'NULL'}\n)\nRETURNING *;\n`;\n\nreturn {\n  json: {\n    ...$json,\n    _persist_sql: insertExecSQL\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        39040,
        34256
      ],
      "id": "c2000006-0001-4000-8000-000000000001",
      "name": "Build WAIT Persist SQL"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._persist_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        39360,
        34256
      ],
      "id": "c2000006-0002-4000-8000-000000000002",
      "name": "Persist WAIT",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Gather Trade Data \u2014 Step 1: Build SQL to fetch entry + exit lifecycle\n// This node runs AFTER Persist EXIT / Persist REDUCE / Persist REVERSE.\n// $json contains the Postgres RETURNING * output from the Persist node.\n//\n// We build a SQL query to pull the COMPLETE trade lifecycle from the database:\n//   - position_journal: entry price, side, qty, entry time, contract\n//   - order_executions: exit fill price, filled qty, status\n//   - trading_decisions: orchestration reasoning, confidence, trend\n\nfunction safeNum(x) {\n  if (x == null) return null;\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n}\n\n// Get ticker and profile from orchestration context or persist output\nlet orchResult = {};\nlet profile = 'S';\nlet ticker = 'UNKNOWN';\n\ntry {\n  const drData = $('Decision Router').first().json || {};\n  orchResult = drData._orchestration_result || {};\n  profile = drData.profile || orchResult.profile || 'S';\n  ticker = orchResult.ticker || drData.ticker || 'UNKNOWN';\n} catch {\n  orchResult = {};\n}\n\n// Also try to get ticker from persist output (RETURNING * rows)\nif (ticker === 'UNKNOWN') {\n  ticker = $json.ticker || 'UNKNOWN';\n}\n\nconst today = new Date().toISOString().slice(0, 10);\n\n// Determine decision type from upstream Prepare nodes\nlet decisionType = 'UNKNOWN';\ntry { if ($('Prepare EXIT').first().json._exit_action) decisionType = 'EXIT'; } catch {}\nif (decisionType === 'UNKNOWN') {\n  try { if ($('Prepare REDUCE').first().json._reduce_action) decisionType = 'REDUCE_EXPOSURE'; } catch {}\n}\nif (decisionType === 'UNKNOWN') {\n  try { if ($('Prepare REVERSE Close').first().json._reverse_action) decisionType = 'REVERSE'; } catch {}\n}\n\n// Build SQL to fetch complete trade lifecycle from DB\n// This is THE source of truth \u2014 not in-memory node references\nconst fetchSQL = `\nSELECT\n  -- Entry data from position_journal\n  pj.ticker,\n  pj.profile,\n  pj.trade_date,\n  pj.side AS entry_side,\n  COALESCE(pj.option_contract_symbol, pj.contract_symbol) AS contract_symbol,\n  pj.avg_entry_premium AS entry_price,\n  pj.entry_time,\n  COALESCE(pj.virtual_qty, pj.qty, 1) AS entry_qty,\n  pj.current_stop,\n  pj.current_tp,\n  pj.status AS position_status,\n  pj.close_reason,\n  pj.closed_at,\n  pj.exit_price AS pj_exit_price,\n  pj.exit_time AS pj_exit_time,\n  pj.exit_reason AS pj_exit_reason,\n  -- Exit data from order_executions (most recent for this ticker/date/decision)\n  oe.fill_price AS exit_fill_price,\n  oe.filled_qty,\n  oe.alpaca_status,\n  oe.success AS order_success,\n  oe.decision_type AS oe_decision_type,\n  oe.execution_action,\n  oe.orchestration_reasoning,\n  oe.ai_confidence,\n  oe.executed_at AS exit_time,\n  -- Orchestration decision context\n  td.decision_type AS orch_decision_type,\n  td.reasoning AS orch_reasoning,\n  td.orchestration_confidence,\n  td.ai_confidence AS orch_ai_confidence,\n  td.current_trend,\n  td.current_rr,\n  td.tracked_entry_price,\n  td.tracked_side,\n  td.tracked_qty,\n  td.tracked_contract,\n  td.direction,\n  td.signal_summary AS orch_signal_summary,\n  td.position_action AS orch_position_action,\n  td.decision_time\nFROM trading.position_journal pj\nLEFT JOIN trading.order_executions oe\n  ON oe.ticker = pj.ticker\n  AND oe.trade_date = pj.trade_date\n  AND oe.profile = pj.profile\n  AND oe.decision_type IN ('EXIT', 'REDUCE_EXPOSURE', 'REVERSE')\nLEFT JOIN trading.trading_decisions td\n  ON td.ticker = pj.ticker\n  AND td.trade_date = pj.trade_date\n  AND td.profile = pj.profile\n  AND td.decision_type IN ('NEW_ENTRY', 'ADD_POSITION')\nWHERE pj.ticker = '${ticker}'\n  AND pj.trade_date = '${today}'\nORDER BY oe.executed_at DESC NULLS LAST, pj.entry_time DESC\nLIMIT 1;\n`;\n\nreturn {\n  json: {\n    _lifecycle_sql: fetchSQL,\n    _context: {\n      ticker,\n      profile,\n      trade_date: today,\n      decision_type: decisionType,\n      orchestration_result: orchResult\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        40480,
        33456
      ],
      "id": "d3000001-0001-4000-8000-000000000001",
      "name": "Gather Trade Data"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._lifecycle_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        40640,
        33456
      ],
      "id": "d3000001-0002-4000-8000-000000000002",
      "name": "Fetch Trade Lifecycle",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Gather Trade Data \u2014 Step 2: Merge DB results + orchestration context\n// Calculate P&L, determine outcome, prepare payload for AI Trade Evaluator\n\nfunction safeNum(x) {\n  if (x == null) return null;\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n}\n\n// Get context from Step 1\nlet context = {};\ntry {\n  context = $('Gather Trade Data').first().json._context || {};\n} catch {\n  context = {};\n}\n\nconst orchResult = context.orchestration_result || {};\n\n// Get DB row (from Fetch Trade Lifecycle Postgres node)\n// $json is the Postgres RETURNING output\nconst db = $json || {};\n\nconst ticker = db.ticker || context.ticker || 'UNKNOWN';\nconst profile = db.profile || context.profile || 'S';\nconst today = db.trade_date || context.trade_date || new Date().toISOString().slice(0, 10);\nconst decisionType = context.decision_type || db.oe_decision_type || 'UNKNOWN';\nconst now = new Date().toISOString();\n\n// Entry data \u2014 DB is source of truth, fallback to orchestration context\nconst entryPrice = safeNum(db.entry_price) || safeNum(db.tracked_entry_price) || safeNum(orchResult.signal_summary?.entry_premium) || null;\nconst entrySide = db.entry_side || db.tracked_side || orchResult.position_action?.side || null;\nconst entryQty = safeNum(db.entry_qty) || safeNum(db.tracked_qty) || safeNum(orchResult.position_action?.qty) || 1;\nconst contractSymbol = db.contract_symbol || db.tracked_contract || orchResult.signal_summary?.contract || null;\nconst entryTime = db.entry_time || db.decision_time || null;\n\n// Exit data \u2014 DB is source of truth\nconst exitPrice = safeNum(db.exit_fill_price) || safeNum(db.pj_exit_price) || null;\nconst exitTime = db.exit_time || db.pj_exit_time || db.closed_at || now;\nconst exitReason = db.close_reason || db.pj_exit_reason || db.execution_action || (decisionType + '_EXECUTED');\nconst orderSuccess = db.order_success === true;\n\n// Orchestration context\nconst entryConfidence = safeNum(db.orch_ai_confidence) || safeNum(db.ai_confidence) || safeNum(orchResult.ai_confidence) || null;\nconst entryTrend = db.current_trend || orchResult.current_trend || null;\nconst entryRR = safeNum(db.current_rr) || safeNum(orchResult.current_rr) || null;\nconst orchReasoning = db.orchestration_reasoning || db.orch_reasoning || orchResult.reasoning || null;\nconst entryDecision = db.orch_decision_type || orchResult.decision_type || null;\n\n// Signal summary from DB or orchestration\nlet signalSummary = {};\ntry {\n  signalSummary = typeof db.orch_signal_summary === 'string' ? JSON.parse(db.orch_signal_summary) : (db.orch_signal_summary || orchResult.signal_summary || {});\n} catch { signalSummary = orchResult.signal_summary || {}; }\n\nlet posAction = {};\ntry {\n  posAction = typeof db.orch_position_action === 'string' ? JSON.parse(db.orch_position_action) : (db.orch_position_action || orchResult.position_action || {});\n} catch { posAction = orchResult.position_action || {}; }\n\n// Calculate P&L\nlet priceChange = null;\nlet priceChangePct = null;\nlet pnlPerContract = null;\nlet pnlTotal = null;\nlet outcome = 'BREAKEVEN';\n\nif (entryPrice != null && exitPrice != null) {\n  priceChange = exitPrice - entryPrice;\n  priceChangePct = entryPrice !== 0 ? (priceChange / entryPrice) * 100 : null;\n  pnlPerContract = priceChange * 100; // options multiplier\n  pnlTotal = pnlPerContract * (entryQty || 1);\n\n  if (priceChange > 0.005) outcome = 'POSITIVE';\n  else if (priceChange < -0.005) outcome = 'NEGATIVE';\n  else outcome = 'BREAKEVEN';\n}\n\n// Hold duration\nlet holdDurationMin = null;\nif (entryTime && exitTime) {\n  const entryMs = Date.parse(entryTime);\n  const exitMs = Date.parse(exitTime);\n  if (Number.isFinite(entryMs) && Number.isFinite(exitMs)) {\n    holdDurationMin = Math.round((exitMs - entryMs) / 60000);\n  }\n}\n\nreturn {\n  json: {\n    ticker,\n    profile,\n    trade_date: today,\n    decision_type: decisionType,\n    contract_symbol: contractSymbol,\n    entry_price: entryPrice,\n    entry_time: entryTime,\n    entry_side: entrySide,\n    entry_qty: entryQty,\n    exit_price: exitPrice,\n    exit_time: exitTime,\n    exit_reason: exitReason,\n    price_change: priceChange,\n    price_change_pct: priceChangePct,\n    pnl_per_contract: pnlPerContract,\n    pnl_total: pnlTotal,\n    outcome,\n    hold_duration_minutes: holdDurationMin,\n    entry_confidence: entryConfidence,\n    entry_trend_direction: entryTrend,\n    entry_option_decision: entryDecision,\n    entry_risk_reward: entryRR,\n    orchestration_reasoning: orchReasoning,\n    signal_summary: signalSummary,\n    position_action: posAction\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        40800,
        33456
      ],
      "id": "d3000001-0003-4000-8000-000000000003",
      "name": "Compute Trade P&L"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        41120,
        33760
      ],
      "id": "d3000002-0001-4000-8000-000000000001",
      "name": "OpenAI Chat Model (Evaluator)",
      "credentials": {
        "openAiApi": {
          "id": "yxVkFtwSghktPWAk",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "eval_session"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        41328,
        33760
      ],
      "id": "d3000002-0002-4000-8000-000000000002",
      "name": "Simple Memory (Evaluator)"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify($json, null, 2) }}",
        "options": {
          "systemMessage": "You are the AI Trade Evaluation Agent \u2014 a ruthless but fair post-trade analyst.\n\nYour job is to CRITIQUE what the Orchestration Agent did after a trade has been CLOSED.\nYou receive the full trade data: entry price, exit price, P&L, hold duration,\nthe orchestration reasoning, signal quality, and market context.\n\nYou must evaluate the trade objectively and output STRICT JSON (no markdown).\n\nINPUT FIELDS YOU RECEIVE:\n- ticker, profile, trade_date\n- decision_type: EXIT / REDUCE_EXPOSURE / REVERSE\n- contract_symbol: the option contract traded\n- entry_price, exit_price: premium prices\n- price_change: exit - entry\n- price_change_pct: percentage change\n- pnl_per_contract, pnl_total: realized P&L\n- outcome: POSITIVE / NEGATIVE / BREAKEVEN\n- hold_duration_minutes: how long position was held\n- entry_confidence: AI confidence at entry time\n- entry_trend_direction: trend at entry\n- entry_option_decision: BUY_CALL / BUY_PUT\n- entry_risk_reward: planned R:R\n- orchestration_reasoning: why the orchestrator entered\n- signal_summary: signal data at entry time\n- position_action: position sizing data\n\nEVALUATION CRITERIA:\n\n1. OUTCOME ASSESSMENT:\n   - Was the trade profitable? By how much?\n   - Did it hit target or stop? Or was it closed early?\n   - How does actual R:R compare to planned R:R?\n\n2. SIGNAL QUALITY (rate: EXCELLENT / GOOD / FAIR / POOR):\n   - Was the entry signal strong (high confidence, aligned timeframes)?\n   - Did the trend support the direction taken?\n   - Were candlestick patterns confirming?\n\n3. TIMING QUALITY (rate: EXCELLENT / GOOD / FAIR / POOR):\n   - Was entry timing good (near support/resistance)?\n   - Was exit timing good (captured move, avoided reversal)?\n   - Was hold duration appropriate for the timeframe profile?\n\n4. RISK MANAGEMENT QUALITY (rate: EXCELLENT / GOOD / FAIR / POOR):\n   - Were stop and target levels reasonable?\n   - Was position sizing appropriate?\n   - Was the risk:reward ratio acceptable before entry?\n\n5. OVERALL GRADE (A/B/C/D/F) and SCORE (0-100):\n   A (90-100): Excellent execution, good entry, good exit, profitable\n   B (75-89): Good trade, minor issues, mostly profitable\n   C (60-74): Average trade, some mistakes, breakeven or small loss\n   D (40-59): Poor trade, significant mistakes, notable loss\n   F (0-39): Bad trade, major errors in judgment\n\n   IMPORTANT: A losing trade CAN get a B or even A if the process was sound\n   (good signal, proper risk management, just got stopped out).\n   A winning trade CAN get a C or D if the process was poor\n   (weak signal, oversized, got lucky).\n\n6. CRITIQUE the orchestration agent specifically:\n   - What did the orchestration agent do WELL?\n   - What did it do WRONG?\n   - What LESSONS should it learn for next time?\n   - WOULD YOU take this trade again given the same signals?\n\nOUTPUT FORMAT (STRICT JSON, no markdown):\n{\n  \"evaluation_grade\": \"A\"|\"B\"|\"C\"|\"D\"|\"F\",\n  \"evaluation_score\": number (0-100),\n  \"outcome_summary\": string (1-2 sentences on P&L result),\n  \"signal_quality\": \"EXCELLENT\"|\"GOOD\"|\"FAIR\"|\"POOR\",\n  \"timing_quality\": \"EXCELLENT\"|\"GOOD\"|\"FAIR\"|\"POOR\",\n  \"risk_management_quality\": \"EXCELLENT\"|\"GOOD\"|\"FAIR\"|\"POOR\",\n  \"critique\": string (3-5 sentences, direct and honest),\n  \"what_went_well\": string (2-3 bullet points),\n  \"what_went_wrong\": string (2-3 bullet points, or 'Nothing major' if trade was good),\n  \"lessons_learned\": string (2-3 actionable takeaways),\n  \"would_take_again\": boolean,\n  \"improvement_suggestions\": string[] (2-3 specific suggestions for the orchestration agent)\n}\n\nRULES:\n- Be HONEST and DIRECT. Do not sugarcoat losses.\n- Focus on PROCESS over OUTCOME. A good process with a bad outcome is better than a bad process with a good outcome.\n- If entry_price or exit_price is null, note data is incomplete but still evaluate what you can.\n- If outcome is BREAKEVEN, focus on whether the trade thesis was valid.\n- Always reference specific numbers (entry/exit prices, P&L, hold time) in your critique.\n- Keep critique concise but actionable."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        41120,
        33456
      ],
      "id": "d3000002-0003-4000-8000-000000000003",
      "name": "AI Trade Evaluator"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build Evaluation Persist SQL\n// Parses the AI Trade Evaluator output and inserts into trade_evaluations.\n\nfunction stripCodeFences(s) {\n  if (typeof s !== 'string') return s;\n  let t = s.trim();\n  t = t.replace(/^```(?:json)?\\s*/i, '');\n  t = t.replace(/\\s*```$/i, '');\n  return t.trim();\n}\n\nfunction parseMaybeJson(x) {\n  if (x == null) return null;\n  if (typeof x === 'object') return x;\n  if (typeof x !== 'string') return null;\n  const t = stripCodeFences(x);\n  try { return JSON.parse(t); } catch { return null; }\n}\n\nfunction safeStr(s, maxLen) {\n  if (s == null) return 'NULL';\n  const v = String(s).replace(/'/g, \"''\").substring(0, maxLen || 4000);\n  return \"'\" + v + \"'\";\n}\n\nfunction safeNum(x) {\n  if (x == null) return 'NULL';\n  const n = Number(x);\n  return Number.isFinite(n) ? n : 'NULL';\n}\n\nfunction safeBool(x) {\n  if (x == null) return 'NULL';\n  return x === true ? 'true' : 'false';\n}\n\n// Parse AI output\nconst aiRaw = $json.output || $json.text || $json.response || null;\nconst aiParsed = parseMaybeJson(aiRaw) || {};\n\n// Get trade data from upstream Compute Trade P&L node\nlet tradeData = {};\ntry {\n  tradeData = $('Compute Trade P&L').first().json || {};\n} catch {\n  tradeData = {};\n}\n\nconst ticker = tradeData.ticker || 'UNKNOWN';\nconst profile = tradeData.profile || 'S';\nconst today = tradeData.trade_date || new Date().toISOString().slice(0, 10);\n\nconst sql = `\nINSERT INTO trading.trade_evaluations (\n  ticker, profile, trade_date,\n  decision_type, contract_symbol,\n  entry_price, entry_time, entry_side, entry_qty,\n  exit_price, exit_time, exit_reason,\n  price_change, price_change_pct, pnl_per_contract, pnl_total,\n  outcome, hold_duration_minutes,\n  entry_confidence, entry_trend_direction, entry_option_decision, entry_risk_reward,\n  evaluation_grade, evaluation_score, critique,\n  what_went_well, what_went_wrong, lessons_learned, would_take_again,\n  signal_quality, timing_quality, risk_management_quality,\n  entry_snapshot, exit_snapshot, raw_evaluation\n) VALUES (\n  '${ticker}', '${profile}', '${today}',\n  ${safeStr(tradeData.decision_type, 30)}, ${safeStr(tradeData.contract_symbol, 60)},\n  ${safeNum(tradeData.entry_price)}, ${tradeData.entry_time ? \"'\" + tradeData.entry_time + \"'\" : 'NULL'}, ${safeStr(tradeData.entry_side, 10)}, ${safeNum(tradeData.entry_qty)},\n  ${safeNum(tradeData.exit_price)}, ${tradeData.exit_time ? \"'\" + tradeData.exit_time + \"'\" : 'NOW()'}, ${safeStr(tradeData.exit_reason, 30)},\n  ${safeNum(tradeData.price_change)}, ${safeNum(tradeData.price_change_pct)}, ${safeNum(tradeData.pnl_per_contract)}, ${safeNum(tradeData.pnl_total)},\n  '${tradeData.outcome || 'BREAKEVEN'}', ${safeNum(tradeData.hold_duration_minutes)},\n  ${safeNum(tradeData.entry_confidence)}, ${safeStr(tradeData.entry_trend_direction, 20)}, ${safeStr(tradeData.entry_option_decision, 20)}, ${safeNum(tradeData.entry_risk_reward)},\n  ${safeStr(aiParsed.evaluation_grade, 5)}, ${safeNum(aiParsed.evaluation_score)}, ${safeStr(aiParsed.critique, 4000)},\n  ${safeStr(aiParsed.what_went_well, 4000)}, ${safeStr(aiParsed.what_went_wrong, 4000)}, ${safeStr(aiParsed.lessons_learned, 4000)}, ${safeBool(aiParsed.would_take_again)},\n  ${safeStr(aiParsed.signal_quality, 20)}, ${safeStr(aiParsed.timing_quality, 20)}, ${safeStr(aiParsed.risk_management_quality, 20)},\n  '${JSON.stringify(tradeData.signal_summary || {}).replace(/'/g, \"''\")}'::jsonb,\n  '${JSON.stringify({ exit_price: tradeData.exit_price, exit_time: tradeData.exit_time, exit_reason: tradeData.exit_reason }).replace(/'/g, \"''\")}'::jsonb,\n  '${JSON.stringify(aiParsed).replace(/'/g, \"''\").substring(0, 8000)}'::jsonb\n)\nRETURNING *;\n`;\n\n// Build Telegram alert text\nconst outcomeEmoji = tradeData.outcome === 'POSITIVE' ? '\\u2705' : tradeData.outcome === 'NEGATIVE' ? '\\u274C' : '\\u2796';\nconst gradeEmoji = { A: '\\u2B50', B: '\\uD83D\\uDC4D', C: '\\uD83E\\uDD37', D: '\\uD83D\\uDC4E', F: '\\uD83D\\uDCA5' };\n\nconst lines = [];\nlines.push(`\\uD83D\\uDCCA AI Trade Evaluation: ${ticker}`);\nlines.push(`${outcomeEmoji} Outcome: ${tradeData.outcome || 'n/a'}`);\nlines.push(`Grade: ${aiParsed.evaluation_grade || 'n/a'} ${gradeEmoji[aiParsed.evaluation_grade] || ''} (Score: ${aiParsed.evaluation_score ?? 'n/a'}/100)`);\nlines.push('');\nlines.push(`Entry: $${tradeData.entry_price ?? 'n/a'} | Exit: $${tradeData.exit_price ?? 'n/a'}`);\nlines.push(`P&L/contract: $${tradeData.pnl_per_contract != null ? tradeData.pnl_per_contract.toFixed(2) : 'n/a'} | Total: $${tradeData.pnl_total != null ? tradeData.pnl_total.toFixed(2) : 'n/a'}`);\nlines.push(`Change: ${tradeData.price_change_pct != null ? tradeData.price_change_pct.toFixed(1) + '%' : 'n/a'} | Hold: ${tradeData.hold_duration_minutes ?? 'n/a'} min`);\nlines.push('');\nlines.push(`Signal: ${aiParsed.signal_quality || 'n/a'} | Timing: ${aiParsed.timing_quality || 'n/a'} | Risk Mgmt: ${aiParsed.risk_management_quality || 'n/a'}`);\nlines.push('');\nlines.push(`Critique: ${aiParsed.critique || 'n/a'}`);\nlines.push('');\nlines.push(`\\u2705 Well: ${aiParsed.what_went_well || 'n/a'}`);\nlines.push(`\\u274C Wrong: ${aiParsed.what_went_wrong || 'n/a'}`);\nlines.push(`\\uD83D\\uDCA1 Lessons: ${aiParsed.lessons_learned || 'n/a'}`);\nlines.push(`Would take again: ${aiParsed.would_take_again === true ? 'Yes' : aiParsed.would_take_again === false ? 'No' : 'n/a'}`);\n\nreturn {\n  json: {\n    ...$json,\n    _eval_persist_sql: sql,\n    _eval_telegram_text: lines.join('\\n'),\n    _eval_data: aiParsed,\n    _trade_data: tradeData\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        41520,
        33456
      ],
      "id": "d3000003-0001-4000-8000-000000000001",
      "name": "Build Eval Persist SQL"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json._eval_persist_sql }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        41840,
        33456
      ],
      "id": "d3000003-0002-4000-8000-000000000002",
      "name": "Persist Evaluation",
      "credentials": {
        "postgres": {
          "id": "qqHq6YBsTYNayjPo",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "chatId": "-4857387406",
        "text": "={{ $('Build Eval Persist SQL').first().json._eval_telegram_text.replace(/_/g,'\\\\_') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        42160,
        33456
      ],
      "id": "d3000004-0001-4000-8000-000000000001",
      "name": "Telegram Evaluation",
      "webhookId": "d3000004-tg01-4000-8000-000000000001",
      "credentials": {
        "telegramApi": {
          "id": "s7F5Kgl3bvhQzcEM",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "orch-gate-skip",
              "leftValue": "={{ $json._skip_orchestrator }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        37200,
        33056
      ],
      "id": "e1000001-gate-4000-8000-000000000001",
      "name": "Orchestrator Gate"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Skip Orchestrator \u2014 Deterministic WAIT\n// When the Orchestrator Gate determines AI is not needed\n// (low confidence, no positions, no directional signal),\n// this node produces a deterministic WAIT decision that\n// matches the format of Save Orchestration Decision output.\n// This saves an AI API call every 5-minute cycle.\n\nconst $json = items[0].json;\nconst orchestration = $json._orchestration || {};\nconst signal = orchestration.signal_snapshot || {};\nconst ticker = signal.ticker || $json.ticker || 'UNKNOWN';\nconst profile = signal.profile || $json.profile || 'S';\nconst today = new Date().toISOString().slice(0, 10);\nconst now = new Date().toISOString();\nconst signalId = orchestration.inserted_signal_id || null;\nconst skipReason = $json._skip_reason || 'Low confidence, no positions \u2014 skipped AI';\n\nconst confidence = signal.confidence;\nconst confPct = (confidence != null && confidence > 0 && confidence <= 1) ? Math.round(confidence * 100) : (confidence != null ? Math.round(confidence) : null);\n\n// Build deterministic WAIT decision\nconst decisionType = 'WAIT';\nconst reasoning = `Deterministic WAIT \u2014 ${skipReason}. AI orchestrator skipped to conserve quota.`;\n\nconst posAction = { action: 'NONE', side: null, qty_change: 0, new_total_qty: 0 };\nconst signalSummary = {\n  option_decision: signal.ai_option_decision || 'WAIT',\n  confidence: confidence,\n  trend: signal.trend_direction || null,\n  alignment: signal.alignment || null,\n  contract: signal.option_details?.contract_symbol || null\n};\nconst entryStrategy = {\n  stage: 'NOT_APPLICABLE',\n  confirmation_count: 0,\n  signal_direction: null,\n  confirmations_needed: 3,\n  override_triggered: false,\n  notes: 'Skipped AI \u2014 low confidence with no positions to manage'\n};\nconst streakContext = 'AI skipped \u2014 no positions, low confidence';\nconst riskNotes = '';\n\n// Build INSERT SQL (same as Save Orchestration Decision)\nconst reasoningEsc = reasoning.replace(/'/g, \"''\");\nconst streakContextEsc = streakContext.replace(/'/g, \"''\");\n\n// Confirmation record\nconst lastDecisions = orchestration.decision_history || [];\nconst lastDecision = lastDecisions[0] || null;\nlet confirmationType = 'CONFIRM';\nif (lastDecision && lastDecision.decision_type !== 'WAIT') {\n  confirmationType = 'CONTRADICT';\n}\n\n// Use CTE to link decision_id to confirmation record\nconst combinedSQL = `\\nWITH new_decision AS (\\n  INSERT INTO trading.trading_decisions (\\n    ticker, profile, trade_date, signal_snapshot_id,\\n    decision_type, reasoning, ai_confidence,\\n    position_action, signal_summary, streak_context\\n  ) VALUES (\\n    '${ticker}', '${profile}', '${today}',\\n    ${signalId ? \"'\" + signalId + \"'\" : 'NULL'},\\n    '${decisionType}',\\n    '${reasoningEsc}',\\n    ${confidence != null ? confidence : 'NULL'},\\n    '${JSON.stringify(posAction)}'::jsonb,\\n    '${JSON.stringify(signalSummary)}'::jsonb,\\n    ${streakContextEsc ? \"'\" + streakContextEsc + \"'\" : 'NULL'}\\n  ) RETURNING id\\n)\\nINSERT INTO trading.decision_confirmations (\\n  ticker, trade_date, decision_id, confirmation_type, notes\\n) SELECT\\n  '${ticker}', '${today}', new_decision.id,\\n  '${confirmationType}',\\n  '${streakContextEsc}'\\nFROM new_decision\\nRETURNING *;\\n`;\n\n// Telegram text\nconst orchLines = [];\norchLines.push(`\\u23f3 AI Orchestrator: WAIT (skipped \u2014 quota saved)`);\norchLines.push(`Ticker: ${ticker} | Profile: ${profile}`);\norchLines.push(`Reasoning: ${reasoning}`);\norchLines.push(`Confidence: ${confPct != null ? confPct + '%' : 'n/a'}`);\norchLines.push(`Signal: ${signalSummary.option_decision} | trend=${signalSummary.trend || 'n/a'}`);\n\nreturn [{\n  json: {\n    ...($json),\n    _suppress_telegram: true,\n    _orchestration_result: {\n      ticker: ticker,\n      profile: profile,\n      decision_type: decisionType,\n      reasoning: reasoning,\n      ai_confidence: confidence,\n      position_action: posAction,\n      signal_summary: signalSummary,\n      confirmation_type: confirmationType,\n      entry_strategy: entryStrategy,\n      risk_notes: riskNotes,\n      streak_context: streakContext,\n      sql: combinedSQL,\n      telegram_text: orchLines.join('\\n')\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        37360,
        33256
      ],
      "id": "e1000002-skip-4000-8000-000000000001",
      "name": "Skip Orchestrator (WAIT)"
    }
  ],
  "pinData": {
    "Schedule Trigger": [
      {
        "json": {
          "timestamp": "2026-01-19T16:30:00.001+00:00",
          "Readable date": "January 19th 2026, 4:30:00 pm",
          "Readable time": "4:30:00 pm",
          "Day of week": "Monday",
          "Year": "2026",
          "Month": "January",
          "Day of month": "19",
          "Hour": "16",
          "Minute": "30",
          "Second": "00",
          "Timezone": "UTC (UTC+00:00)"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "connections": {
    "Set Params": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Build AI Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Indicator Analyst",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Create Chart ID": {
      "main": [
        [
          {
            "node": "Create Exchange",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search ticker on yahoo finance": {
      "main": [
        [
          {
            "node": "Code Sticker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Sticker": {
      "main": [
        [
          {
            "node": "Set Params",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Output Telegram": {
      "main": [
        [
          {
            "node": "Insert row",
            "type": "main",
            "index": 0
          },
          {
            "node": "Day Trade Report Validation",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send a text message": {
      "main": [
        [
          {
            "node": "Create Chart ID",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Signal Snapshot",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Profile": {
      "main": [
        [
          {
            "node": "Set Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build AI Payload": {
      "main": [
        [
          {
            "node": "Derive Option Intent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Confidence": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Request": {
      "main": [
        [
          {
            "node": "Search ticker on yahoo finance",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert row": {
      "main": [
        []
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Indicator Analyst",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Indicator Analyst": {
      "main": [
        [
          {
            "node": "Normalize Confidence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculator": {
      "ai_tool": [
        [
          {
            "node": "AI Indicator Analyst",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Effective End": {
      "main": [
        [
          {
            "node": "Set Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Normalize Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Results": {
      "main": [
        [
          {
            "node": "Code in JavaScript3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request2": {
      "main": [
        [
          {
            "node": "Code in JavaScript2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Code in JavaScript4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript2": {
      "main": [
        [
          {
            "node": "Code in JavaScript5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript3": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript4": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Code in JavaScript5": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Clock1": {
      "main": [
        [
          {
            "node": "Code in JavaScript6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript6": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "Set Effective End",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram Trigger": {
      "main": [
        [
          {
            "node": "Get Profile",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Order Payload": {
      "main": [
        [
          {
            "node": "If Order1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Order1": {
      "main": [
        [
          {
            "node": "Submit Order",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "HTTP Account": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Size": {
      "main": [
        [
          {
            "node": "Parse Order Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Output Telegram",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Output Telegram",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Output Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Submit Order": {
      "main": [
        [
          {
            "node": "Normalize Order",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Order": {
      "main": [
        [
          {
            "node": "Build ORDER Persist SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build ORDER Persist SQL": {
      "main": [
        [
          {
            "node": "Persist ORDER",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist ORDER": {
      "main": [
        [
          {
            "node": "Insert row1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Derive Option Intent": {
      "main": [
        [
          {
            "node": "Get Option Contracts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Option Contracts": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get Option Snapshot": {
      "main": [
        [
          {
            "node": "Enrich Payload for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Payload for AI": {
      "main": [
        [
          {
            "node": "Compute Option Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Option Snapshots (Shortlist)": {
      "main": [
        [
          {
            "node": "Merge Snapshots (Keep Input)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Select Contract (Liquid)": {
      "main": [
        [
          {
            "node": "Compare Candidates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Liquidity OK?": {
      "main": [
        [
          {
            "node": "Get Option Snapshot",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Force WAIT (Liquidity Gate)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Force WAIT (Liquidity Gate)": {
      "main": [
        [
          {
            "node": "Enrich Payload for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select Contract (Shortlist)": {
      "main": [
        [
          {
            "node": "Get Option Snapshots (Shortlist)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Snapshots (Keep Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Trend & Confidence": {
      "main": [
        [
          {
            "node": "Enforce Desired Right",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compare Candidates": {
      "main": [
        [
          {
            "node": "Liquidity OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Select Contract (Shortlist)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Compute Size",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        []
      ]
    },
    "Decision Router": {
      "main": [
        [
          {
            "node": "HTTP Account",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Notify CONFIRM_HOLD",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Account",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare REDUCE",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare REVERSE Close",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare EXIT",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Notify WAIT",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Notify CONFIRM_HOLD": {
      "main": [
        [
          {
            "node": "Build HOLD Persist SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build HOLD Persist SQL": {
      "main": [
        [
          {
            "node": "Persist HOLD",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist HOLD": {
      "main": [
        [
          {
            "node": "Telegram CONFIRM_HOLD",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram CONFIRM_HOLD": {
      "main": [
        []
      ]
    },
    "Prepare EXIT": {
      "main": [
        [
          {
            "node": "Close Position (EXIT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Close Position (EXIT)": {
      "main": [
        [
          {
            "node": "Format EXIT Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format EXIT Result": {
      "main": [
        [
          {
            "node": "Build EXIT Persist SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build EXIT Persist SQL": {
      "main": [
        [
          {
            "node": "Persist EXIT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist EXIT": {
      "main": [
        [
          {
            "node": "Telegram EXIT",
            "type": "main",
            "index": 0
          },
          {
            "node": "Gather Trade Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram EXIT": {
      "main": [
        []
      ]
    },
    "Prepare REDUCE": {
      "main": [
        [
          {
            "node": "Sell to Close (REDUCE)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sell to Close (REDUCE)": {
      "main": [
        [
          {
            "node": "Format REDUCE Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format REDUCE Result": {
      "main": [
        [
          {
            "node": "Build REDUCE Persist SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build REDUCE Persist SQL": {
      "main": [
        [
          {
            "node": "Persist REDUCE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist REDUCE": {
      "main": [
        [
          {
            "node": "Telegram REDUCE",
            "type": "main",
            "index": 0
          },
          {
            "node": "Gather Trade Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram REDUCE": {
      "main": [
        []
      ]
    },
    "Prepare REVERSE Close": {
      "main": [
        [
          {
            "node": "Close Position (REVERSE)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Close Position (REVERSE)": {
      "main": [
        [
          {
            "node": "Format REVERSE Close",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format REVERSE Close": {
      "main": [
        [
          {
            "node": "Build REVERSE Persist SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build REVERSE Persist SQL": {
      "main": [
        [
          {
            "node": "Persist REVERSE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist REVERSE": {
      "main": [
        [
          {
            "node": "Telegram REVERSE Close",
            "type": "main",
            "index": 0
          },
          {
            "node": "Gather Trade Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram REVERSE Close": {
      "main": [
        [
          {
            "node": "If REVERSE Close OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If REVERSE Close OK": {
      "main": [
        [
          {
            "node": "HTTP Account",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Notify WAIT": {
      "main": [
        [
          {
            "node": "Build WAIT Persist SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build WAIT Persist SQL": {
      "main": [
        [
          {
            "node": "Persist WAIT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist WAIT": {
      "main": [
        [
          {
            "node": "Telegram WAIT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram WAIT": {
      "main": [
        []
      ]
    },
    "Enforce Desired Right": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Option Metrics": {
      "main": [
        [
          {
            "node": "Replace Get Option Bars (Selected)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Option ATR Stops/TP": {
      "main": [
        [
          {
            "node": "Compute Trend & Confidence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Replace Get Option Bars (Selected)": {
      "main": [
        [
          {
            "node": "Compute Option ATR Stops/TP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Clock1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "AI Indicator Analyst",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Save Signal Snapshot",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Snapshots (Keep Input)": {
      "main": [
        [
          {
            "node": "Select Contract (Liquid)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Day Trade Report Validation",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory1": {
      "ai_memory": [
        [
          {
            "node": "Day Trade Report Validation",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [],
        [
          {
            "node": "Render Verification Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Day Trade Report Validation": {
      "main": [
        [
          {
            "node": "Code in JavaScript7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Render Verification Report": {
      "main": [
        [
          {
            "node": "Send a text message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript7": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Signal Snapshot": {
      "main": [
        [
          {
            "node": "Sync Broker State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sync Broker State": {
      "main": [
        [
          {
            "node": "Persist Broker State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist Broker State": {
      "main": [
        [
          {
            "node": "Query Decision History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Decision History": {
      "main": [
        [
          {
            "node": "Build Orchestrator Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Orchestrator Context": {
      "main": [
        [
          {
            "node": "Orchestrator Gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "AI Decision Orchestrator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory2": {
      "ai_memory": [
        [
          {
            "node": "AI Decision Orchestrator",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AI Decision Orchestrator": {
      "main": [
        [
          {
            "node": "Save Orchestration Decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Orchestrator Gate": {
      "main": [
        [
          {
            "node": "AI Decision Orchestrator",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Orchestrator (WAIT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Orchestrator (WAIT)": {
      "main": [
        [
          {
            "node": "Persist Decision",
            "type": "main",
            "index": 0
          },
          {
            "node": "Suppress Dup Telegram",
            "type": "main",
            "index": 0
          },
          {
            "node": "Decision Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Orchestration Decision": {
      "main": [
        [
          {
            "node": "Persist Decision",
            "type": "main",
            "index": 0
          },
          {
            "node": "Suppress Dup Telegram",
            "type": "main",
            "index": 0
          },
          {
            "node": "Decision Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist Decision": {
      "main": [
        []
      ]
    },
    "Suppress Dup Telegram": {
      "main": [
        [
          {
            "node": "Orchestration Telegram",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Gather Trade Data": {
      "main": [
        [
          {
            "node": "Fetch Trade Lifecycle",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Trade Lifecycle": {
      "main": [
        [
          {
            "node": "Compute Trade P&L",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Trade P&L": {
      "main": [
        [
          {
            "node": "AI Trade Evaluator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model (Evaluator)": {
      "ai_languageModel": [
        [
          {
            "node": "AI Trade Evaluator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory (Evaluator)": {
      "ai_memory": [
        [
          {
            "node": "AI Trade Evaluator",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AI Trade Evaluator": {
      "main": [
        [
          {
            "node": "Build Eval Persist SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Eval Persist SQL": {
      "main": [
        [
          {
            "node": "Persist Evaluation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Persist Evaluation": {
      "main": [
        [
          {
            "node": "Telegram Evaluation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram Evaluation": {
      "main": [
        []
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "489f0dab-91cd-463c-942a-d75aa42b5efc",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "dca74b7defb74ff98bf878328bd6cd3d02921b10dd24a3f6f6fd90e41a53b557"
  },
  "id": "r2VpB3W8rAUSHPIn",
  "tags": []
}